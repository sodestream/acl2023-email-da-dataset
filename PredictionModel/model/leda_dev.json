[{"current_segment": {"sid": 5, "labels": "InformationProviding", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Real-Time Communication in WEB-browsers Working Group of the IETF."}, "context_segments": []}, {"current_segment": {"sid": 5114, "labels": "InformationProviding", "content": "\n1515-1525 The Session Description Protocol (SDP)      James Polk\n'servclass' Attribute\ndraft-polk-mmusic-traffic-class-for-sdp-00.txt"}, "context_segments": [{"sid": 5, "labels": "InformationProviding", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Real-Time Communication in WEB-browsers Working Group of the IETF."}]}, {"current_segment": {"sid": 7328, "labels": "Social", "content": "Hi,"}, "context_segments": [{"sid": 5, "labels": "InformationProviding", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Real-Time Communication in WEB-browsers Working Group of the IETF."}, {"sid": 5114, "labels": "InformationProviding", "content": "\n1515-1525 The Session Description Protocol (SDP)      James Polk\n'servclass' Attribute\ndraft-polk-mmusic-traffic-class-for-sdp-00.txt"}]}, {"current_segment": {"sid": 6, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nTitle           : Web Real-Time Communication Use-cases and Requirements\nAuthors         : Christer Holmberg\nStefan Hakansson\nGoran AP Eriksson\nFilename        : draft-ietf-rtcweb-use-cases-and-requirements-16.txt\nPages           : 34\nDate            : 2015-01-23"}, "context_segments": []}, {"current_segment": {"sid": 5115, "labels": "InformationProviding", "content": "\n1525-1540 TCP Candidates with Interactive             Ari Keranen\nConnectivity Establishment (ICE)\\\ndraft-ietf-mmusic-ice-tcp-09.txt"}, "context_segments": [{"sid": 6, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nTitle           : Web Real-Time Communication Use-cases and Requirements\nAuthors         : Christer Holmberg\nStefan Hakansson\nGoran AP Eriksson\nFilename        : draft-ietf-rtcweb-use-cases-and-requirements-16.txt\nPages           : 34\nDate            : 2015-01-23"}]}, {"current_segment": {"sid": 7329, "labels": "Social", "content": "Daniel,\n"}, "context_segments": [{"sid": 6, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nTitle           : Web Real-Time Communication Use-cases and Requirements\nAuthors         : Christer Holmberg\nStefan Hakansson\nGoran AP Eriksson\nFilename        : draft-ietf-rtcweb-use-cases-and-requirements-16.txt\nPages           : 34\nDate            : 2015-01-23"}, {"sid": 5115, "labels": "InformationProviding", "content": "\n1525-1540 TCP Candidates with Interactive             Ari Keranen\nConnectivity Establishment (ICE)\\\ndraft-ietf-mmusic-ice-tcp-09.txt"}]}, {"current_segment": {"sid": 7, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nAbstract:\nThis document describes web based real-time communication use-cases.\nRequirements on the browser functionality are derived from the use-\ncases."}, "context_segments": []}, {"current_segment": {"sid": 5116, "labels": "InformationProviding", "content": "\n1540-1555 Grouping of Adjacent Media in the Session   Ali Begen\nDescription Protocol\ndraft-jennings-mmusic-adjacent-grouping-01.txt"}, "context_segments": [{"sid": 7, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nAbstract:\nThis document describes web based real-time communication use-cases.\nRequirements on the browser functionality are derived from the use-\ncases."}]}, {"current_segment": {"sid": 7330, "labels": "InformationProviding,InformationProviding,NeutralResponse", "content": "\nThat said, I will need to defer to others to confirm the details of the EdDSA usage as I do not have experience with those crypto algorithms.\n\nOne minor editorial nit. In section 4 there are multiple references to the \"Chapter\" of another draft. Example:\n\nThe Ed25519 signature algorithm is described in Chapter\n5.1.6 in [I-D.irtf-cfrg-eddsa<https://tools.ietf.org/html/draft-ietf-curdle-dnskey-eddsa-01#ref-I-D.irtf-cfrg-eddsa>].\n"}, "context_segments": [{"sid": 7, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nAbstract:\nThis document describes web based real-time communication use-cases.\nRequirements on the browser functionality are derived from the use-\ncases."}, {"sid": 5116, "labels": "InformationProviding", "content": "\n1540-1555 Grouping of Adjacent Media in the Session   Ali Begen\nDescription Protocol\ndraft-jennings-mmusic-adjacent-grouping-01.txt"}]}, {"current_segment": {"sid": 8, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThis document was developed in an initial phase of the work with\nrather minor updates at later stages.  It has not really served as a\ntool in deciding features or scope for the WGs efforts so far.  It is\nbeing published to record the early conclusions of the working group.\nIt will not be used as a set of rigid guidelines that specifications\nand implementations will be held to in the future."}, "context_segments": []}, {"current_segment": {"sid": 5117, "labels": "InformationProviding", "content": "\n1555-1610 Real Time Streaming Protocol 2.0 (RTSP)     Magnus Westerlund\ndraft-ietf-mmusic-rfc2326bis-24.txt             Martin Stiemerling"}, "context_segments": [{"sid": 8, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThis document was developed in an initial phase of the work with\nrather minor updates at later stages.  It has not really served as a\ntool in deciding features or scope for the WGs efforts so far.  It is\nbeing published to record the early conclusions of the working group.\nIt will not be used as a set of rigid guidelines that specifications\nand implementations will be held to in the future."}]}, {"current_segment": {"sid": 7331, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nIn US English a \"chapter\" is typically reserved for a \"book\". I think the better term here might be \"Section\", but I don't know if there is specific guidance anywhere on what to call areas of another I-D.\n"}, "context_segments": [{"sid": 8, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThis document was developed in an initial phase of the work with\nrather minor updates at later stages.  It has not really served as a\ntool in deciding features or scope for the WGs efforts so far.  It is\nbeing published to record the early conclusions of the working group.\nIt will not be used as a set of rigid guidelines that specifications\nand implementations will be held to in the future."}, {"sid": 5117, "labels": "InformationProviding", "content": "\n1555-1610 Real Time Streaming Protocol 2.0 (RTSP)     Magnus Westerlund\ndraft-ietf-mmusic-rfc2326bis-24.txt             Martin Stiemerling"}]}, {"current_segment": {"sid": 9, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe IETF datatracker status page for this draft is:\nhttps://datatracker.ietf.org/doc/draft-ietf-rtcweb-use-cases-and-requirements/"}, "context_segments": []}, {"current_segment": {"sid": 5118, "labels": "InformationProviding,ContextSetting,StateDecision", "content": "The IETF79 MMUSIC agenda has been posted. Since it is short, it is\nrepeated here."}, "context_segments": [{"sid": 9, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe IETF datatracker status page for this draft is:\nhttps://datatracker.ietf.org/doc/draft-ietf-rtcweb-use-cases-and-requirements/"}]}, {"current_segment": {"sid": 7332, "labels": "Thanking,Thanking,Social", "content": "\nThank you to the authors for moving this forward.\n"}, "context_segments": [{"sid": 9, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe IETF datatracker status page for this draft is:\nhttps://datatracker.ietf.org/doc/draft-ietf-rtcweb-use-cases-and-requirements/"}, {"sid": 5118, "labels": "InformationProviding,ContextSetting,StateDecision", "content": "The IETF79 MMUSIC agenda has been posted. Since it is short, it is\nrepeated here."}]}, {"current_segment": {"sid": 10, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThere's also a htmlized version available at:\nhttp://tools.ietf.org/html/draft-ietf-rtcweb-use-cases-and-requirements-16"}, "context_segments": []}, {"current_segment": {"sid": 5119, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nMMUSIC IETF79 Agenda"}, "context_segments": [{"sid": 10, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThere's also a htmlized version available at:\nhttp://tools.ietf.org/html/draft-ietf-rtcweb-use-cases-and-requirements-16"}]}, {"current_segment": {"sid": 7333, "labels": "InformationProviding,InformationProviding", "content": "\nThis message starts a Working Group Last Call (WGLC) for\ndraft-ietf-curdle-dnskey-eddsa-01."}, "context_segments": [{"sid": 10, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThere's also a htmlized version available at:\nhttp://tools.ietf.org/html/draft-ietf-rtcweb-use-cases-and-requirements-16"}, {"sid": 5119, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nMMUSIC IETF79 Agenda"}]}, {"current_segment": {"sid": 11, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA diff from the previous version is available at:\nhttp://www.ietf.org/rfcdiff?url2=draft-ietf-rtcweb-use-cases-and-requirements-16"}, "context_segments": []}, {"current_segment": {"sid": 5120, "labels": "InformationProviding", "content": "\nWednesday 1510-1610 Emerald Room\nFlemming Andreason and Tom Taylor, Co-Chairs"}, "context_segments": [{"sid": 11, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA diff from the previous version is available at:\nhttp://www.ietf.org/rfcdiff?url2=draft-ietf-rtcweb-use-cases-and-requirements-16"}]}, {"current_segment": {"sid": 7334, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe version to be reviewed is\nhttps://tools.ietf.org/html/draft-ietf-curdle-dnskey-eddsa-01"}, "context_segments": [{"sid": 11, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA diff from the previous version is available at:\nhttp://www.ietf.org/rfcdiff?url2=draft-ietf-rtcweb-use-cases-and-requirements-16"}, {"sid": 5120, "labels": "InformationProviding", "content": "\nWednesday 1510-1610 Emerald Room\nFlemming Andreason and Tom Taylor, Co-Chairs"}]}, {"current_segment": {"sid": 7335, "labels": "Question,Question,InformationProviding,NeutralResponse,InformationSeeking", "content": "\nDoes this use Ed25519 or Ed25519ctx?  It describes a context string,\nwhich Ed25519 throws away."}, "context_segments": [{"sid": 11, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA diff from the previous version is available at:\nhttp://www.ietf.org/rfcdiff?url2=draft-ietf-rtcweb-use-cases-and-requirements-16"}, {"sid": 5120, "labels": "InformationProviding", "content": "\nWednesday 1510-1610 Emerald Room\nFlemming Andreason and Tom Taylor, Co-Chairs"}, {"sid": 7334, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe version to be reviewed is\nhttps://tools.ietf.org/html/draft-ietf-curdle-dnskey-eddsa-01"}]}, {"current_segment": {"sid": 7336, "labels": "Answer,InformationProviding,Answer", "content": "\nWell, if it has context, it can't be Ed25519 (because that can't have\ncontext)... Dunno if that is wanted (note that Ed25519ctx can't be\ncomputed with standard issue Ed25519 code (white-box changes aren't\ngreat).\n\nAlso, even if I seemed to have come up with the idea, I don't like\nit now (due to usage difficulty).\n"}, "context_segments": [{"sid": 11, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA diff from the previous version is available at:\nhttp://www.ietf.org/rfcdiff?url2=draft-ietf-rtcweb-use-cases-and-requirements-16"}, {"sid": 5120, "labels": "InformationProviding", "content": "\nWednesday 1510-1610 Emerald Room\nFlemming Andreason and Tom Taylor, Co-Chairs"}, {"sid": 7334, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe version to be reviewed is\nhttps://tools.ietf.org/html/draft-ietf-curdle-dnskey-eddsa-01"}, {"sid": 7335, "labels": "Question,Question,InformationProviding,NeutralResponse,InformationSeeking", "content": "\nDoes this use Ed25519 or Ed25519ctx?  It describes a context string,\nwhich Ed25519 throws away."}]}, {"current_segment": {"sid": 12, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPlease note that it may take a couple of minutes from the time of submission\nuntil the htmlized version and diff are available at tools.ietf.org."}, "context_segments": []}, {"current_segment": {"sid": 5121, "labels": "InformationProviding", "content": "\n1510-1515 Working Group Status                        Chairs"}, "context_segments": [{"sid": 12, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPlease note that it may take a couple of minutes from the time of submission\nuntil the htmlized version and diff are available at tools.ietf.org."}]}, {"current_segment": {"sid": 7337, "labels": "Social", "content": "\n-Ilari"}, "context_segments": [{"sid": 12, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPlease note that it may take a couple of minutes from the time of submission\nuntil the htmlized version and diff are available at tools.ietf.org."}, {"sid": 5121, "labels": "InformationProviding", "content": "\n1510-1515 Working Group Status                        Chairs"}, {"sid": 7334, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe version to be reviewed is\nhttps://tools.ietf.org/html/draft-ietf-curdle-dnskey-eddsa-01"}, {"sid": 7335, "labels": "Question,Question,InformationProviding,NeutralResponse,InformationSeeking", "content": "\nDoes this use Ed25519 or Ed25519ctx?  It describes a context string,\nwhich Ed25519 throws away."}]}, {"current_segment": {"sid": 13, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nInternet-Drafts are also available by anonymous FTP at:\nftp://ftp.ietf.org/internet-drafts/"}, "context_segments": []}, {"current_segment": {"sid": 7338, "labels": "ExtensionOfPrevious,InformationProviding,ProposeAction", "content": "\nPlease send your comments, questions, and edit proposals to the WG mail\nlist until November 16th, 2016.  If you believe that the document is ready\nto be submitted to the IESG for consideration as a Standards Track RFC\nplease send a short message stating this."}, "context_segments": [{"sid": 13, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nInternet-Drafts are also available by anonymous FTP at:\nftp://ftp.ietf.org/internet-drafts/"}]}, {"current_segment": {"sid": 7339, "labels": "Social", "content": "\nYours,"}, "context_segments": []}, {"current_segment": {"sid": 7340, "labels": "Social", "content": "\nRich and Daniel"}, "context_segments": []}, {"current_segment": {"sid": 7341, "labels": "Thanking,InformationProviding,NeutralResponse,InformationProviding,NeutralResponse,Thanking,Social", "content": "\nthanks for the comment. I have just submitted an updated version\nof the draft where I resolved all the comments except this particular\none."}, "context_segments": []}, {"current_segment": {"sid": 7342, "labels": "ExtensionOfPrevious,Agreement,InformationProviding", "content": "\nI also have feeling that we don't have to explain *in the draft* why\nwe picked this particular algorithm."}, "context_segments": []}, {"current_segment": {"sid": 7343, "labels": "NeutralResponse,InformationProviding", "content": "> I also have feeling that we don't have to explain *in the draft* why we\n> picked this particular algorithm."}, "context_segments": [{"sid": 7342, "labels": "ExtensionOfPrevious,Agreement,InformationProviding", "content": "\nI also have feeling that we don't have to explain *in the draft* why\nwe picked this particular algorithm."}]}, {"current_segment": {"sid": 7344, "labels": "Agreement,InformationProviding,Agreement", "content": "\nMuch as I don't like to disagree with my co-chair :) I agree with you.  RFC's typically say \"how to do it.\"  Rationale's are usually left for the WG mailing list or perhaps conference papers :)"}, "context_segments": [{"sid": 7342, "labels": "ExtensionOfPrevious,Agreement,InformationProviding", "content": "\nI also have feeling that we don't have to explain *in the draft* why\nwe picked this particular algorithm."}]}, {"current_segment": {"sid": 7345, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nHere's the side by side diff for WG convenience:\nhttps://www.ietf.org/rfcdiff?url1=draft-ietf-curdle-dnskey-eddsa-01&url2=draft-ietf-curdle-dnskey-eddsa-02"}, "context_segments": []}, {"current_segment": {"sid": 7346, "labels": "Agreement,NeutralResponse,InformationProviding", "content": "Sounds like cross mailing list consensus ;-)"}, "context_segments": []}, {"current_segment": {"sid": 7347, "labels": "Social", "content": "Ilari and rest of WG,"}, "context_segments": []}, {"current_segment": {"sid": 7348, "labels": "InformationProviding,InformationProviding,NeutralResponse,ProposeAction", "content": "Dear all,\n\nI have incorporated the comments from Simon changing\nSecurity Considerations and removing the Section about\nImplementations.\n\nI have also clarified usage of context.  The context label\nis used only for Ed448.\n\nI have also updated the example for Ed25519, but I would\nreally appreciate if somebody could review the script\nused to generate the examples:\n\nhttps://gitlab.labs.nic.cz/labs/ietf/blob/master/dnskey.py\n\nThe updated drafts can't be uploaded, but I uploaded the\nlast version to our gitlab:\n\nXML: https://gitlab.labs.nic.cz/labs/ietf/raw/master/draft-ietf-curdle-dnskey-eddsa.xml\nTXT: https://gitlab.labs.nic.cz/labs/ietf/raw/master/draft-ietf-curdle-dnskey-eddsa.txt\nHTML: https://gitlab.labs.nic.cz/labs/ietf/raw/master/draft-ietf-curdle-dnskey-eddsa.html\n\nO.\nOnd\u0159ej Sur\u00fd -- Technical Fellow\nCZ.NIC, z.s.p.o.    --     Laborato\u0159e CZ.NIC\nMilesovska 5, 130 00 Praha 3, Czech Republic\nmailto:ondrej.sury@nic.cz    https://nic.cz/\n\n----- Original Message -----"}, "context_segments": []}, {"current_segment": {"sid": 7349, "labels": "InformationProviding,InformationProviding,ProposeAction", "content": "\nFor those that have not yet reviewed the document, the WGLC is almost\nending, so please provide your comments by the end of the week... or on\nyour way back!"}, "context_segments": []}, {"current_segment": {"sid": 7350, "labels": "Social", "content": "\nYours"}, "context_segments": []}, {"current_segment": {"sid": 7351, "labels": "Disagreement,InformationProviding", "content": "On 5 Nov 2016, at 10:00, Daniel Migault wrote:"}, "context_segments": []}, {"current_segment": {"sid": 7352, "labels": "InformationProviding,Agreement,InformationProviding,Agreement,ContextSetting,ProposeAction", "content": "The draft is in good shape. I agree with Simon that we should drop the\ncontext string and add the security consideration. If the WG agrees, it\nwould be good for us to have another week to review the revised document\n(and for people who have running code to re-run the test vectors.)\n\nI have a concern not with the draft, but with the comments others have\nmade during the WG Last Call. In specific, I do not agree with:\n"}, "context_segments": []}, {"current_segment": {"sid": 7353, "labels": "Disagreement,InformationProviding", "content": "> I think that woudl be helpful to have some text that provides some\n> rational\n> for using Ed25519 versus Ed25519ph and Ed25519ctx as well as Ed448\n> versus\n> Ed448ph. I belive that is collision resilience as well as offline\n> signing\n> in which case double path does not really matter."}, "context_segments": []}, {"current_segment": {"sid": 7354, "labels": "InformationProviding,InformationProviding,Disagreement,ExtensionOfPrevious", "content": "\nThe discussion of those other formats in draft-irtf-cfrg-eddsa seems\ngood enough to me. I have a concern that adding the rationale will in\nfact confuse developers into looking at the other formats. Our spec\nshould be \"this is the format\", not \"and here are other things we\nconsidered and didn't adopt\".\n"}, "context_segments": []}, {"current_segment": {"sid": 7355, "labels": "Social", "content": "Paul,"}, "context_segments": []}, {"current_segment": {"sid": 7356, "labels": "InformationProviding,InformationProviding,Agreement", "content": "\nI also think it would be easier from implementation perspective for Ed25519."}, "context_segments": []}, {"current_segment": {"sid": 7357, "labels": "Question,Question,NeutralResponse,InformationSeeking,InformationProviding", "content": "\nWhat about Ed448? Should I keep the context there or drop it as well?"}, "context_segments": []}, {"current_segment": {"sid": 7358, "labels": "Thanking,InformationProviding,StateDecision,Social,Thanking", "content": "Hi,\n\nThank you all for the reviews. My understanding is that these reviews have\nbeen considered in the new text and we are moving the document forward.\n\nYours,\nRich and Daniel\n"}, "context_segments": []}, {"current_segment": {"sid": 7359, "labels": "InformationProviding", "content": "If you believe that the document is ready to be submitted to the IESG for consideration as a Standards Track RFC please send a short message stating this."}, "context_segments": []}, {"current_segment": {"sid": 7443, "labels": "InformationProviding,InformationProviding", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Crypto Forum of the IETF."}, "context_segments": []}, {"current_segment": {"sid": 7444, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\nTitle           : Edwards-curve Digital Signature Algorithm (EdDSA)\nAuthors         : Simon Josefsson\nIlari Liusvaara\nFilename        : draft-irtf-cfrg-eddsa-06.txt\nPages           : 55\nDate            : 2016-08-10"}, "context_segments": []}, {"current_segment": {"sid": 7445, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\nAbstract:\nThe elliptic curve signature scheme Edwards-curve Digital Signature\nAlgorithm (EdDSA) is described.  The algorithm is instantiated with\nrecommended parameters for the edwards25519 and edwards448 curves.\nAn example implementation and test vectors are provided."}, "context_segments": []}, {"current_segment": {"sid": 7446, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\nThe IETF datatracker status page for this draft is:\nhttps://datatracker.ietf.org/doc/draft-irtf-cfrg-eddsa/"}, "context_segments": []}, {"current_segment": {"sid": 7447, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\nThere's also a htmlized version available at:\nhttps://tools.ietf.org/html/draft-irtf-cfrg-eddsa-06"}, "context_segments": []}, {"current_segment": {"sid": 7448, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\nA diff from the previous version is available at:\nhttps://www.ietf.org/rfcdiff?url2=draft-irtf-cfrg-eddsa-06"}, "context_segments": []}, {"current_segment": {"sid": 7449, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious", "content": "\nPlease note that it may take a couple of minutes from the time of submission\nuntil the htmlized version and diff are available at tools.ietf.org."}, "context_segments": []}, {"current_segment": {"sid": 7450, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\nInternet-Drafts are also available by anonymous FTP at:\nftp://ftp.ietf.org/internet-drafts/"}, "context_segments": []}, {"current_segment": {"sid": 3594, "labels": "Social,Social", "content": "Folks,"}, "context_segments": []}, {"current_segment": {"sid": 3595, "labels": "Social,Thanking,Question,InformationProviding,ClarificationElicitation,InformationProviding,ContextSetting,Social,Thanking,InformationSeeking", "content": "Hello,\n\nIt's great to see draft-17 being published. Thank you all for the effort.\n\nMaybe the addition of extensions field to the Certificate message got\nlost in the changelog?\nhttps://github.com/tlswg/tls13-spec/pull/654\n\nMy understanding has been that it was a post-16 change and it changes\nthe wire protocol.\n"}, "context_segments": []}, {"current_segment": {"sid": 3596, "labels": "Agreement,StateDecision,Answer,Agreement,StateDecision,InformationProviding", "content": "You're right. I just missed it. Added to the editor's copy."}, "context_segments": []}, {"current_segment": {"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, "context_segments": []}, {"current_segment": {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}]}, {"current_segment": {"sid": 3599, "labels": "Agreement,InformationProviding,ProposeAction,Social", "content": "\nPlease do.\n\nWe're working on ours so interop testing would be great.\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}]}, {"current_segment": {"sid": 3600, "labels": "InformationProviding,ContextSetting,Social,InformationProviding,NeutralResponse,ContextSetting", "content": "\nNot sure how up to date this is but here\u2019s a list of some implementations:\n\nhttps://github.com/tlswg/tls13-spec/wiki/Implementations\n\nspt"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}, {"sid": 3599, "labels": "Agreement,InformationProviding,ProposeAction,Social", "content": "\nPlease do.\n\nWe're working on ours so interop testing would be great.\n"}]}, {"current_segment": {"sid": 3601, "labels": "InformationProviding", "content": "\nAnd since that implementation supports RFC7250 (for the server"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}]}, {"current_segment": {"sid": 3602, "labels": "NeutralResponse,ProposeAction,NeutralResponse,ProposeAction,InformationProviding", "content": "\nI think this probably should go in Encrypted Extensions.\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}]}, {"current_segment": {"sid": 3603, "labels": "NeutralResponse,InformationProviding,Disagreement,ProposeAction", "content": "\nIt is definitely related to the certificate chain, and the spec\nsays such things should go to the first certificate slot (and indeed\nthe table about extensions says it goes to certificate extensions\nblock (but not which one).\n\nThe client_certificate_type (which I am not using) is listed to go to\nEncryptedExtensions, which definitely looks wrong to me, being another\nextension related to the certificate chain.\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}, {"sid": 3602, "labels": "NeutralResponse,ProposeAction,NeutralResponse,ProposeAction,InformationProviding", "content": "\nI think this probably should go in Encrypted Extensions.\n"}]}, {"current_segment": {"sid": 3604, "labels": "NeutralResponse,Social,InformationProviding,Disagreement", "content": "\nMy argument would be that it doesn't belong in \"individual certificates\"\nbecause it applies to certificates as a whole. It's not like it would be\nlegal to have a 7250 cert followed by an X.509 cert, one hopes\n\n-Ekr\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}, {"sid": 3602, "labels": "NeutralResponse,ProposeAction,NeutralResponse,ProposeAction,InformationProviding", "content": "\nI think this probably should go in Encrypted Extensions.\n"}, {"sid": 3603, "labels": "NeutralResponse,InformationProviding,Disagreement,ProposeAction", "content": "\nIt is definitely related to the certificate chain, and the spec\nsays such things should go to the first certificate slot (and indeed\nthe table about extensions says it goes to certificate extensions\nblock (but not which one).\n\nThe client_certificate_type (which I am not using) is listed to go to\nEncryptedExtensions, which definitely looks wrong to me, being another\nextension related to the certificate chain.\n"}]}, {"current_segment": {"sid": 3611, "labels": "Social", "content": "\n-Ekr\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}, {"sid": 3602, "labels": "NeutralResponse,ProposeAction,NeutralResponse,ProposeAction,InformationProviding", "content": "\nI think this probably should go in Encrypted Extensions.\n"}, {"sid": 3603, "labels": "NeutralResponse,InformationProviding,Disagreement,ProposeAction", "content": "\nIt is definitely related to the certificate chain, and the spec\nsays such things should go to the first certificate slot (and indeed\nthe table about extensions says it goes to certificate extensions\nblock (but not which one).\n\nThe client_certificate_type (which I am not using) is listed to go to\nEncryptedExtensions, which definitely looks wrong to me, being another\nextension related to the certificate chain.\n"}]}, {"current_segment": {"sid": 3612, "labels": "InformationProviding", "content": "\nand the spec"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}, {"sid": 3602, "labels": "NeutralResponse,ProposeAction,NeutralResponse,ProposeAction,InformationProviding", "content": "\nI think this probably should go in Encrypted Extensions.\n"}, {"sid": 3603, "labels": "NeutralResponse,InformationProviding,Disagreement,ProposeAction", "content": "\nIt is definitely related to the certificate chain, and the spec\nsays such things should go to the first certificate slot (and indeed\nthe table about extensions says it goes to certificate extensions\nblock (but not which one).\n\nThe client_certificate_type (which I am not using) is listed to go to\nEncryptedExtensions, which definitely looks wrong to me, being another\nextension related to the certificate chain.\n"}]}, {"current_segment": {"sid": 3613, "labels": "Social", "content": "\n-Ilari"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3598, "labels": "NeutralResponse,ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\nUpdated my own implementation from -16 to -17 (TODO: Add to\nimplementations page, it isn't any of the ones listed).\n\nAnd since that implementation supports RFC7250 (for the server\ncertificate), here is my interpretation of it:\n\nThe certificate type is sent in extensions of EE certificate,\nvia the usual server_certificate_type extension (using the server-side\nsyntax from RFC7250).\n"}, {"sid": 3602, "labels": "NeutralResponse,ProposeAction,NeutralResponse,ProposeAction,InformationProviding", "content": "\nI think this probably should go in Encrypted Extensions.\n"}]}, {"current_segment": {"sid": 3614, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nOkay, the extension is after the certificate it attaches to (which is\njust weird), but turns out this wasn't that bad to implement, due to\nhow the code happened to be laid out (it first sliced the certificate\nmessage to extract the certificates and only afterwards processed\nthose).\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}]}, {"current_segment": {"sid": 3615, "labels": "InformationProviding,ContextSetting,Question,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\n... Interop tests with picotls failed:\n\n- Picotls sends extension 13 (signature_algorithms) in ServerHello,\nwhich my implementation does not like[1].\n- Picotls still seems to have the resumption_context mixed into\nhashes. I tought that got nuked when switching to \"finished\nstuffing\"? This causes wrong encryption keys to be derived,\ncausing the handshake to blow up.\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}]}, {"current_segment": {"sid": 3616, "labels": "Thanking,InformationProviding,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,StateDecision,Thanking,Social", "content": "\nThank you very much for testing, and for reporting the issues you\nfound. Apparently I missed the changes when I made the adjustments for\ndraft-17.\n\nI've pushed the fixes on to my git repository\n(https://github.com/h2o/picotls) fixing the two issues. Hopefully with\nthem, picotls would be able to communicate with your implementation (I\nthink it might be better to go through my code with draft-17 in hand\nto see if any other discordances exist, but that'll be in the next\nweek).\n\nI am also looking forward to seeing your implementation on the Wiki.\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3615, "labels": "InformationProviding,ContextSetting,Question,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\n... Interop tests with picotls failed:\n\n- Picotls sends extension 13 (signature_algorithms) in ServerHello,\nwhich my implementation does not like[1].\n- Picotls still seems to have the resumption_context mixed into\nhashes. I tought that got nuked when switching to \"finished\nstuffing\"? This causes wrong encryption keys to be derived,\ncausing the handshake to blow up.\n"}]}, {"current_segment": {"sid": 3617, "labels": "Agreement,Agreement,InformationProviding", "content": "\nYou are correct.\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3615, "labels": "InformationProviding,ContextSetting,Question,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\n... Interop tests with picotls failed:\n\n- Picotls sends extension 13 (signature_algorithms) in ServerHello,\nwhich my implementation does not like[1].\n- Picotls still seems to have the resumption_context mixed into\nhashes. I tought that got nuked when switching to \"finished\nstuffing\"? This causes wrong encryption keys to be derived,\ncausing the handshake to blow up.\n"}]}, {"current_segment": {"sid": 3618, "labels": "Answer,Answer,InformationProviding", "content": "\nIt did.\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3615, "labels": "InformationProviding,ContextSetting,Question,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\n... Interop tests with picotls failed:\n\n- Picotls sends extension 13 (signature_algorithms) in ServerHello,\nwhich my implementation does not like[1].\n- Picotls still seems to have the resumption_context mixed into\nhashes. I tought that got nuked when switching to \"finished\nstuffing\"? This causes wrong encryption keys to be derived,\ncausing the handshake to blow up.\n"}]}, {"current_segment": {"sid": 3619, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,InformationSeeking,InformationProviding", "content": "\n[1] Wasn't this ripped out in -17? The -17 draft seems to list that\nextension as \"clear\", shouldn't it be \"client\" as the AFAIK the\nserver won't send it?\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}]}, {"current_segment": {"sid": 3620, "labels": "NeutralResponse,Thanking,Social,Answer,Thanking,InformationProviding", "content": "\nThanks. That got missed in the update.\n\n-Ekr\n"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}, {"sid": 3619, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,InformationSeeking,InformationProviding", "content": "\n[1] Wasn't this ripped out in -17? The -17 draft seems to list that\nextension as \"clear\", shouldn't it be \"client\" as the AFAIK the\nserver won't send it?\n"}]}, {"current_segment": {"sid": 3621, "labels": "Social", "content": "\n-Ilari"}, "context_segments": [{"sid": 3597, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI have just uploaded draft-ietf-tls-tls13-17."}]}, {"current_segment": {"sid": 3622, "labels": "ContextSetting,StateDecision,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThe major change in this draft is the removal of the 0-RTT Finished\nand resumption_context constructs and their replacement with the\npsk_binder. This has a number of side effects:"}, "context_segments": []}, {"current_segment": {"sid": 3623, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\n- Binds in the original transcript into the resumed handshake\nwhenever resumption-PSK is used."}, "context_segments": []}, {"current_segment": {"sid": 3624, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,StateDecision", "content": "\n- Provides proof of possession of the RMS by the client (subject\nto replay issues). I've moved the obfuscated_ticket_age field\nout of the early_data_indication so that it now provides the\nsame limited anti-replay for non-0-RTT PSK."}, "context_segments": []}, {"current_segment": {"sid": 3625, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\n- Removes the need for any early handshake encryption. This change,\nalong with the dual key ladders we introduced in -16, also allowed\nus to simplify the traffic key expansion so we don't need explicit\nlabels for each key (they are already used in Derive-Secret)."}, "context_segments": []}, {"current_segment": {"sid": 3626, "labels": "ContextSetting,StateDecision,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nOther changes included:\n- Tweaking the PSK key exchange modes a bit (and removing the\ninoperative ability to specify PSK auth modes, while leaving\na hook to do it later)."}, "context_segments": []}, {"current_segment": {"sid": 3627, "labels": "StateDecision,InformationProviding,ExtensionOfPrevious", "content": "\n- Cleaned up the cipher suite requirements for resumption and 0-RTT.\nYou can resume/do PSK as long as the PSK KDF matches, but to do 0-RTT\nyou need the whole cipher suite must match."}, "context_segments": []}, {"current_segment": {"sid": 3628, "labels": "InformationProviding,InformationSeeking,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nThis revision resolves all the outstanding technical PRs [0] and all but\none of the non-parked technical issues (#144, whether we should remove the\nredundant TLSCipherText.opaque_type and TLSCipherText.record_version\nfields). We are pursuing measurements to resolve whether this will\nbe a compat problem but we don't have them yet."}, "context_segments": []}, {"current_segment": {"sid": 3629, "labels": "InformationProviding,ProposeAction,InformationSeeking,InformationProviding,ProposeAction", "content": "\nAs usual, comments welcome. We are already working on implementing\n-17 in NSS/Firefox and should have it before Seoul."}, "context_segments": []}, {"current_segment": {"sid": 3630, "labels": "Social", "content": "\n-Ekr"}, "context_segments": []}, {"current_segment": {"sid": 3631, "labels": "ContextSetting,InformationProviding,ContextSetting,ProposeAction", "content": "\nFull Changelog\n- Remove the 0-RTT Finished, resumption_context, and replace with a\npsk_binder field in the PSK itself (*)"}, "context_segments": []}, {"current_segment": {"sid": 3632, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Restructure PSK key exchange negotiation modes (*)"}, "context_segments": []}, {"current_segment": {"sid": 3633, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Add max_early_data_size field to TicketEarlyDataInfo (*)"}, "context_segments": []}, {"current_segment": {"sid": 3634, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Add a 0-RTT exporter and change the transcript for the regular exporter"}, "context_segments": []}, {"current_segment": {"sid": 3635, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Merge TicketExtensions and Extensions registry. Changes\nticket_early_data_info code point (*)"}, "context_segments": []}, {"current_segment": {"sid": 3636, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Replace Client.key_shares in response to HRR (*)"}, "context_segments": []}, {"current_segment": {"sid": 3637, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Remove redundant labels for traffic key derivation (*)"}, "context_segments": []}, {"current_segment": {"sid": 3638, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Harmonize requirements about cipher suite matching: for resumption you\nneed to match KDF but for 0-RTT you need whole cipher suite. This\nallows PSKs to actually negotiate cipher suites. (*)"}, "context_segments": []}, {"current_segment": {"sid": 3639, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Explicitly allow non-offered extensions in NewSessionTicket"}, "context_segments": []}, {"current_segment": {"sid": 3640, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Explicitly allow predicting ClientFinished for NST"}, "context_segments": []}, {"current_segment": {"sid": 3641, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n- Clarify conditions for allowing 0-RTT with PSK"}, "context_segments": []}, {"current_segment": {"sid": 3642, "labels": "ContextSetting,InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\n[0] The two remaining outstanding PRs are:\n#680: Forbid post-handshake authentication except when permitted by\napplication profile. This is almost entirely a requirements-level\nchange, though it would allow clients to send \"unexpected_message\"\nwhen receiving an unexpected CertificateRequest."}, "context_segments": []}, {"current_segment": {"sid": 3643, "labels": "InformationProviding,InformationProviding,ContextSetting,ProposeAction", "content": "\n#612: TLS 1.3 -> TLS 2.0\nThis has no change on the wire format."}, "context_segments": []}, {"current_segment": {"sid": 505, "labels": "Disagreement,InformationProviding", "content": "\nI could not understand how does it make sense for you to refer \"TURN\" in the\nrequirement whereas it implies \"PCP\" or \"ICE-TCP\" or \"TURN over WebSocket\"\nin the solution."}, "context_segments": []}, {"current_segment": {"sid": 5265, "labels": "Social,Social", "content": "Hi,"}, "context_segments": [{"sid": 505, "labels": "Disagreement,InformationProviding", "content": "\nI could not understand how does it make sense for you to refer \"TURN\" in the\nrequirement whereas it implies \"PCP\" or \"ICE-TCP\" or \"TURN over WebSocket\"\nin the solution."}]}, {"current_segment": {"sid": 7606, "labels": "Question,InformationProviding,InformationProviding,ProposeAction,ContextSetting,InformationSeeking", "content": "One of the things I am trying to persuade groups writing crypto\napplications is that we should adopt a common format for fingerprints, Why?"}, "context_segments": [{"sid": 505, "labels": "Disagreement,InformationProviding", "content": "\nI could not understand how does it make sense for you to refer \"TURN\" in the\nrequirement whereas it implies \"PCP\" or \"ICE-TCP\" or \"TURN over WebSocket\"\nin the solution."}, {"sid": 5265, "labels": "Social,Social", "content": "Hi,"}]}, {"current_segment": {"sid": 506, "labels": "NeutralResponse,InformationProviding", "content": "\nI understand the text you're suggesting to mean that WebRTC clients\nwould be required support at least one in the set { TURN, ICE-TCP, TURN\nover WebSocket, PCP }. This would be broken. A client that chooses to\nsupport, for example, only PCP would be ridiculously broken. All clients\nMUST support TURN as a base traversal mechanism. Other mechanisms are\nicing on the cake.\n\nI'm fairly sure this is not what you were suggesting though, since that\nwould be so obviously broken. That's why I said that your suggestion\nmakes no sense to me.\n"}, "context_segments": [{"sid": 505, "labels": "Disagreement,InformationProviding", "content": "\nI could not understand how does it make sense for you to refer \"TURN\" in the\nrequirement whereas it implies \"PCP\" or \"ICE-TCP\" or \"TURN over WebSocket\"\nin the solution."}, {"sid": 5265, "labels": "Social,Social", "content": "Hi,"}, {"sid": 7606, "labels": "Question,InformationProviding,InformationProviding,ProposeAction,ContextSetting,InformationSeeking", "content": "One of the things I am trying to persuade groups writing crypto\napplications is that we should adopt a common format for fingerprints, Why?"}]}, {"current_segment": {"sid": 507, "labels": "Thanking,Social", "content": "\nThanks\nPartha"}, "context_segments": []}, {"current_segment": {"sid": 5266, "labels": "InformationProviding,ContextSetting,StateDecision,InformationProviding,ContextSetting", "content": "\nThe updated version of RTSP 2.0 addresses the comments received during the WGLC.\nThe diff to -23 will be available here:\nhttp://tools.ietf.org/wg/mmusic/draft-ietf-mmusic-rfc2326bis/draft-ietf-mmusic-rfc2326bis-24-from-23.diff.html"}, "context_segments": [{"sid": 507, "labels": "Thanking,Social", "content": "\nThanks\nPartha"}]}, {"current_segment": {"sid": 7607, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n1) Because having a standard approach is the right thing to do"}, "context_segments": [{"sid": 507, "labels": "Thanking,Social", "content": "\nThanks\nPartha"}, {"sid": 5266, "labels": "InformationProviding,ContextSetting,StateDecision,InformationProviding,ContextSetting", "content": "\nThe updated version of RTSP 2.0 addresses the comments received during the WGLC.\nThe diff to -23 will be available here:\nhttp://tools.ietf.org/wg/mmusic/draft-ietf-mmusic-rfc2326bis/draft-ietf-mmusic-rfc2326bis-24-from-23.diff.html"}]}, {"current_segment": {"sid": 508, "labels": "NeutralResponse,InformationProviding", "content": "\nPersonal opinion:"}, "context_segments": []}, {"current_segment": {"sid": 5267, "labels": "InformationProviding,ProposeAction,InformationSeeking,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nThere are, to my knowledge, two open issues by now that still have to be discussed:\n- 503 issues (cf. SIP) (in issue tracker)\nhttps://sourceforge.net/tracker/?func=detail&aid=3007825&group_id=23194&atid=377744\n- Content-Location in RTSP 2.0 (email Tom)\nhttp://www.ietf.org/mail-archive/web/mmusic/current/msg08204.html"}, "context_segments": [{"sid": 508, "labels": "NeutralResponse,InformationProviding", "content": "\nPersonal opinion:"}]}, {"current_segment": {"sid": 7608, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n2) Because a direct trust mechanism (i.e. a fingerprint) is useful in every\ncrypto application"}, "context_segments": [{"sid": 508, "labels": "NeutralResponse,InformationProviding", "content": "\nPersonal opinion:"}, {"sid": 5267, "labels": "InformationProviding,ProposeAction,InformationSeeking,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nThere are, to my knowledge, two open issues by now that still have to be discussed:\n- 503 issues (cf. SIP) (in issue tracker)\nhttps://sourceforge.net/tracker/?func=detail&aid=3007825&group_id=23194&atid=377744\n- Content-Location in RTSP 2.0 (email Tom)\nhttp://www.ietf.org/mail-archive/web/mmusic/current/msg08204.html"}]}, {"current_segment": {"sid": 509, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nI think the below places the text in the wrong context. The note is in\nmy mind relevant in the context of the general NAT/FW traversal\nrequirements, not the one discussing need to support multiple NAT/FW\ntraversal servers. Thus, I think Section 3.3.2 and thus requirement F29.\nOr potentially regarding Requirement F2. Is more appropriate places to\ninclude this."}, "context_segments": []}, {"current_segment": {"sid": 5268, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI will be away from my emails (starting tonight) until July 12 and back afterwards."}, "context_segments": [{"sid": 509, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nI think the below places the text in the wrong context. The note is in\nmy mind relevant in the context of the general NAT/FW traversal\nrequirements, not the one discussing need to support multiple NAT/FW\ntraversal servers. Thus, I think Section 3.3.2 and thus requirement F29.\nOr potentially regarding Requirement F2. Is more appropriate places to\ninclude this."}]}, {"current_segment": {"sid": 7609, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n* OpenPGP Key fingerprints\n* SSH server keys AND it would be nice to do public keys one day\n* Roots of trust for PKIX and S/MIME"}, "context_segments": [{"sid": 509, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nI think the below places the text in the wrong context. The note is in\nmy mind relevant in the context of the general NAT/FW traversal\nrequirements, not the one discussing need to support multiple NAT/FW\ntraversal servers. Thus, I think Section 3.3.2 and thus requirement F29.\nOr potentially regarding Requirement F2. Is more appropriate places to\ninclude this."}, {"sid": 5268, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI will be away from my emails (starting tonight) until July 12 and back afterwards."}]}, {"current_segment": {"sid": 7610, "labels": "NeutralResponse,InformationProviding,NeutralResponse", "content": "\nObXKCD: https://xkcd.com/927/\n"}, "context_segments": [{"sid": 509, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nI think the below places the text in the wrong context. The note is in\nmy mind relevant in the context of the general NAT/FW traversal\nrequirements, not the one discussing need to support multiple NAT/FW\ntraversal servers. Thus, I think Section 3.3.2 and thus requirement F29.\nOr potentially regarding Requirement F2. Is more appropriate places to\ninclude this."}, {"sid": 5268, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI will be away from my emails (starting tonight) until July 12 and back afterwards."}, {"sid": 7609, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n* OpenPGP Key fingerprints\n* SSH server keys AND it would be nice to do public keys one day\n* Roots of trust for PKIX and S/MIME"}]}, {"current_segment": {"sid": 510, "labels": "NeutralResponse,InformationProviding", "content": "\nIn the early phases of the use-case draft we did not use the words\n\"ICE\", \"STUN\" or \"TURN\" - things were stated more technology neutral.\n\nBut at some stage it was pretty clear that ICE was the solution the WG\nwas going for; and at the same time many wanted to have ICE specific\nrequirements (such as \"The browser must be able to use several STUN and\nTURN servers\") included.\n\nSo we made the change and started talking about ICE, STUN and TURN in\nthe document (but note that in the description it is still said\n\"Assuming that ICE will be used\").\n\nI am not super happy about having the requirements depend on choosing a\ncertain solution, but at the same time I think that ICE is a corner\nstone so for me it is livable to have in the document.\n"}, "context_segments": []}, {"current_segment": {"sid": 7611, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n3) Because simply taking SHA-2 of 'stuff' opens possibilities for semantic\nsubstitution attacks"}, "context_segments": [{"sid": 510, "labels": "NeutralResponse,InformationProviding", "content": "\nIn the early phases of the use-case draft we did not use the words\n\"ICE\", \"STUN\" or \"TURN\" - things were stated more technology neutral.\n\nBut at some stage it was pretty clear that ICE was the solution the WG\nwas going for; and at the same time many wanted to have ICE specific\nrequirements (such as \"The browser must be able to use several STUN and\nTURN servers\") included.\n\nSo we made the change and started talking about ICE, STUN and TURN in\nthe document (but note that in the description it is still said\n\"Assuming that ICE will be used\").\n\nI am not super happy about having the requirements depend on choosing a\ncertain solution, but at the same time I think that ICE is a corner\nstone so for me it is livable to have in the document.\n"}]}, {"current_segment": {"sid": 511, "labels": "NeutralResponse,InformationProviding", "content": "\nI can live with Simon text in case it is documented in Sec 4.2  as"}, "context_segments": []}, {"current_segment": {"sid": 7612, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n4) Adopting a common format encourages innovation that can benefit all\napplications that share that format."}, "context_segments": [{"sid": 511, "labels": "NeutralResponse,InformationProviding", "content": "\nI can live with Simon text in case it is documented in Sec 4.2  as"}]}, {"current_segment": {"sid": 512, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nF31     The browser must be able to use several STUN\nand TURN servers. Note that TURN support being mandatory\ndoes not preclude the browser from supporting\nadditional traversal mechanisms.\nF32     There browser must support that STUN and TURN\nservers to use are supplied by other entities\nthan via the web application (i.e. the network\nprovider). Note that TURN support being mandatory\ndoes not preclude the browser from supporting\nadditional traversal mechanisms."}, "context_segments": []}, {"current_segment": {"sid": 7613, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n5) Adopting a single fingerprint format encourages the development of\napplications to manage them across applications - like the Mathematical\nMesh which I am working on."}, "context_segments": [{"sid": 512, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nF31     The browser must be able to use several STUN\nand TURN servers. Note that TURN support being mandatory\ndoes not preclude the browser from supporting\nadditional traversal mechanisms.\nF32     There browser must support that STUN and TURN\nservers to use are supplied by other entities\nthan via the web application (i.e. the network\nprovider). Note that TURN support being mandatory\ndoes not preclude the browser from supporting\nadditional traversal mechanisms."}]}, {"current_segment": {"sid": 513, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nand also Appendix A:"}, "context_segments": []}, {"current_segment": {"sid": 7614, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nWe are not going to get to one true representation of keys. But I think we\ncould get to a fingerprint format that every application can use without\nthe risk of semantic substitution attacks."}, "context_segments": [{"sid": 513, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nand also Appendix A:"}]}, {"current_segment": {"sid": 514, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA22     The Web API must provide means for the\napplication to specify several STUN and/or\nTURN servers to use. Note that TURN support being mandatory\ndoes not preclude a Web API from supporting\nadditional traversal mechanisms."}, "context_segments": []}, {"current_segment": {"sid": 7615, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nI am not too bothered about the possibility that someone generates an\nOpenPGP key and somehow persuades S/MIME to send a message using the same\nkey. If I am being really strict, I can see it is not ideal."}, "context_segments": [{"sid": 514, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA22     The Web API must provide means for the\napplication to specify several STUN and/or\nTURN servers to use. Note that TURN support being mandatory\ndoes not preclude a Web API from supporting\nadditional traversal mechanisms."}]}, {"current_segment": {"sid": 515, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPlease let me know in case you have any issue in the above text."}, "context_segments": []}, {"current_segment": {"sid": 7616, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nWhat does worry me however is that if Mallet gives Alice his key\nfingerprint for OpenPGP, she puts it in her 'trusted key ring' and it turns\nout that when the SSH app interprets the sequence of bits that were\nfingerprinted they have some different semantics."}, "context_segments": [{"sid": 515, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPlease let me know in case you have any issue in the above text."}]}, {"current_segment": {"sid": 516, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nBTW, just for the record, draft-ietf-rtcweb-use-cases-and-requirements-12\ndoes not specify the list of traversal mechanism requirements for WebRTC\nGateway/Server."}, "context_segments": []}, {"current_segment": {"sid": 7617, "labels": "ExtensionOfPrevious,ContextSetting,ProposeAction,InformationProviding", "content": "\nMy current proposal is in:"}, "context_segments": [{"sid": 516, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nBTW, just for the record, draft-ietf-rtcweb-use-cases-and-requirements-12\ndoes not specify the list of traversal mechanism requirements for WebRTC\nGateway/Server."}]}, {"current_segment": {"sid": 517, "labels": "Thanking,Social", "content": "\nThanks\nPartha"}, "context_segments": []}, {"current_segment": {"sid": 7618, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nhttps://tools.ietf.org/html/draft-hallambaker-udf-03"}, "context_segments": [{"sid": 517, "labels": "Thanking,Social", "content": "\nThanks\nPartha"}]}, {"current_segment": {"sid": 518, "labels": "NeutralResponse,InformationProviding", "content": "\nPlease note that when non-IETFers read this requirement document, they come\nto the conclusion that IETF RTCWeb WG recommends TURN and not other\nmechanisms. I'm saying that requirement document should not be used as the\nmechanism to eliminate the other alternatives when there is a discussion\ngoing-on in PNTAW alias. So, I'm asking for the change."}, "context_segments": []}, {"current_segment": {"sid": 7619, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThis allows use SHA-2-512 and SHA-3-512 as the hash algorithms. The default\npresentation is as a text string encoded in BASE32 encoding with spacing\nevery 5 characters to promote readability."}, "context_segments": [{"sid": 518, "labels": "NeutralResponse,InformationProviding", "content": "\nPlease note that when non-IETFers read this requirement document, they come\nto the conclusion that IETF RTCWeb WG recommends TURN and not other\nmechanisms. I'm saying that requirement document should not be used as the\nmechanism to eliminate the other alternatives when there is a discussion\ngoing-on in PNTAW alias. So, I'm asking for the change."}]}, {"current_segment": {"sid": 519, "labels": "Agreement,InformationProviding", "content": "\nI would totally agree with that sentiment, although I don't see your\nproposed text change reflecting it accurately. How about simply:\n\n\"Note that TURN support being mandatory does not preclude a WebRTC\nendpoint from supporting additional traversal mechanisms.\"\n"}, "context_segments": [{"sid": 518, "labels": "NeutralResponse,InformationProviding", "content": "\nPlease note that when non-IETFers read this requirement document, they come\nto the conclusion that IETF RTCWeb WG recommends TURN and not other\nmechanisms. I'm saying that requirement document should not be used as the\nmechanism to eliminate the other alternatives when there is a discussion\ngoing-on in PNTAW alias. So, I'm asking for the change."}, {"sid": 7619, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThis allows use SHA-2-512 and SHA-3-512 as the hash algorithms. The default\npresentation is as a text string encoded in BASE32 encoding with spacing\nevery 5 characters to promote readability."}]}, {"current_segment": {"sid": 7620, "labels": "NeutralResponse,InformationProviding,Disagreement,Social", "content": "\nOh not another SHA-as-big-as-we-can-get.  We know from various (public-IP)\nInternet scans that the universal standard on the net is SHA-256, and\nanything else, in particular the huge SHA-2 variants, are the GPS signal\nof the Internet, their use is so far below the noise floor that you need\nspecialised signal processing just to see they're there.  Just stick with\nSHA-256, which pretty much everything does, rather than going to oddball\nexotic algorithms that need special-case support.\n\nPeter."}, "context_segments": [{"sid": 518, "labels": "NeutralResponse,InformationProviding", "content": "\nPlease note that when non-IETFers read this requirement document, they come\nto the conclusion that IETF RTCWeb WG recommends TURN and not other\nmechanisms. I'm saying that requirement document should not be used as the\nmechanism to eliminate the other alternatives when there is a discussion\ngoing-on in PNTAW alias. So, I'm asking for the change."}, {"sid": 7619, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThis allows use SHA-2-512 and SHA-3-512 as the hash algorithms. The default\npresentation is as a text string encoded in BASE32 encoding with spacing\nevery 5 characters to promote readability."}, {"sid": 519, "labels": "Agreement,InformationProviding", "content": "\nI would totally agree with that sentiment, although I don't see your\nproposed text change reflecting it accurately. How about simply:\n\n\"Note that TURN support being mandatory does not preclude a WebRTC\nendpoint from supporting additional traversal mechanisms.\"\n"}]}, {"current_segment": {"sid": 520, "labels": "Agreement,InformationProviding", "content": "\n+1 for the above text.\n"}, "context_segments": [{"sid": 518, "labels": "NeutralResponse,InformationProviding", "content": "\nPlease note that when non-IETFers read this requirement document, they come\nto the conclusion that IETF RTCWeb WG recommends TURN and not other\nmechanisms. I'm saying that requirement document should not be used as the\nmechanism to eliminate the other alternatives when there is a discussion\ngoing-on in PNTAW alias. So, I'm asking for the change."}, {"sid": 7619, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThis allows use SHA-2-512 and SHA-3-512 as the hash algorithms. The default\npresentation is as a text string encoded in BASE32 encoding with spacing\nevery 5 characters to promote readability."}, {"sid": 519, "labels": "Agreement,InformationProviding", "content": "\nI would totally agree with that sentiment, although I don't see your\nproposed text change reflecting it accurately. How about simply:\n\n\"Note that TURN support being mandatory does not preclude a WebRTC\nendpoint from supporting additional traversal mechanisms.\"\n"}, {"sid": 7620, "labels": "NeutralResponse,InformationProviding,Disagreement,Social", "content": "\nOh not another SHA-as-big-as-we-can-get.  We know from various (public-IP)\nInternet scans that the universal standard on the net is SHA-256, and\nanything else, in particular the huge SHA-2 variants, are the GPS signal\nof the Internet, their use is so far below the noise floor that you need\nspecialised signal processing just to see they're there.  Just stick with\nSHA-256, which pretty much everything does, rather than going to oddball\nexotic algorithms that need special-case support.\n\nPeter."}]}, {"current_segment": {"sid": 521, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nLet us discuss in PNTAW alias which Firewall/NAT mechanisms have to be used\nby WebRTC client, WebRTC gateway/server (Sec 4.3 of\ndraft-ietf-rtcweb-use-cases-and-requirements-12) and not as part of the\nrequirement draft."}, "context_segments": []}, {"current_segment": {"sid": 7622, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nSo a SSH server fingerprint might look like:  MB2GK-6DUF5-YGYYL-JNY5E-RWSHZ"}, "context_segments": [{"sid": 521, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nLet us discuss in PNTAW alias which Firewall/NAT mechanisms have to be used\nby WebRTC client, WebRTC gateway/server (Sec 4.3 of\ndraft-ietf-rtcweb-use-cases-and-requirements-12) and not as part of the\nrequirement draft."}]}, {"current_segment": {"sid": 522, "labels": "Thanking,Social", "content": "\nThanks\nPartha"}, "context_segments": []}, {"current_segment": {"sid": 7623, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nOne of the things I find rather difficult with SSH is that the key files\nfor the applications I have seen in the wild do not comply with the spec,\nlines don't wrap at 72 characters. Rather worse, the files have the full\npublic key in them which makes them a real pain to use when configuring\nfiles."}, "context_segments": [{"sid": 522, "labels": "Thanking,Social", "content": "\nThanks\nPartha"}]}, {"current_segment": {"sid": 523, "labels": "NeutralResponse,Thanking,InformationProviding,Social", "content": "\nThanks for your understanding about my firewall/NAT related problem\nstatement in this draft."}, "context_segments": []}, {"current_segment": {"sid": 7624, "labels": "ExtensionOfPrevious,InformationProviding,ProposeAction", "content": "\nI would really like to be able to configure my GitHub accounts without\nhaving to cut and paste lines with a thousand characters of text. It would\nbe nice if the SSH config files could use fingerprints rather than the\nactual keys."}, "context_segments": [{"sid": 523, "labels": "NeutralResponse,Thanking,InformationProviding,Social", "content": "\nThanks for your understanding about my firewall/NAT related problem\nstatement in this draft."}]}, {"current_segment": {"sid": 524, "labels": "NeutralResponse,InformationProviding", "content": "\nI have proposed the firewall/NAT related text by which the specific\nmechanism is not highlighted in the requirement document as there is no WG\nconsensus for any of the mechanism including TURN. It is possible to argue\nhypothetically in PNTAW alias that PCP is the only mechanism required in\nWebRTC endpoint.   Also, I\u0092m more interested in WebRTC gateway/server (Sec\n4.3. of draft-ietf-rtcweb-use-cases-and-requirements-12) requirements\nwherein it is not required to support TURN and the related mail thread is\nhttp://www.ietf.org/mail-archive/web/pntaw/current/msg00181.html."}, "context_segments": []}, {"current_segment": {"sid": 7625, "labels": "InformationProviding", "content": "Phillip Hallam-Baker <phill@hallambaker.com> writes:\n"}, "context_segments": [{"sid": 524, "labels": "NeutralResponse,InformationProviding", "content": "\nI have proposed the firewall/NAT related text by which the specific\nmechanism is not highlighted in the requirement document as there is no WG\nconsensus for any of the mechanism including TURN. It is possible to argue\nhypothetically in PNTAW alias that PCP is the only mechanism required in\nWebRTC endpoint.   Also, I\u0092m more interested in WebRTC gateway/server (Sec\n4.3. of draft-ietf-rtcweb-use-cases-and-requirements-12) requirements\nwherein it is not required to support TURN and the related mail thread is\nhttp://www.ietf.org/mail-archive/web/pntaw/current/msg00181.html."}]}, {"current_segment": {"sid": 525, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nIMO, my proposed text without mentioning any firewall/NAT mechanism in the\nrequirement document helps to move forward without depend on the solution\ndiscussion in PNTAW alias."}, "context_segments": []}, {"current_segment": {"sid": 526, "labels": "Thanking,Social", "content": "\nThanks"}, "context_segments": []}, {"current_segment": {"sid": 527, "labels": "NeutralResponse,InformationProviding", "content": "\nI don't see any support for the changes you proposes in this discussion.\nWhat I see some support for is to add a statement making clear that\nthere might be additional NAT/Firewall traversal mechanisms than\nSTUN/TURN. Simon proposed:"}, "context_segments": []}, {"current_segment": {"sid": 528, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\n\"Note that TURN support being mandatory does not preclude a WebRTC\nendpoint from supporting additional traversal mechanisms.\""}, "context_segments": []}, {"current_segment": {"sid": 529, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nHowever, looking at the document as it is currently written, I am\nuncertain where this would be added. The first mention of TURN is in\nSection 3.3.4.1, and that section is focused on the global service\nprovider perspective and the need for location based provisioning of\nNAT/Firewall traversal server resources."}, "context_segments": []}, {"current_segment": {"sid": 530, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nI think it can be added to Section 3.3.5.1 without being misplaced, but\nit would be given a slightly narrower scope."}, "context_segments": []}, {"current_segment": {"sid": 531, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nI any of you want to be more explicit where this should be included,\nplease be. If you are not forthcoming I will request the authors to add\nthis in what they consider sensible position."}, "context_segments": []}, {"current_segment": {"sid": 532, "labels": "NeutralResponse,Thanking,InformationProviding,Social", "content": "\nThanks a lot for providing the background. We are in the same page w.r.t\nICE. My concern is w.r.t TURN word usage only. It will be great in case\n\"TURN\" is replaced with \"Firewall traversal\" in the below mentioned snippet\nof the draft."}, "context_segments": []}, {"current_segment": {"sid": 533, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\n<snip>\nSec 3.3.4.1\nthe service provider would like to be able to provide several STUN and TURN\nservers (via the app) to the browser;"}, "context_segments": []}, {"current_segment": {"sid": 534, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nSec 3.3.5.1\nIt must be possible to configure the browsers used in the enterprise with\nnetwork specific STUN and TURN servers."}, "context_segments": []}, {"current_segment": {"sid": 535, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe RTCWEB functionality will need to utilize both network specific STUN and\nTURN resources and STUN and TURN servers provisioned by the web application."}, "context_segments": []}, {"current_segment": {"sid": 536, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nSec 4.2"}, "context_segments": []}, {"current_segment": {"sid": 537, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nF31     The browser must be able to use several STUN\nand TURN servers\nF32     There browser must support that STUN and TURN\nservers to use are supplied by other entities\nthan via the web application (i.e. the network\nprovider)."}, "context_segments": []}, {"current_segment": {"sid": 538, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nAppendix A"}, "context_segments": []}, {"current_segment": {"sid": 539, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA22     The Web API must provide means for the application to specify\nseveral STUN and/or TURN servers to use.\n</snip>"}, "context_segments": []}, {"current_segment": {"sid": 540, "labels": "ProposeAction,InformationProviding", "content": "\nAlso, Could you plese add the statement in the line of that \"Firewall\ntraversal mechanism in this document shall be TURN, ICE-TCP, TURN over\nWebSocket, PCP\" to provide more clarity."}, "context_segments": []}, {"current_segment": {"sid": 541, "labels": "Disagreement,InformationProviding", "content": "\nFWIW, I would completely disagree with that change. It makes no sense to me.\n"}, "context_segments": [{"sid": 540, "labels": "ProposeAction,InformationProviding", "content": "\nAlso, Could you plese add the statement in the line of that \"Firewall\ntraversal mechanism in this document shall be TURN, ICE-TCP, TURN over\nWebSocket, PCP\" to provide more clarity."}]}, {"current_segment": {"sid": 542, "labels": "Thanking,Social", "content": "\nThanks\nPartha"}, "context_segments": []}, {"current_segment": {"sid": 543, "labels": "Question,InformationSeeking", "content": "Where can I find: \" \"PCP\" or \"ICE-TCP\" or \"TURN over WebSocket\" in the\nsolution. \" ?\n(Haven't followed for a while.)\n\n/Karl\n"}, "context_segments": []}, {"current_segment": {"sid": 544, "labels": "NeutralResponse,InformationProviding", "content": "\n-----Ursprungligt meddelande-----\nFr\u00e5n: rtcweb [mailto:rtcweb-bounces@ietf.org] F\u00f6r Parthasarathi R\nSkickat: den 24 januari 2014 17:23\nTill: 'Simon Perreault'; rtcweb@ietf.org\n\u00c4mne: Re: [rtcweb] Query/Comment on\ndraft-ietf-rtcweb-use-cases-and-requirements-12\n\nSimon,\n\nI could not understand how does it make sense for you to refer \"TURN\" in the\nrequirement whereas it implies \"PCP\" or \"ICE-TCP\" or \"TURN over WebSocket\"\nin the solution.\n\nThanks\nPartha\n"}, "context_segments": []}, {"current_segment": {"sid": 3702, "labels": "Social,Social", "content": "Hi,"}, "context_segments": []}, {"current_segment": {"sid": 6806, "labels": "InformationProviding", "content": "The IETF MMUSIC WG is holding an Interim meeting on the topic of RTSP\nthe 19th and 20th of May 2008 in Stockholm, Sweden. The meeting will\nstart at lunch time 12.00 and continue until 18.00 on Monday the 19th."}, "context_segments": [{"sid": 3702, "labels": "Social,Social", "content": "Hi,"}]}, {"current_segment": {"sid": 3703, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI took a look at both documents today and I am attaching my two\nreviews.  Since the structure of the documents is quite similar, the\nreview comments are also quite similar."}, "context_segments": []}, {"current_segment": {"sid": 6807, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe purpose of the meeting is the following: First, to discuss the open\nissues that at that time exists on the RTSP 2.0 core specification.\nSecondly, to discuss any liaison response from other standards\ndeveloping organizations using RTSP. Especially their desired extensions\nto RTSP and their impact on the RTSP 2.0 core specification. We\nespecially encourage persons from such organizations to participate in\nthis meeting. Third, to discuss issues and ways to progress already\nexisting MMUSIC WG item extensions to RTSP. Fourth, to discuss any RTSP\nextensions proposed to become MMUSIC WG items. The main goal is to help\nensure the timely completion of the RTSP 2.0 core specification while\nensuring that the potential user's requirements have been considered and\nthe necessary extension mechanisms are in place.\n\nThe RTSP 2.0 core specification editors intends to submit an updated\nversion of the draft in good time (2-3 weeks) prior to the meeting to\nallow everyone to prepare. At that time a more detailed agenda will also\nbe published taking requests for topics and the incoming liaisons into\naccount.\n\nParticipants are required to register prior to the event to ensure that\nthe facilities can accommodate the participants. The last day of\nregistration is the 5th of May. Registration shall be sent to\nmagnus.westerlund@ericsson.com with the subject line \"MMUSIC RTSP\ninterim meeting\" indicating the participant's name and also any specific\nagenda requests. The meeting will most likely be held out in Kista (20\nmin subway ride from downtown Stockholm).\n\nAny questions on this event can be directed to the MMUSIC WG chairs\nJoerg Ott (jo@acm.org) and Jean-Francois Mule (jf.mule@cablelabs.com) or\nthe meeting organizer Magnus Westerlund\n(magnus.westerlund@ericsson.com).\n\nReferences:\nCurrent WG documents:\nhttp://tools.ietf.org/wg/mmusic/draft-ietf-mmusic-rfc2326bis/\nhttp://tools.ietf.org/wg/mmusic/draft-ietf-mmusic-rtsp-nat/\nhttp://tools.ietf.org/wg/mmusic/draft-ietf-mmusic-rtsp-nat-evaluation/\n\nRTSP Core issue tracker:\nhttp://sourceforge.net/projects/rtspspec\nIETF-Announce mailing list\nIETF-Announce@ietf.org\nhttps://www.ietf.org/mailman/listinfo/ietf-announce"}, "context_segments": [{"sid": 3703, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI took a look at both documents today and I am attaching my two\nreviews.  Since the structure of the documents is quite similar, the\nreview comments are also quite similar."}]}, {"current_segment": {"sid": 3704, "labels": "ContextSetting,ProposeAction,InformationProviding,Social,InformationProviding,ContextSetting,ProposeAction", "content": "\nOne more thing:\n\nSince ietf-ssh-client, ietf-ssh-server, ietf-ssh-common essentially\ndefine only groupings (one grouping per module) and identities, I\nsuggest to merge these definitions into a single module, say\nietf-ssh-common. This way, the module name ietf-ssh-server can be used\n(later) to define an instantiation of the groupings for a standalone\nSSH server.\n\nI would suggest the same for the ietf-tls-* modules (even though there\nis not a common standalone TLS server).\n\nSince these modules will have conformance-type 'import' in YANG\nlibrary, I do not really see what the benfit of splitting things\ninto multiple modules. What you implement is defined by the modules\nusing the groupings.\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}, "context_segments": [{"sid": 3703, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI took a look at both documents today and I am attaching my two\nreviews.  Since the structure of the documents is quite similar, the\nreview comments are also quite similar."}, {"sid": 6807, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe purpose of the meeting is the following: First, to discuss the open\nissues that at that time exists on the RTSP 2.0 core specification.\nSecondly, to discuss any liaison response from other standards\ndeveloping organizations using RTSP. Especially their desired extensions\nto RTSP and their impact on the RTSP 2.0 core specification. We\nespecially encourage persons from such organizations to participate in\nthis meeting. Third, to discuss issues and ways to progress already\nexisting MMUSIC WG item extensions to RTSP. Fourth, to discuss any RTSP\nextensions proposed to become MMUSIC WG items. The main goal is to help\nensure the timely completion of the RTSP 2.0 core specification while\nensuring that the potential user's requirements have been considered and\nthe necessary extension mechanisms are in place.\n\nThe RTSP 2.0 core specification editors intends to submit an updated\nversion of the draft in good time (2-3 weeks) prior to the meeting to\nallow everyone to prepare. At that time a more detailed agenda will also\nbe published taking requests for topics and the incoming liaisons into\naccount.\n\nParticipants are required to register prior to the event to ensure that\nthe facilities can accommodate the participants. The last day of\nregistration is the 5th of May. Registration shall be sent to\nmagnus.westerlund@ericsson.com with the subject line \"MMUSIC RTSP\ninterim meeting\" indicating the participant's name and also any specific\nagenda requests. The meeting will most likely be held out in Kista (20\nmin subway ride from downtown Stockholm).\n\nAny questions on this event can be directed to the MMUSIC WG chairs\nJoerg Ott (jo@acm.org) and Jean-Francois Mule (jf.mule@cablelabs.com) or\nthe meeting organizer Magnus Westerlund\n(magnus.westerlund@ericsson.com).\n\nReferences:\nCurrent WG documents:\nhttp://tools.ietf.org/wg/mmusic/draft-ietf-mmusic-rfc2326bis/\nhttp://tools.ietf.org/wg/mmusic/draft-ietf-mmusic-rtsp-nat/\nhttp://tools.ietf.org/wg/mmusic/draft-ietf-mmusic-rtsp-nat-evaluation/\n\nRTSP Core issue tracker:\nhttp://sourceforge.net/projects/rtspspec\nIETF-Announce mailing list\nIETF-Announce@ietf.org\nhttps://www.ietf.org/mailman/listinfo/ietf-announce"}]}, {"current_segment": {"sid": 6808, "labels": "ExtensionOfPrevious,InformationProviding", "content": "On Tuesday it will start at 9.00 and end at latest at 17.00."}, "context_segments": [{"sid": 3703, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI took a look at both documents today and I am attaching my two\nreviews.  Since the structure of the documents is quite similar, the\nreview comments are also quite similar."}]}, {"current_segment": {"sid": 3705, "labels": "Thanking,ContextSetting,ContextSetting,StateDecision,Thanking,InformationProviding,Social", "content": "\nThanks!  And, to make responding easier, I've copied/pasted both\nsets of comments in below.\n"}, "context_segments": [{"sid": 3703, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nI took a look at both documents today and I am attaching my two\nreviews.  Since the structure of the documents is quite similar, the\nreview comments are also quite similar."}, {"sid": 6808, "labels": "ExtensionOfPrevious,InformationProviding", "content": "On Tuesday it will start at 9.00 and end at latest at 17.00."}]}, {"current_segment": {"sid": 3706, "labels": "Social", "content": "\n/js"}, "context_segments": []}, {"current_segment": {"sid": 3707, "labels": "Social,Social", "content": "Hi Juergen,"}, "context_segments": []}, {"current_segment": {"sid": 3708, "labels": "Question,NeutralResponse,ProposeAction,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationSeeking", "content": "\nI just noticed this comment went unanswered before.  I don't feel\nstrongly about this, but 1) I would call it \"ietf-ssh-groupings\",\n2) it will have a large impact on the structure of the draft (what\nwould the ToC be?), and 3) it definitely will break downstream\nmodules (as their imports will fail as the old names disappear)."}, "context_segments": []}, {"current_segment": {"sid": 3709, "labels": "ClarificationElicitation,Question,InformationSeeking", "content": "\nBecause you are sure you will never put typedefs or identity\ndefinition there?\n"}, "context_segments": [{"sid": 3708, "labels": "Question,NeutralResponse,ProposeAction,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationSeeking", "content": "\nI just noticed this comment went unanswered before.  I don't feel\nstrongly about this, but 1) I would call it \"ietf-ssh-groupings\",\n2) it will have a large impact on the structure of the draft (what\nwould the ToC be?), and 3) it definitely will break downstream\nmodules (as their imports will fail as the old names disappear)."}]}, {"current_segment": {"sid": 3710, "labels": "Answer,ContextSetting,Answer,ContextSetting,InformationProviding", "content": "\nNot to say there wouldn't be, but that the reason for importing\nthe module would be for the groupings.   BTW, I want to update my\nprevious comment, I now have a preference (see bottom).\n"}, "context_segments": [{"sid": 3708, "labels": "Question,NeutralResponse,ProposeAction,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationSeeking", "content": "\nI just noticed this comment went unanswered before.  I don't feel\nstrongly about this, but 1) I would call it \"ietf-ssh-groupings\",\n2) it will have a large impact on the structure of the draft (what\nwould the ToC be?), and 3) it definitely will break downstream\nmodules (as their imports will fail as the old names disappear)."}, {"sid": 3709, "labels": "ClarificationElicitation,Question,InformationSeeking", "content": "\nBecause you are sure you will never put typedefs or identity\ndefinition there?\n"}]}, {"current_segment": {"sid": 3711, "labels": "Answer,Answer,InformationProviding", "content": "\nThe ToC falls out of the content.\n"}, "context_segments": [{"sid": 3708, "labels": "Question,NeutralResponse,ProposeAction,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationSeeking", "content": "\nI just noticed this comment went unanswered before.  I don't feel\nstrongly about this, but 1) I would call it \"ietf-ssh-groupings\",\n2) it will have a large impact on the structure of the draft (what\nwould the ToC be?), and 3) it definitely will break downstream\nmodules (as their imports will fail as the old names disappear)."}]}, {"current_segment": {"sid": 3712, "labels": "NeutralResponse,ProposeAction,InformationSeeking,Question,NeutralResponse,ProposeAction,InformationProviding", "content": "\nThe question was/is how to structure the draft, it's not obvious.\nIt would great if you could provide an example ToC for what you\nhad in mind.\n"}, "context_segments": [{"sid": 3708, "labels": "Question,NeutralResponse,ProposeAction,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationSeeking", "content": "\nI just noticed this comment went unanswered before.  I don't feel\nstrongly about this, but 1) I would call it \"ietf-ssh-groupings\",\n2) it will have a large impact on the structure of the draft (what\nwould the ToC be?), and 3) it definitely will break downstream\nmodules (as their imports will fail as the old names disappear)."}, {"sid": 3711, "labels": "Answer,Answer,InformationProviding", "content": "\nThe ToC falls out of the content.\n"}]}, {"current_segment": {"sid": 3713, "labels": "NeutralResponse,Social,InformationProviding,NeutralResponse", "content": "\nNothing got published so far. I think the number of IDs affected are\nclose to the number of IDs dealing with NC configuration, all in the\nhand of one editor.\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}, "context_segments": [{"sid": 3708, "labels": "Question,NeutralResponse,ProposeAction,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationSeeking", "content": "\nI just noticed this comment went unanswered before.  I don't feel\nstrongly about this, but 1) I would call it \"ietf-ssh-groupings\",\n2) it will have a large impact on the structure of the draft (what\nwould the ToC be?), and 3) it definitely will break downstream\nmodules (as their imports will fail as the old names disappear)."}]}, {"current_segment": {"sid": 3714, "labels": "Disagreement,InformationProviding,InformationProviding,Disagreement", "content": "\nNot true, if you saw Benoit's recent dependency graph, there's ~6 drafts\nauthored by others that depend on ietf-tls-server or ietf-tls-client.\n"}, "context_segments": [{"sid": 3708, "labels": "Question,NeutralResponse,ProposeAction,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationSeeking", "content": "\nI just noticed this comment went unanswered before.  I don't feel\nstrongly about this, but 1) I would call it \"ietf-ssh-groupings\",\n2) it will have a large impact on the structure of the draft (what\nwould the ToC be?), and 3) it definitely will break downstream\nmodules (as their imports will fail as the old names disappear)."}, {"sid": 3713, "labels": "NeutralResponse,Social,InformationProviding,NeutralResponse", "content": "\nNothing got published so far. I think the number of IDs affected are\nclose to the number of IDs dealing with NC configuration, all in the\nhand of one editor.\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}]}, {"current_segment": {"sid": 3715, "labels": "ExtensionOfPrevious,ProposeAction,Question,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,InformationSeeking", "content": "\nThat said, I'm beginning to think that this is not a good idea.  The\nimpact to the drafts (four of them) is enormous, and all just so that\nsome future definition can use the module name \"ietf-ssh-server\".  How\nabout instead, at that time, a bis of this document is produced to add\nin the missing \"ieft-ssh-server\" container?  That produces an equally\ngood result (better, I think) and is much less work now.\n"}, "context_segments": [{"sid": 3708, "labels": "Question,NeutralResponse,ProposeAction,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationSeeking", "content": "\nI just noticed this comment went unanswered before.  I don't feel\nstrongly about this, but 1) I would call it \"ietf-ssh-groupings\",\n2) it will have a large impact on the structure of the draft (what\nwould the ToC be?), and 3) it definitely will break downstream\nmodules (as their imports will fail as the old names disappear)."}, {"sid": 3713, "labels": "NeutralResponse,Social,InformationProviding,NeutralResponse", "content": "\nNothing got published so far. I think the number of IDs affected are\nclose to the number of IDs dealing with NC configuration, all in the\nhand of one editor.\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}]}, {"current_segment": {"sid": 3716, "labels": "Social", "content": "\nK.  // contributor"}, "context_segments": [{"sid": 3708, "labels": "Question,NeutralResponse,ProposeAction,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationSeeking", "content": "\nI just noticed this comment went unanswered before.  I don't feel\nstrongly about this, but 1) I would call it \"ietf-ssh-groupings\",\n2) it will have a large impact on the structure of the draft (what\nwould the ToC be?), and 3) it definitely will break downstream\nmodules (as their imports will fail as the old names disappear)."}, {"sid": 3713, "labels": "NeutralResponse,Social,InformationProviding,NeutralResponse", "content": "\nNothing got published so far. I think the number of IDs affected are\nclose to the number of IDs dealing with NC configuration, all in the\nhand of one editor.\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}]}, {"current_segment": {"sid": 3717, "labels": "Question,ClarificationElicitation,InformationProviding,Answer,ProposeAction,InformationSeeking", "content": "On Thu, Aug 17, 2017 at 08:42:11PM +0000, Kent Watsen wrote:\n> Hi Juergen,\n> I've trimmed all but the ongoing threads...\n> Kent\n> >> For the ssh-client-server draft\n> >> > - The overall setup is somewhat complicated but I do understand why.\n> >> >  Obviously, the attempts to make things generic come with a price\n> >> >  since many YANG definitions interact with other definitions that\n> >> >  need to be understood. And while the end result is that we can\n> >> >  configure SSH clients and servers for NETCONF, we only have a\n> >> >  collection of groupings to configure a regular SSH client or\n> >> >  server. Should we have an instantiation of these groupings for\n> >> >  regular SSH clients and servers as well?\n> >> I'm hoping to not have to do this, but can see that there might be\n> >> value in doing so in order to further proof-out the model.  To do\n> >> this right would entail something like what Clyde did for the syslog\n> >> model in evaluating many vendor's implementations to find a common\n> >> denominator.  I can imagine the WG undertaking such an analysis for\n> >> an SSH-server container, but I fail to see how it could be done for\n> >> an SSH-client container.  Also, when thinking about symmetry to the\n> >> tls-client-server draft, note that the idea of creating a container\n> >> for a TLS-server doesn't make sense (which one, right?)\n> > Yes, for TLS there is no a common standalone TLS service. For SSH,\n> > there is however since SSH was created for a specific service (while\n> > TLS was created as a plugin to secure another existing service).\n> > The client question we discussed before and I tend to agree that\n> > usually a client you configure is embedded into some other\n> > functionality that likely has its own configuration, so having a\n> > grouping is OK.\n> > But since there are SSH servers out there, do we expect this ID to\n> > just provide groupings and we hope that some other module later comes\n> > along and picks up the groupings and turns them into a more general\n> > SSH server configuration model?\n> This is my hope, so as to limit the scope of this document.\n> > My understanding is that NC implementations actually come in different\n> > forms, some simply running behind a regular SSH server while others\n> > come with their own integrated SSH server. Does this affect the data\n> > model?\n> I think JUNOS is an example where the NC server runs \"behind an SSH\n> server\", but it's not really \"behind\" so much as a fork/exec of an\n> sshd process running the \"netconf\" subsystem (i.e., the NC server).\n> Is this what you meant?\n> Regardless, I don't see a need to change either the ietf-netconf-server\n> or ietf-ssh-server data models to support either the fork/exec or\n> link-to-library implementation strategies.  Do you?"}, "context_segments": []}, {"current_segment": {"sid": 3718, "labels": "ClarificationElicitation,NeutralResponse,ClarificationElicitation,InformationProviding,Answer,InformationSeeking", "content": "\nWell, if your server is running as a subsystem of your regular SSH\ndaemon, then I think your SSH daemon configuration and your NETCONF\nspecific SSH configuration are essentially the same, no? Or more\nprecisely, you have an SSH daemon configuration plus a statement that\nenables NETCONF as a subsystem, but you do not have a NETCONF specific\nSSH configuration.\n"}, "context_segments": []}, {"current_segment": {"sid": 3719, "labels": "ClarificationElicitation,InformationProviding,Answer,InformationSeeking", "content": ">> >> For the ssh-client-server draft\n>> >> > - The overall setup is somewhat complicated but I do understand why.\n>> >> >  Obviously, the attempts to make things generic come with a price\n>> >> >  since many YANG definitions interact with other definitions that\n>> >> >  need to be understood. And while the end result is that we can\n>> >> >  configure SSH clients and servers for NETCONF, we only have a\n>> >> >  collection of groupings to configure a regular SSH client or\n>> >> >  server. Should we have an instantiation of these groupings for\n>> >> >  regular SSH clients and servers as well?\n>> >> I'm hoping to not have to do this, but can see that there might be\n>> >> value in doing so in order to further proof-out the model.  To do\n>> >> this right would entail something like what Clyde did for the syslog\n>> >> model in evaluating many vendor's implementations to find a common\n>> >> denominator.  I can imagine the WG undertaking such an analysis for\n>> >> an SSH-server container, but I fail to see how it could be done for\n>> >> an SSH-client container.  Also, when thinking about symmetry to the\n>> >> tls-client-server draft, note that the idea of creating a container\n>> >> for a TLS-server doesn't make sense (which one, right?)\n>> > Yes, for TLS there is no a common standalone TLS service. For SSH,\n>> > there is however since SSH was created for a specific service (while\n>> > TLS was created as a plugin to secure another existing service).\n>> > The client question we discussed before and I tend to agree that\n>> > usually a client you configure is embedded into some other\n>> > functionality that likely has its own configuration, so having a\n>> > grouping is OK.\n>> > But since there are SSH servers out there, do we expect this ID to\n>> > just provide groupings and we hope that some other module later comes\n>> > along and picks up the groupings and turns them into a more general\n>> > SSH server configuration model?\n>> This is my hope, so as to limit the scope of this document.\n>> > My understanding is that NC implementations actually come in different\n>> > forms, some simply running behind a regular SSH server while others\n>> > come with their own integrated SSH server. Does this affect the data\n>> > model?\n>> I think JUNOS is an example where the NC server runs \"behind an SSH\n>> server\", but it's not really \"behind\" so much as a fork/exec of an\n>> sshd process running the \"netconf\" subsystem (i.e., the NC server).\n>> Is this what you meant?\n>> Regardless, I don't see a need to change either the ietf-netconf-server\n>> or ietf-ssh-server data models to support either the fork/exec or\n>> link-to-library implementation strategies.  Do you?\n> Well, if your server is running as a subsystem of your regular SSH\n> daemon, then I think your SSH daemon configuration and your NETCONF\n> specific SSH configuration are essentially the same, no? Or more\n> precisely, you have an SSH daemon configuration plus a statement that\n> enables NETCONF as a subsystem, but you do not have a NETCONF specific\n> SSH configuration."}, "context_segments": [{"sid": 3718, "labels": "ClarificationElicitation,NeutralResponse,ClarificationElicitation,InformationProviding,Answer,InformationSeeking", "content": "\nWell, if your server is running as a subsystem of your regular SSH\ndaemon, then I think your SSH daemon configuration and your NETCONF\nspecific SSH configuration are essentially the same, no? Or more\nprecisely, you have an SSH daemon configuration plus a statement that\nenables NETCONF as a subsystem, but you do not have a NETCONF specific\nSSH configuration.\n"}]}, {"current_segment": {"sid": 3720, "labels": "Answer,Disagreement,NeutralResponse,InformationProviding,Answer,Disagreement,ProposeAction", "content": "\nNot exactly.  There's SSH listening on port 22 and then there is SSH\nlistening on port 830.  When listening on 830, it can be a separate\ninstance of `sshd` and given unique startup parameters (e.g., the\nsshd_config file).  It is not expected that this configuration\n(ietf-netconf-server) would ever influence the SSH listening on\nport 22.\n\nBack to if the implementation strategy can affects the data model, my\nassertion is that the startup parameters are equally applicable, whether\nusing the fork/exec (e.g., instances of `sshd`) or the link-to-library\n(e.g., a python script), and therefore I don't think the implementation\nstrategy affects the data model.\n"}, "context_segments": [{"sid": 3718, "labels": "ClarificationElicitation,NeutralResponse,ClarificationElicitation,InformationProviding,Answer,InformationSeeking", "content": "\nWell, if your server is running as a subsystem of your regular SSH\ndaemon, then I think your SSH daemon configuration and your NETCONF\nspecific SSH configuration are essentially the same, no? Or more\nprecisely, you have an SSH daemon configuration plus a statement that\nenables NETCONF as a subsystem, but you do not have a NETCONF specific\nSSH configuration.\n"}]}, {"current_segment": {"sid": 3721, "labels": "ClarificationElicitation,NeutralResponse,Question,NeutralResponse,InformationSeeking,InformationProviding", "content": "\nSo are you running a separate SSH server just for NETCONF or not? I am\nnot asking about 'it _can_ be given unique parameters'.\n"}, "context_segments": [{"sid": 3718, "labels": "ClarificationElicitation,NeutralResponse,ClarificationElicitation,InformationProviding,Answer,InformationSeeking", "content": "\nWell, if your server is running as a subsystem of your regular SSH\ndaemon, then I think your SSH daemon configuration and your NETCONF\nspecific SSH configuration are essentially the same, no? Or more\nprecisely, you have an SSH daemon configuration plus a statement that\nenables NETCONF as a subsystem, but you do not have a NETCONF specific\nSSH configuration.\n"}, {"sid": 3720, "labels": "Answer,Disagreement,NeutralResponse,InformationProviding,Answer,Disagreement,ProposeAction", "content": "\nNot exactly.  There's SSH listening on port 22 and then there is SSH\nlistening on port 830.  When listening on 830, it can be a separate\ninstance of `sshd` and given unique startup parameters (e.g., the\nsshd_config file).  It is not expected that this configuration\n(ietf-netconf-server) would ever influence the SSH listening on\nport 22.\n\nBack to if the implementation strategy can affects the data model, my\nassertion is that the startup parameters are equally applicable, whether\nusing the fork/exec (e.g., instances of `sshd`) or the link-to-library\n(e.g., a python script), and therefore I don't think the implementation\nstrategy affects the data model.\n"}]}, {"current_segment": {"sid": 3722, "labels": "Answer,Answer,InformationProviding", "content": "\nYes, sshd running on port 22 and sshd running on port 830 can be completely\ndifferent instances of sshd.  The can even be different executables, maybe\nport 830 is listened to by a Ruby-based application...\n"}, "context_segments": [{"sid": 3718, "labels": "ClarificationElicitation,NeutralResponse,ClarificationElicitation,InformationProviding,Answer,InformationSeeking", "content": "\nWell, if your server is running as a subsystem of your regular SSH\ndaemon, then I think your SSH daemon configuration and your NETCONF\nspecific SSH configuration are essentially the same, no? Or more\nprecisely, you have an SSH daemon configuration plus a statement that\nenables NETCONF as a subsystem, but you do not have a NETCONF specific\nSSH configuration.\n"}, {"sid": 3720, "labels": "Answer,Disagreement,NeutralResponse,InformationProviding,Answer,Disagreement,ProposeAction", "content": "\nNot exactly.  There's SSH listening on port 22 and then there is SSH\nlistening on port 830.  When listening on 830, it can be a separate\ninstance of `sshd` and given unique startup parameters (e.g., the\nsshd_config file).  It is not expected that this configuration\n(ietf-netconf-server) would ever influence the SSH listening on\nport 22.\n\nBack to if the implementation strategy can affects the data model, my\nassertion is that the startup parameters are equally applicable, whether\nusing the fork/exec (e.g., instances of `sshd`) or the link-to-library\n(e.g., a python script), and therefore I don't think the implementation\nstrategy affects the data model.\n"}, {"sid": 3721, "labels": "ClarificationElicitation,NeutralResponse,Question,NeutralResponse,InformationSeeking,InformationProviding", "content": "\nSo are you running a separate SSH server just for NETCONF or not? I am\nnot asking about 'it _can_ be given unique parameters'.\n"}]}, {"current_segment": {"sid": 3723, "labels": "Question,NeutralResponse,Question,ClarificationElicitation,InformationSeeking,InformationProviding", "content": "\nThe question is whether there is a separate SSH daemon for NETCONF or\nNETCONF is just hooked up the SSH daemon also used for other services.\nI think this does make a difference, no?\n"}, "context_segments": [{"sid": 3718, "labels": "ClarificationElicitation,NeutralResponse,ClarificationElicitation,InformationProviding,Answer,InformationSeeking", "content": "\nWell, if your server is running as a subsystem of your regular SSH\ndaemon, then I think your SSH daemon configuration and your NETCONF\nspecific SSH configuration are essentially the same, no? Or more\nprecisely, you have an SSH daemon configuration plus a statement that\nenables NETCONF as a subsystem, but you do not have a NETCONF specific\nSSH configuration.\n"}, {"sid": 3720, "labels": "Answer,Disagreement,NeutralResponse,InformationProviding,Answer,Disagreement,ProposeAction", "content": "\nNot exactly.  There's SSH listening on port 22 and then there is SSH\nlistening on port 830.  When listening on 830, it can be a separate\ninstance of `sshd` and given unique startup parameters (e.g., the\nsshd_config file).  It is not expected that this configuration\n(ietf-netconf-server) would ever influence the SSH listening on\nport 22.\n\nBack to if the implementation strategy can affects the data model, my\nassertion is that the startup parameters are equally applicable, whether\nusing the fork/exec (e.g., instances of `sshd`) or the link-to-library\n(e.g., a python script), and therefore I don't think the implementation\nstrategy affects the data model.\n"}]}, {"current_segment": {"sid": 3724, "labels": "Answer,Answer,InformationProviding", "content": "\nEach NETCONF server implementation is free to choose their SSH strategy.\nBut this is why the ietf-ssh-* modules have been careful to just focus on\nthe lowest common denominator and, specifically, not be openssl-specific.\n"}, "context_segments": [{"sid": 3718, "labels": "ClarificationElicitation,NeutralResponse,ClarificationElicitation,InformationProviding,Answer,InformationSeeking", "content": "\nWell, if your server is running as a subsystem of your regular SSH\ndaemon, then I think your SSH daemon configuration and your NETCONF\nspecific SSH configuration are essentially the same, no? Or more\nprecisely, you have an SSH daemon configuration plus a statement that\nenables NETCONF as a subsystem, but you do not have a NETCONF specific\nSSH configuration.\n"}, {"sid": 3720, "labels": "Answer,Disagreement,NeutralResponse,InformationProviding,Answer,Disagreement,ProposeAction", "content": "\nNot exactly.  There's SSH listening on port 22 and then there is SSH\nlistening on port 830.  When listening on 830, it can be a separate\ninstance of `sshd` and given unique startup parameters (e.g., the\nsshd_config file).  It is not expected that this configuration\n(ietf-netconf-server) would ever influence the SSH listening on\nport 22.\n\nBack to if the implementation strategy can affects the data model, my\nassertion is that the startup parameters are equally applicable, whether\nusing the fork/exec (e.g., instances of `sshd`) or the link-to-library\n(e.g., a python script), and therefore I don't think the implementation\nstrategy affects the data model.\n"}, {"sid": 3723, "labels": "Question,NeutralResponse,Question,ClarificationElicitation,InformationSeeking,InformationProviding", "content": "\nThe question is whether there is a separate SSH daemon for NETCONF or\nNETCONF is just hooked up the SSH daemon also used for other services.\nI think this does make a difference, no?\n"}]}, {"current_segment": {"sid": 3725, "labels": "InformationProviding,Answer,StateDecision", "content": "> >> >  To create a YANG model for a regular SSH server (for system level or\n> >> >  CLI access), one would have to implement the ietf-keystore model,\n> >> >  write a YANG module to suitably instantiate the\n> >> >  ietf-ssh-server:ssh-server-grouping and likely use some\n> >> >  endpoints-container grouping (well this has not been factored out\n> >> >  yet but I get to this in a different review).\n> >> Yes, it would be an exercise like this.\n> > So you are saying I guess this is the direction you see this to evolve.\n> Yes, I'm hoping to not increase the scope of this draft.  I do see it\n> as a possible future item to define a concrete SSH server data model.\n> That effort would entail evaluating various implementations to ensure\n> it captures the most commonly used bits in the base model, and using\n> features for the less-used parts."}, "context_segments": []}, {"current_segment": {"sid": 3726, "labels": "NeutralResponse,ProposeAction,Agreement,ContextSetting,ProposeAction,InformationProviding", "content": "\nYes, this should not be in this draft but at least it should be clear\nhow this all would integrate, see my comment above.\n"}, "context_segments": []}, {"current_segment": {"sid": 3727, "labels": "Agreement,NeutralResponse,InformationProviding,Agreement", "content": "\nYup, not in this draft.  Your comment above is still being discussed...\n"}, "context_segments": [{"sid": 3726, "labels": "NeutralResponse,ProposeAction,Agreement,ContextSetting,ProposeAction,InformationProviding", "content": "\nYes, this should not be in this draft but at least it should be clear\nhow this all would integrate, see my comment above.\n"}]}, {"current_segment": {"sid": 3728, "labels": "Question,InformationProviding,ContextSetting,Apologising,InformationSeeking,Social", "content": "> >> > - In section 2, should there be text that says what happens if there\n> >> >   is not client authentication configured or how to extend this for\n> >> >   authentication types commonly found on the web for instance?\n> >> Why should there be, isn't that a protocol-specific issue?  For\n> >> instance, per comments from before, the ietf-netconf-client and\n> >> ietf-restconf-client models add 'must' statements asserting\n> >> client-authentication is configured. Is this something that\n> >> should be mentioned in Security Considerations?\n> > I think it would help to spell out 'if no client auth configured,\n> > there is no client auth; if you want to always have client auth, a\n> > must statement can be used'.\n> Sorry, I misspoke before.  The 'must' statements were used elsewhere.\n> For section 2, /ietf-ssh-client:ssh-client/client-auth/auth-type is\n> set to mandatory true.  So, in this case, client-auth is always\n> configured, and your original concern unwarranted?"}, "context_segments": []}, {"current_segment": {"sid": 3729, "labels": "Answer,Answer,InformationProviding", "content": "\nLikely.\n"}, "context_segments": []}, {"current_segment": {"sid": 3730, "labels": "InformationSeeking,InformationProviding,ContextSetting,ProposeAction", "content": "> >> This sounds a lot like what was discussed before about configuring\n> >> NC/RC clients to authentication to call-home connections.  We decided\n> >> to just support a single set of auth params that would be used for all\n> >> servers (and not define a server-id to client-auth mapping).  So, this\n> >> grouping may not work well in some examples.  Is it okay?\n> > Perhaps not supporting SNI is sufficient for network management\n> > purposes but then also pretty clearly the TLS groupings are not\n> > generally usable.\n> Thinking about this some more, it seems my previous response\n> wasn't on target.  This isn't about what auth-credentials the\n> client passes, so much as how the client indicates the server\n> it wants to connect to in its client hello message.  It\n> seems like something to configure SNI should be added to\n> ietf-tls-client, how about this?\n>   +-- server-name-indication\n>     +-- server-name* [name-type]\n>       +-- name-type  enumeration (e.g., 'hostname')\n>       +-- name-value anydata     (e.g., foobar.example.com)\n> And likewise to ietf-tls-server, though I have less idea\n> how to do it (suggestions welcome!)  or, like mentioned above,\n> maybe it's just how ietf-tls-server is used."}, "context_segments": []}, {"current_segment": {"sid": 3731, "labels": "Question,NeutralResponse,ClarificationElicitation,NeutralResponse,InformationSeeking,InformationProviding", "content": "\nSecond guessing myself here, does this really need to be configuration\nor is the client-side of SNI just a function of how the code works?\n"}, "context_segments": [{"sid": 3730, "labels": "InformationSeeking,InformationProviding,ContextSetting,ProposeAction", "content": "> >> This sounds a lot like what was discussed before about configuring\n> >> NC/RC clients to authentication to call-home connections.  We decided\n> >> to just support a single set of auth params that would be used for all\n> >> servers (and not define a server-id to client-auth mapping).  So, this\n> >> grouping may not work well in some examples.  Is it okay?\n> > Perhaps not supporting SNI is sufficient for network management\n> > purposes but then also pretty clearly the TLS groupings are not\n> > generally usable.\n> Thinking about this some more, it seems my previous response\n> wasn't on target.  This isn't about what auth-credentials the\n> client passes, so much as how the client indicates the server\n> it wants to connect to in its client hello message.  It\n> seems like something to configure SNI should be added to\n> ietf-tls-client, how about this?\n>   +-- server-name-indication\n>     +-- server-name* [name-type]\n>       +-- name-type  enumeration (e.g., 'hostname')\n>       +-- name-value anydata     (e.g., foobar.example.com)\n> And likewise to ietf-tls-server, though I have less idea\n> how to do it (suggestions welcome!)  or, like mentioned above,\n> maybe it's just how ietf-tls-server is used."}]}, {"current_segment": {"sid": 3732, "labels": "Answer,NeutralResponse,InformationProviding", "content": "\nIt is the server side that matters I think.\n"}, "context_segments": [{"sid": 3730, "labels": "InformationSeeking,InformationProviding,ContextSetting,ProposeAction", "content": "> >> This sounds a lot like what was discussed before about configuring\n> >> NC/RC clients to authentication to call-home connections.  We decided\n> >> to just support a single set of auth params that would be used for all\n> >> servers (and not define a server-id to client-auth mapping).  So, this\n> >> grouping may not work well in some examples.  Is it okay?\n> > Perhaps not supporting SNI is sufficient for network management\n> > purposes but then also pretty clearly the TLS groupings are not\n> > generally usable.\n> Thinking about this some more, it seems my previous response\n> wasn't on target.  This isn't about what auth-credentials the\n> client passes, so much as how the client indicates the server\n> it wants to connect to in its client hello message.  It\n> seems like something to configure SNI should be added to\n> ietf-tls-client, how about this?\n>   +-- server-name-indication\n>     +-- server-name* [name-type]\n>       +-- name-type  enumeration (e.g., 'hostname')\n>       +-- name-value anydata     (e.g., foobar.example.com)\n> And likewise to ietf-tls-server, though I have less idea\n> how to do it (suggestions welcome!)  or, like mentioned above,\n> maybe it's just how ietf-tls-server is used."}, {"sid": 3731, "labels": "Question,NeutralResponse,ClarificationElicitation,NeutralResponse,InformationSeeking,InformationProviding", "content": "\nSecond guessing myself here, does this really need to be configuration\nor is the client-side of SNI just a function of how the code works?\n"}]}, {"current_segment": {"sid": 3733, "labels": "NeutralResponse,InformationProviding,NeutralResponse,ContextSetting", "content": "\nAccording to https://tools.ietf.org/html/rfc6066#section-3, the client\nis sending this data to the server.  My original idea was that this\nneeded to be client-side configuration.  But, as I second-guessed\nmyself, I'm now thinking that the client might do this automatically.\nFor instance, `wget https://example.com` may very well cause the client\nto send SNI info in the TLS handshake, even though it wasn't configured.\n"}, "context_segments": [{"sid": 3730, "labels": "InformationSeeking,InformationProviding,ContextSetting,ProposeAction", "content": "> >> This sounds a lot like what was discussed before about configuring\n> >> NC/RC clients to authentication to call-home connections.  We decided\n> >> to just support a single set of auth params that would be used for all\n> >> servers (and not define a server-id to client-auth mapping).  So, this\n> >> grouping may not work well in some examples.  Is it okay?\n> > Perhaps not supporting SNI is sufficient for network management\n> > purposes but then also pretty clearly the TLS groupings are not\n> > generally usable.\n> Thinking about this some more, it seems my previous response\n> wasn't on target.  This isn't about what auth-credentials the\n> client passes, so much as how the client indicates the server\n> it wants to connect to in its client hello message.  It\n> seems like something to configure SNI should be added to\n> ietf-tls-client, how about this?\n>   +-- server-name-indication\n>     +-- server-name* [name-type]\n>       +-- name-type  enumeration (e.g., 'hostname')\n>       +-- name-value anydata     (e.g., foobar.example.com)\n> And likewise to ietf-tls-server, though I have less idea\n> how to do it (suggestions welcome!)  or, like mentioned above,\n> maybe it's just how ietf-tls-server is used."}, {"sid": 3731, "labels": "Question,NeutralResponse,ClarificationElicitation,NeutralResponse,InformationSeeking,InformationProviding", "content": "\nSecond guessing myself here, does this really need to be configuration\nor is the client-side of SNI just a function of how the code works?\n"}, {"sid": 3732, "labels": "Answer,NeutralResponse,InformationProviding", "content": "\nIt is the server side that matters I think.\n"}]}, {"current_segment": {"sid": 3734, "labels": "NeutralResponse,ProposeAction,InformationProviding,NeutralResponse,ContextSetting,ProposeAction", "content": "\nOn the server side, based on the SNI received, you have to pick the\nright key and certificate. So there needs to be some mapping.\n"}, "context_segments": []}, {"current_segment": {"sid": 3735, "labels": "NeutralResponse,ContextSetting,NeutralResponse,ContextSetting,InformationProviding", "content": "\nhmmm, see below...\n"}, "context_segments": [{"sid": 3734, "labels": "NeutralResponse,ProposeAction,InformationProviding,NeutralResponse,ContextSetting,ProposeAction", "content": "\nOn the server side, based on the SNI received, you have to pick the\nright key and certificate. So there needs to be some mapping.\n"}]}, {"current_segment": {"sid": 3736, "labels": "Question,ProposeAction,InformationSeeking,InformationProviding", "content": "> >> > - The description of the list certificate says \"unordered list of\n> >> >   certificates the TLS server can pick from when sending its Server\n> >> >   Certificate message.\". So how does the server pick the certificate?\n> >> >   Is the idea that the somewhat vague text takes care of SNI? What if\n> >> >   SNI is not used, which certificate is picked? How does the server\n> >> >   pick the corresponding key? (Or are these certificates assumed to\n> >> >   all be associated with the same key?)\n> >> I'm looking at https://tools.ietf.org/html/rfc5246#section-7.4.2:\n> >>    If the server has multiple certificates, it chooses one of them based\n> >>    on the above-mentioned criteria (in addition to other criteria, such\n> >>    as transport layer endpoint, local configuration and preferences,\n> >>    etc.).\n> > So the server magically picks one. This may be OK for the TLS\n> > spec to say, not sure this is sufficient for a configuration spec.\n> Do you want the configuration spec to have a pointer to this part of\n> the TLS spec?"}, "context_segments": []}, {"current_segment": {"sid": 3737, "labels": "Answer,Social,InformationProviding,Answer", "content": "\nWell, the TLS spec text does not help me to configure this such that I\nget the right certificate selected for the SNI presented...\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}, "context_segments": []}, {"current_segment": {"sid": 3738, "labels": "ExtensionOfPrevious,Question,ProposeAction,InformationSeeking,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction", "content": "\nPeaking at TLS 1.3, draft-ietf-tls-tls13-21#section-4.4.2.2 says:\n\n-  The \"server_name\" and \"certificate_authorities\" extensions\n[RFC6066] are used to *guide certificate selection*.\n\nand in S4.2.4 it says:\n\nThe \"trusted_ca_keys\" extension, which serves a similar purpose\n[RFC6066], but is more complicated, is not used in TLS 1.3 (although\nit may appear in ClientHello messages from clients which are offering\nprior versions of TLS).\n\nSo, there's at least 3 different ways that the server can go about\nselecting which certificates it sends.  To me, this again seems like\nsomething maybe the server's code does internally - e.g., it sifts\nthrough all the certs it has (i.e. list certificate in the YANG model),\nsending the subset matching protocol-level criteria.  Do you know?\n\nPeaking at NGINX config, it seems to have a config like:\n\n+--- server* [ <not sure what the key might be> ]\n+--- listen inet:port    // 443\n+--- server_name string  // example.com\n+--- root        string  // /usr/share/nginx/www\n+--- ssl         Boolean // on\n+--- ssl_certificate     // /etc/nginx/ssl/example.org/server.crt;\n+--- ssl_certificate_key // /etc/nginx/ssl/example.org/server.key;\n\nNote that the TLS-part of the config has been splayed across the\napp-specific config.  By contrast, the groupings we have now are more\nfor a single SSL host (not virtual hosting).  We could add 'sni-to-name'\nmapping structures, but we it be helpful to complex TLS apps like NGINX?\n"}, "context_segments": [{"sid": 3737, "labels": "Answer,Social,InformationProviding,Answer", "content": "\nWell, the TLS spec text does not help me to configure this such that I\nget the right certificate selected for the SNI presented...\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}]}, {"current_segment": {"sid": 3739, "labels": "NeutralResponse,Social,InformationProviding,Answer", "content": "\nI think the key here is server_name as this allows nginx to multiplex\nincoming connections to the \"right\" list instance, i.e., I can have\nmultiple server configured to listen on the same port and the TLS SNI\nindication provides a hint which list instance is used and this\nimplies the correct security parameters.\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}, "context_segments": [{"sid": 3737, "labels": "Answer,Social,InformationProviding,Answer", "content": "\nWell, the TLS spec text does not help me to configure this such that I\nget the right certificate selected for the SNI presented...\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}, {"sid": 3738, "labels": "ExtensionOfPrevious,Question,ProposeAction,InformationSeeking,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction", "content": "\nPeaking at TLS 1.3, draft-ietf-tls-tls13-21#section-4.4.2.2 says:\n\n-  The \"server_name\" and \"certificate_authorities\" extensions\n[RFC6066] are used to *guide certificate selection*.\n\nand in S4.2.4 it says:\n\nThe \"trusted_ca_keys\" extension, which serves a similar purpose\n[RFC6066], but is more complicated, is not used in TLS 1.3 (although\nit may appear in ClientHello messages from clients which are offering\nprior versions of TLS).\n\nSo, there's at least 3 different ways that the server can go about\nselecting which certificates it sends.  To me, this again seems like\nsomething maybe the server's code does internally - e.g., it sifts\nthrough all the certs it has (i.e. list certificate in the YANG model),\nsending the subset matching protocol-level criteria.  Do you know?\n\nPeaking at NGINX config, it seems to have a config like:\n\n+--- server* [ <not sure what the key might be> ]\n+--- listen inet:port    // 443\n+--- server_name string  // example.com\n+--- root        string  // /usr/share/nginx/www\n+--- ssl         Boolean // on\n+--- ssl_certificate     // /etc/nginx/ssl/example.org/server.crt;\n+--- ssl_certificate_key // /etc/nginx/ssl/example.org/server.key;\n\nNote that the TLS-part of the config has been splayed across the\napp-specific config.  By contrast, the groupings we have now are more\nfor a single SSL host (not virtual hosting).  We could add 'sni-to-name'\nmapping structures, but we it be helpful to complex TLS apps like NGINX?\n"}]}, {"current_segment": {"sid": 3740, "labels": "NeutralResponse,Question,InformationProviding,Question,ClarificationElicitation,InformationProviding,Agreement,InformationSeeking", "content": "\nYes, \"server_name\" would be the key for the server-side SNI lookup.  But\nwhere are we going with this?  I think that we concluded that the current\ngroupings are more for a single SSL host and not amazingly useful to a\nserver that wants to do virtual hosting.  Is this a problem we need to\nsolve now?\n\nPS: Gary also replied regarding the server-side of SNI.\n"}, "context_segments": [{"sid": 3737, "labels": "Answer,Social,InformationProviding,Answer", "content": "\nWell, the TLS spec text does not help me to configure this such that I\nget the right certificate selected for the SNI presented...\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}, {"sid": 3738, "labels": "ExtensionOfPrevious,Question,ProposeAction,InformationSeeking,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction", "content": "\nPeaking at TLS 1.3, draft-ietf-tls-tls13-21#section-4.4.2.2 says:\n\n-  The \"server_name\" and \"certificate_authorities\" extensions\n[RFC6066] are used to *guide certificate selection*.\n\nand in S4.2.4 it says:\n\nThe \"trusted_ca_keys\" extension, which serves a similar purpose\n[RFC6066], but is more complicated, is not used in TLS 1.3 (although\nit may appear in ClientHello messages from clients which are offering\nprior versions of TLS).\n\nSo, there's at least 3 different ways that the server can go about\nselecting which certificates it sends.  To me, this again seems like\nsomething maybe the server's code does internally - e.g., it sifts\nthrough all the certs it has (i.e. list certificate in the YANG model),\nsending the subset matching protocol-level criteria.  Do you know?\n\nPeaking at NGINX config, it seems to have a config like:\n\n+--- server* [ <not sure what the key might be> ]\n+--- listen inet:port    // 443\n+--- server_name string  // example.com\n+--- root        string  // /usr/share/nginx/www\n+--- ssl         Boolean // on\n+--- ssl_certificate     // /etc/nginx/ssl/example.org/server.crt;\n+--- ssl_certificate_key // /etc/nginx/ssl/example.org/server.key;\n\nNote that the TLS-part of the config has been splayed across the\napp-specific config.  By contrast, the groupings we have now are more\nfor a single SSL host (not virtual hosting).  We could add 'sni-to-name'\nmapping structures, but we it be helpful to complex TLS apps like NGINX?\n"}, {"sid": 3739, "labels": "NeutralResponse,Social,InformationProviding,Answer", "content": "\nI think the key here is server_name as this allows nginx to multiplex\nincoming connections to the \"right\" list instance, i.e., I can have\nmultiple server configured to listen on the same port and the TLS SNI\nindication provides a hint which list instance is used and this\nimplies the correct security parameters.\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}]}, {"current_segment": {"sid": 3741, "labels": "Question,InformationProviding,ContextSetting,Question,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,StateDecision,InformationSeeking", "content": "In preparation for posting an update to this draft (to resolve most of\nthe validation issues caught by Benoit's tools), I reviewed this entire\nthread again.\n\nFirst, it looks like the fork in the thread with Gary is still open\n(Gary, can you see about closing out these issues?)   Here are the\ntopics being discussed there:\n- add a config false list of identities in ietf-ssh-common?\n- rather than moving them to an iana-* module...\n- add a typedef to ietf-keystore that wraps the leafrefs to\nkeystore?\n- SNI/virtual-hosting (this is picked up below as well)\n"}, "context_segments": []}, {"current_segment": {"sid": 3742, "labels": "Social,Social", "content": "Hi Juergen,\n"}, "context_segments": []}, {"current_segment": {"sid": 3743, "labels": "ContextSetting,ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nContinuing with this discussion:\n"}, "context_segments": []}, {"current_segment": {"sid": 3744, "labels": "InformationSeeking,InformationProviding,UnderstandingNegative", "content": "On Thu, Aug 10, 2017 at 08:11:11PM +0000, Kent Watsen wrote:\n> Hi Juergen,\n> > I took a look at both documents today and I am attaching my two\n> > reviews.  Since the structure of the documents is quite similar, the\n> > review comments are also quite similar.\n> Thanks!  And, to make responding easier, I've copied/pasted both\n> sets of comments in below.\n> Kent\n> For the ssh-client-server draft\n> > - The overall setup is somewhat complicated but I do understand why.\n> >  Obviously, the attempts to make things generic come with a price\n> >  since many YANG definitions interact with other definitions that\n> >  need to be understood. And while the end result is that we can\n> >  configure SSH clients and servers for NETCONF, we only have a\n> >  collection of groupings to configure a regular SSH client or\n> >  server. Should we have an instantiation of these groupings for\n> >  regular SSH clients and servers as well?\n> I'm hoping to not have to do this, but can see that there might be\n> value in doing so in order to further proof-out the model.  To do\n> this right would entail something like what Clyde did for the syslog\n> model in evaluating many vendor's implementations to find a common\n> denominator.  I can imagine the WG undertaking such an analysis for\n> an SSH-server container, but I fail to see how it could be done for\n> an SSH-client container.  Also, when thinking about symmetry to the\n> tls-client-server draft, note that the idea of creating a container\n> for a TLS-server doesn't make sense (which one, right?)"}, "context_segments": []}, {"current_segment": {"sid": 3745, "labels": "NeutralResponse,Agreement,Question,Question,ClarificationElicitation,InformationProviding,Agreement,InformationSeeking", "content": "\nYes, for TLS there is no a common standalone TLS service. For SSH,\nthere is however since SSH was created for a specific service (while\nTLS was created as a plugin to secure another existing service).\n\nThe client question we discussed before and I tend to agree that\nusually a client you configure is embedded into some other\nfunctionality that likely has its own configuration, so having a\ngrouping is OK.\n\nBut since there are SSH servers out there, do we expect this ID to\njust provide groupings and we hope that some other module later comes\nalong and picks up the groupings and turns them into a more general\nSSH server configuration model?\n\nMy understanding is that NC implementations actually come in different\nforms, some simply running behind a regular SSH server while others\ncome with their own integrated SSH server. Does this affect the data\nmodel?\n"}, "context_segments": []}, {"current_segment": {"sid": 3746, "labels": "Agreement,InformationProviding", "content": "> >  To create a YANG model for a regular SSH server (for system level or\n> >  CLI access), one would have to implement the ietf-keystore model,\n> >  write a YANG module to suitably instantiate the\n> >  ietf-ssh-server:ssh-server-grouping and likely use some\n> >  endpoints-container grouping (well this has not been factored out\n> >  yet but I get to this in a different review).\n> Yes, it would be an exercise like this."}, "context_segments": []}, {"current_segment": {"sid": 3747, "labels": "ClarificationElicitation,NeutralResponse,InformationSeeking,InformationProviding", "content": "\nSo you are saying I guess this is the direction you see this to evolve.\n"}, "context_segments": []}, {"current_segment": {"sid": 3748, "labels": "ContextSetting,StateDecision,InformationProviding", "content": "> >  Obviously, reusability comes with a certain price in complexity and\n> >  I guess this is why we often had WG meetings where Kent asked\n> >  questions but nobody felt to respond. Anyway, if we create these\n> >  reusable components, we need to find a name for them.  Saying these\n> >  are SSH client and server models (as the title does) is likely\n> >  confusing people since the definitions are really only meaningful if\n> >  instantiated in other contexts. The simplest change might be to\n> >  change the title to \"YANG Groupings for SSH Clients and SSH\n> >  Servers\".\n> Yes, awkward silence, and now here we are.  For now, I've change\n> the title as suggested.  I also made the similar change for the\n> tls-client-server draft."}, "context_segments": []}, {"current_segment": {"sid": 3749, "labels": "NeutralResponse,NeutralResponse,InformationProviding", "content": "\nOK\n"}, "context_segments": []}, {"current_segment": {"sid": 3750, "labels": "ClarificationElicitation,InformationProviding,ContextSetting,InformationSeeking", "content": "> We could copy/paste the keystore example, but isn't the following\n> note just above the example good enough?\n>    This example is consistent with the\n>    examples presented in Section 2.2 of [I-D.ietf-netconf-keystore]."}, "context_segments": []}, {"current_segment": {"sid": 3751, "labels": "NeutralResponse,Question,Question,InformationProviding,NeutralResponse,InformationSeeking", "content": "\nAs a reader, having to look at multiple RFCs is a bit harder. During\nproduction of the RFCs, how do we make sure things stay aligned? Well,\nthis problem exists in any case.\n"}, "context_segments": []}, {"current_segment": {"sid": 3752, "labels": "InformationProviding,Agreement,ContextSetting", "content": "> > - The identities in ietf-ssh-common probably need to be moved to IANA\n> >   and there likely need to be proper procedures for managing the\n> >   identities.  Are the identities clearly SSH specific? If not, the\n> >   management will likely be more complex.\n> Right, and this is related to the keystore identity issue as well.\n> https://github.com/netconf-wg/keystore/issues/8."}, "context_segments": []}, {"current_segment": {"sid": 3753, "labels": "Agreement,Agreement,InformationProviding", "content": "\nYes.\n"}, "context_segments": []}, {"current_segment": {"sid": 3754, "labels": "Social,Social", "content": "Hi Juergen,"}, "context_segments": []}, {"current_segment": {"sid": 3755, "labels": "Social,Social", "content": "Hi Juergen,\n"}, "context_segments": []}, {"current_segment": {"sid": 3756, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\nMy responses in-line."}, "context_segments": []}, {"current_segment": {"sid": 3757, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nBTW, I've updated the github addressing some of the previous comments,\nyou might want to merge your local copies."}, "context_segments": []}, {"current_segment": {"sid": 3758, "labels": "Question,InformationProviding,InformationSeeking", "content": "> <GARY>\n> They are SSH-specific in that they come from the IANA registry for\n> the SSH protocol.  It would be difficult to come up with\n> protocol-independent identities as different protocols have\n> different ideas as to an algorithm 'unit' is.  For example, in SSH\n> you specify KEX algorithms separate from MAC algorithms, but in TLS\n> the combination of those plus other algorithm types constitute a\n> cipher suite.  If we move the identities to an iana-* module, I\n> suppose the expectation is that every IANA number has an associated\n> YANG identity.  In that case, do we want to have an if-feature for\n> every identity (there are hundreds and they are almost all\n> optional-to-implement)?  Or do we want to get rid of if-features\n> altogether and let the management agent return an error when it\n> can't support the requested configuration?\n> </GARY>"}, "context_segments": []}, {"current_segment": {"sid": 3759, "labels": "NeutralResponse,InformationSeeking,InformationProviding,Answer", "content": "\nThis is what I expected (that the identities are protocol specific).\nPersonally, I do not think it is useful to define large numbers of\nfeatures and servers should reject identities not supported. The\nquestion is whether there should be config false list of identities\nsupported so that a client does not have to do trial and error.\n"}, "context_segments": []}, {"current_segment": {"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}, "context_segments": []}, {"current_segment": {"sid": 3761, "labels": "InformationProviding,NeutralResponse,ProposeAction", "content": "> > - I think it is a good practice to introduce for every base identity a\n> >  corresponding specific identityref type so that tree diagrams etc\n> >  have a more readable type. The pattern is:\n> >  identity foo {\n> >    description\n> >     \"Abstract base identity for foos.\";\n> >  typedef foo-ref {\n> >    type identifyref { base foo; }\n> >    description\n> >      \"A foo identity reference.\";\n> >  And then you use foo-ref as the type in the data models that refer to\n> >  foo identities.\n> All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n> please take care of this one?).  That said, there's still the larger\n> issue of us moving all the identities into some other module."}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3762, "labels": "NeutralResponse,Question,ClarificationElicitation,InformationProviding,NeutralResponse,ProposeAction,InformationSeeking", "content": "\nIt is not clear whether one module is the answer, i.e., whether the\nidentities are identical between security protocols or whether they\ntraditionally all do their own little soup. If the later, then this is\nlikely how it works in practice. So the security WGs actually\ncoordinate when they need a new name / label for a security mechanism?\nIf not, creating a central module is going to lead to headaches for\nthose in charge to maintain it.\n"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3763, "labels": "InformationProviding,ContextSetting", "content": "> > - Security considerations: This may need some rewriting since there is\n> >  really no data tree. The general template does not really work well\n> >  for modules only defining reusable groupings. I think what is really\n> >  needed here are guidelines for authors of documents using the\n> >  groupings. Also remove text that clearly is irrelevant (there are no\n> >  RPC so why spent a paragraph on them).\n> I added this sentence (to both drafts):\n>   Since the modules defined in this document define only groupings,\n>   these considerations are primarily for the designers of other\n>   modules that use these groupings."}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3764, "labels": "NeutralResponse,NeutralResponse,InformationProviding", "content": "\nOK\n"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3765, "labels": "InformationProviding,ContextSetting,StateDecision", "content": "> I also change \"module\" to \"modules\", since the draft defines more\n> than one.\n> I left the \"RPC\" paragraph (and both the RPC and \"readable nodes\"\n> paragraphs in the tls-client-server draft).  These paragraphs have\n> a place where a list of nodes are to be supplied.  In this case,\n> my putting \"NONE\" seems to 1) preserve the template and 2) indicate\n> that the consideration was analyzed.  This is unchartered waters\n> but, it seems that we'd want the considerations to be explicit in\n> what all it considered."}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3766, "labels": "NeutralResponse,ProposeAction,NeutralResponse,ProposeAction,InformationProviding", "content": "\nPersonally, I prefer to not see text that does not apply in the final\ndocument. Perhaps decorate this with an RFC editor instruction to\nremove the text during the final stages of the process.\n"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3767, "labels": "Question,ClarificationElicitation,InformationProviding,Answer,ContextSetting,InformationSeeking", "content": "> > - In section 2, should there be text that says what happens if there\n> >   is not client authentication configured or how to extend this for\n> >   authentication types commonly found on the web for instance?\n> Why should there be, isn't that a protocol-specific issue?  For instance,\n> per comments from before, the ietf-netconf-client and ietf-restconf-client\n> models add 'must' statements asserting client-authentication is configured.\n> Is this something that should be mentioned in Security Considerations?"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3768, "labels": "ProposeAction,Answer,ProposeAction,InformationProviding", "content": "\nI think it would help to spell out 'if no client auth configured,\nthere is no client auth; if you want to always have client auth, a\nmust statement can be used'.\n"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3769, "labels": "InformationProviding,ProposeAction,UnderstandingNegative", "content": "> > - Does the TLS server not need to know which key to use? I only see\n>     a reference to a certificate to use.\n> I don't know which node you're looking at, but there is one reference\n> to a certificate that is under a specific key, and there is another\n> reference to a set of certificates that is not associated with any key."}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3770, "labels": "NeutralResponse,InformationProviding,NeutralResponse", "content": "\nAh, it is a leafref to .../key/certificates/certificate - I did not\ncatch that.\n"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3771, "labels": "ClarificationElicitation,NeutralResponse,InformationSeeking,InformationProviding", "content": "> > - With web servers, things are often more complicated since you only\n> >   know which key/certificate to use once you know which site is being\n> >   accessed. The Server Name Indication (SNI) TLS extension [RFC 6066]\n> >   deals with this. How could this be factored into the YANG server\n> >   grouping?\n> I'm unsure what you're saying.  A client is configured to connect to a\n> specific site, but it doesn't know what site it will actually connect\n> to, and hence can't be configured to know which certificate to use?"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3772, "labels": "InformationProviding,Answer,InformationProviding,Answer", "content": "\nNo, the server starts a TLS handshake but it does not yet know which\nsite hosted on the server the client goes to and hence the server does\nnot know which certificate to use. In HTTP, it is the Host: header\nthat tells the server which virtual host you talk to. TLS happens\nbefore that and hence the TLS server either has to guess the right\ncertificate (bad) or the TLS client uses SNI to let the server know\nduring the TLS exchange which Host: he wants to talk to. The point\nhere is that the assumption that a listing transport endpoint maps to\na specific certificate in general is not true.\n"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3773, "labels": "ClarificationElicitation,InformationProviding,NeutralResponse,StateDecision,InformationSeeking", "content": "> This sounds a lot like what was discussed before about configuring\n> NC/RC clients to authentication to call-home connections.  We decided\n> to just support a single set of auth params that would be used for all\n> servers (and not define a server-id to client-auth mapping).  So, this\n> grouping may not work well in some examples.  Is it okay?"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3774, "labels": "Answer,InformationProviding,Answer", "content": "\nPerhaps not supporting SNI is sufficient for network management\npurposes but then also pretty clearly the TLS groupings are not\ngenerally usable.\n"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3775, "labels": "InformationProviding,NeutralResponse,ContextSetting", "content": "> > - The description of the list certificate says \"unordered list of\n> >   certificates the TLS server can pick from when sending its Server\n> >   Certificate message.\". So how does the server pick the certificate?\n> >   Is the idea that the somewhat vague text takes care of SNI? What if\n> >   SNI is not used, which certificate is picked? How does the server\n> >   pick the corresponding key? (Or are these certificates assumed to\n> >   all be associated with the same key?)\n> I'm looking at https://tools.ietf.org/html/rfc5246#section-7.4.2:\n>    If the server has multiple certificates, it chooses one of them based\n>    on the above-mentioned criteria (in addition to other criteria, such\n>    as transport layer endpoint, local configuration and preferences,\n>    etc.)."}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3776, "labels": "NeutralResponse,Social,InformationProviding,NeutralResponse", "content": "\nSo the server magically picks one. This may be OK for the TLS spec to say,\nnot sure this is sufficient for a configuration spec.\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}, "context_segments": [{"sid": 3760, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": ">     > - I think it is a good practice to introduce for every base identity a\n>     >  corresponding specific identityref type so that tree diagrams etc\n>     >  have a more readable type. The pattern is:\n>     >  identity foo {\n>     >    description\n>     >     \"Abstract base identity for foos.\";\n>     >  typedef foo-ref {\n>     >    type identifyref { base foo; }\n>     >    description\n>     >      \"A foo identity reference.\";\n>     >  And then you use foo-ref as the type in the data models that refer to\n>     >  foo identities.\n>     All of the identities are in the \"ietf-*-common\" modules (Gary, can you\n>     please take care of this one?).  That said, there's still the larger\n>     issue of us moving all the identities into some other module.\n> <GARY>\n> I had suggested defining types for the leafrefs to (trusted-){keys, certs} in\n> the keystore module, so that modules using keystore won't need to refer to\n> paths in keystore and removes their coupling to the structure of keystore.\n> There isn't as big a benefit to encapsulating identityrefs.  The node\n> identifiers are descriptive of their type and I kind of like knowing that a type\n> is an identityref without referring to the typedef, but I think a case can be\n> made for consistency.\n> </GARY>"}]}, {"current_segment": {"sid": 3777, "labels": "Agreement,Agreement,InformationProviding", "content": "\nI agree that identities for the references into the keystore lists are\neven more useful.\n"}, "context_segments": []}, {"current_segment": {"sid": 3778, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": "> <GARY>\n> We haven't explored virtual hosting.  I think the server grouping could be used\n> as it currently is, because each virtual host could have a separate TLS\n> configuration, although I don't know if any real-world implementations support\n> the full set of TLS configurations for each virtual host.\n> Here's a hypothetical web server config, the SNI would be inferred from\n> 'server-name', which is an application-level config.\n> e.g.:\n>   <web-server>\n>     <use-tls>true</use-tls>\n>     <ip-address>0.0.0.0</ip-address>\n>     <port>443</port>\n>     <virtual-host>\n>       <server-name>foo.com</server-name>\n>       <tls-server-cfg>\n>         <certificate>foo_cert_1</certificate>\n>         <certificate>foo_cert_2</certificate>\n>       </tls-server-cfg>\n>     </virtual-host>\n>     <virtual-host>\n>       <server-name>bar.org</server-name>\n>       <tls-server-cfg>\n>         <certificate>bar_cert_1</certificate>\n>         <certificate>bar_cert_2</certificate>\n>       </tls-server-cfg>\n>     </virtual-host>\n>   </web-server>\n> </GARY>"}, "context_segments": []}, {"current_segment": {"sid": 3779, "labels": "Agreement,Social,NeutralResponse,InformationProviding", "content": "\nThis might work.\n\n/js\n\nJuergen Schoenwaelder           Jacobs University Bremen gGmbH\nPhone: +49 421 200 3587         Campus Ring 1 | 28759 Bremen | Germany\nFax:   +49 421 200 3103         <http://www.jacobs-university.de/>"}, "context_segments": []}, {"current_segment": {"sid": 3780, "labels": "InformationProviding,InformationProviding,ContextSetting,StateDecision", "content": "\nI've trimmed all but the ongoing threads..."}, "context_segments": []}, {"current_segment": {"sid": 3781, "labels": "Social,Social", "content": "Hi Juergen,\n"}, "context_segments": []}, {"current_segment": {"sid": 3782, "labels": "Social,Social", "content": "Hi Kent/Juergen,"}, "context_segments": []}, {"current_segment": {"sid": 547, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,StateDecision,ExtensionOfPrevious", "content": "\nOld: May 2013\nNew: Delete\nSend Quality of Service markings of RTCWeb packets (draft-\nietf-rtcweb-qos) to IESG for publication as Proposed Standard\nNote: We will delete this milestone for now. If there is need\nfor an RTCWEB document, we will resurrect it. We expect TSVWG to adopt\ntheir part of this soon."}, "context_segments": []}, {"current_segment": {"sid": 5269, "labels": "Social,Social", "content": "Hi,"}, "context_segments": [{"sid": 547, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,StateDecision,ExtensionOfPrevious", "content": "\nOld: May 2013\nNew: Delete\nSend Quality of Service markings of RTCWeb packets (draft-\nietf-rtcweb-qos) to IESG for publication as Proposed Standard\nNote: We will delete this milestone for now. If there is need\nfor an RTCWEB document, we will resurrect it. We expect TSVWG to adopt\ntheir part of this soon."}]}, {"current_segment": {"sid": 7677, "labels": "Question,InformationProviding,Question,InformationSeeking", "content": "\nWhy would you do this with Blake2b as opposed to using the personalization\nstrings feature?\n\nIt's simpler and likely faster to do this than to use personalization\nstrings (which, e.g., the Blake2 internet-draft doesn't include).  See\nmy note (message-id 20151014152755.03AAE607C3@jupiter.mumble.net) at\n\nhttps://www.ietf.org/mail-archive/web/cfrg/current/msg07420.html\n\nfor details."}, "context_segments": [{"sid": 547, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,StateDecision,ExtensionOfPrevious", "content": "\nOld: May 2013\nNew: Delete\nSend Quality of Service markings of RTCWeb packets (draft-\nietf-rtcweb-qos) to IESG for publication as Proposed Standard\nNote: We will delete this milestone for now. If there is need\nfor an RTCWEB document, we will resurrect it. We expect TSVWG to adopt\ntheir part of this soon."}, {"sid": 5269, "labels": "Social,Social", "content": "Hi,"}]}, {"current_segment": {"sid": 548, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: Mar 2014\nNew: Sep 2014\nSend STUN Usage for Consent Freshness to IESG for publication as\nproposed standard\ndraft-ietf-rtcweb-stun-consent-freshness"}, "context_segments": []}, {"current_segment": {"sid": 5270, "labels": "InformationSeeking,ClarificationElicitation,InformationProviding,ContextSetting,ProposeAction,Question,InformationProviding,ProposeAction", "content": "\nIn the open issues list in draft-ietf-mmusic-rfc2326bis-12 there is issue:\n6.   Should a IPv6 multicast scope parameter for the Transport\nheader be defined? This would be similar to TTL."}, "context_segments": [{"sid": 548, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: Mar 2014\nNew: Sep 2014\nSend STUN Usage for Consent Freshness to IESG for publication as\nproposed standard\ndraft-ietf-rtcweb-stun-consent-freshness"}]}, {"current_segment": {"sid": 549, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: May 2103\nNew: May 2014\nSend Data Stream Transport for non-media data (draft-ietf-\nrtcweb-data-channel) to IESG for publication as Proposed Standard\ndraft-ietf-rtcweb-data-channel draft-ietf-rtcweb-data-protocol"}, "context_segments": []}, {"current_segment": {"sid": 5271, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,InformationProviding,StateDecision", "content": "\nHowever after refreshing my knowledge of the IPv6 multicast addresses in\nRFC 4291 I think this is an non issue. The reason is that the address\nitself contains scope specification."}, "context_segments": [{"sid": 549, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: May 2103\nNew: May 2014\nSend Data Stream Transport for non-media data (draft-ietf-\nrtcweb-data-channel) to IESG for publication as Proposed Standard\ndraft-ietf-rtcweb-data-channel draft-ietf-rtcweb-data-protocol"}]}, {"current_segment": {"sid": 550, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: New milestone\nNew: Sep 2014\nSend Specification of Transport Protocols and their NAT Traversal to\nIESG for publication as Proposed Standard\ndraft-ietf-rtcweb-transports"}, "context_segments": []}, {"current_segment": {"sid": 551, "labels": "InformationProviding,ExtensionOfPrevious", "content": "On 01/23/2014 10:19 AM, Magnus Westerlund wrote:\n> Old: New milestone\n> New: Sep 2014\n> Send Specification of Transport Protocols and their NAT Traversal to\n> IESG for publication as Proposed Standard\n> draft-ietf-rtcweb-transports"}, "context_segments": [{"sid": 550, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: New milestone\nNew: Sep 2014\nSend Specification of Transport Protocols and their NAT Traversal to\nIESG for publication as Proposed Standard\ndraft-ietf-rtcweb-transports"}]}, {"current_segment": {"sid": 552, "labels": "Question,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,ExtensionOfPrevious,InformationSeeking", "content": "\nGiven that there has been fairly small controversies here, I feel that\nthis should be doable in the same timeframe as rtp-usage - that is, April.\n\nIf the chairs' decision is that the normative parts of -firewalls- needs\nto go into -transport-, I would aim this for September.\n\nNote: There is no mention of -firewalls- in the milestones suggested.\nWhat's the chairs' thinking on this?\n"}, "context_segments": [{"sid": 550, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: New milestone\nNew: Sep 2014\nSend Specification of Transport Protocols and their NAT Traversal to\nIESG for publication as Proposed Standard\ndraft-ietf-rtcweb-transports"}]}, {"current_segment": {"sid": 553, "labels": "InformationSeeking,Question,InformationProviding,Agreement,ContextSetting,ProposeAction,Question,Agreement", "content": "\nThat would be great. I am a bit hesitant to put to many documents into\nthis time-frame. In addition I wonder if we are certain that we have\nensure that all pieces that are required to be part of this document are\nknown already in April. I am mostly thinking of the ongoing discussions\naround NAT traversal protocols. However, if you like to have a shorter\ntarget date, what about June? That should allow both RTP parts, the data\nchannel parts and this NAT/FW traversal protocol stuff to settled with\nno big open ends.\n"}, "context_segments": [{"sid": 550, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: New milestone\nNew: Sep 2014\nSend Specification of Transport Protocols and their NAT Traversal to\nIESG for publication as Proposed Standard\ndraft-ietf-rtcweb-transports"}, {"sid": 552, "labels": "Question,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,ExtensionOfPrevious,InformationSeeking", "content": "\nGiven that there has been fairly small controversies here, I feel that\nthis should be doable in the same timeframe as rtp-usage - that is, April.\n\nIf the chairs' decision is that the normative parts of -firewalls- needs\nto go into -transport-, I would aim this for September.\n\nNote: There is no mention of -firewalls- in the milestones suggested.\nWhat's the chairs' thinking on this?\n"}]}, {"current_segment": {"sid": 554, "labels": "InformationProviding,NeutralResponse,ContextSetting,ProposeAction,StateDecision,Apologising,NeutralResponse,Apologising,Social", "content": "\nSorry, this I realize is one editing I should have done, but forgot to\ndo before sending this out to the WG. I was considering to clarify that\nit specifies the protocols used for NAT/FW traversal. But after\ndiscussion the chairs did come to conclusion to keep the milestone\nsimple. Thus the proposal for milestone text should be:\n\nSend Specification of Transport Protocols to IESG for publication\nas Proposed Standard\n"}, "context_segments": [{"sid": 550, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: New milestone\nNew: Sep 2014\nSend Specification of Transport Protocols and their NAT Traversal to\nIESG for publication as Proposed Standard\ndraft-ietf-rtcweb-transports"}, {"sid": 552, "labels": "Question,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,ExtensionOfPrevious,InformationSeeking", "content": "\nGiven that there has been fairly small controversies here, I feel that\nthis should be doable in the same timeframe as rtp-usage - that is, April.\n\nIf the chairs' decision is that the normative parts of -firewalls- needs\nto go into -transport-, I would aim this for September.\n\nNote: There is no mention of -firewalls- in the milestones suggested.\nWhat's the chairs' thinking on this?\n"}]}, {"current_segment": {"sid": 555, "labels": "ContextSetting,NeutralResponse,InformationProviding", "content": "Mostly, this looks realistic.\n\nOne place where I'm more optimistic:\n"}, "context_segments": []}, {"current_segment": {"sid": 556, "labels": "InformationProviding,ContextSetting,ProposeAction,InformationProviding", "content": "\nBelow you will find a proposal for updating the WGs milestones. This\ninclude creating two new milestones and deleting one. Regarding the\ndates, they are though targets, and might not be reached. But to reach\nour end of year goal for the core documents we see a need to push hard.\nYou can also see the order in which we believe the work can be completed\nin."}, "context_segments": []}, {"current_segment": {"sid": 557, "labels": "InformationSeeking,ExtensionOfPrevious,ProposeAction,Social,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\nPlease provide any feedback on these milestones by 6th of February."}, "context_segments": []}, {"current_segment": {"sid": 558, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ExtensionOfPrevious", "content": "\nSo each milestone we have i listed below with its current date and the\nproposed new one."}, "context_segments": []}, {"current_segment": {"sid": 559, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: Oct 2012\nNew: March 2014\nSend Security and Privacy Problem Statement (draft-ietf-\nrtcweb-security) to IESG for publication as Informational\ndraft-ietf-rtcweb-security"}, "context_segments": []}, {"current_segment": {"sid": 560, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious", "content": "\nOld: Oct 2012\nNew: Feb 2014\nComplete Overview (and hold for dependency resolution)\n(draft-ietf-rtcweb-overview)\ndraft-ietf-rtcweb-overview"}, "context_segments": []}, {"current_segment": {"sid": 561, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,ExtensionOfPrevious", "content": "\nOld: New milestone\nNew: Dec 2014\nSend Overview (after dependencies are ready) to IESG for publication as\nApplicability Statement\ndraft-ietf-rtcweb-overview\nNote: This is a new milestone created to show when we believe the\noverview truly can be published, i.e. at the end of the set of core\ndocuments."}, "context_segments": []}, {"current_segment": {"sid": 562, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: Oct 2012\nNew: Jan 2014\nSend Use Cases document (draft-ietf-rtcweb-use-cases-and- requirements)\nto IESG for publication as Informational\ndraft-ietf-rtcweb-use-cases-and-requirements"}, "context_segments": []}, {"current_segment": {"sid": 563, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: Jan 2013\nNew: April 2014\nSend Media Transport (draft-ietf-rtcweb-rtp-usage) to IESG for\npublication as Proposed Standard\ndraft-ietf-rtcweb-rtp-usage"}, "context_segments": []}, {"current_segment": {"sid": 564, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious", "content": "\nOld: Jan 2013\nNew: Jun 2014\nSend Security Solution (draft-ietf-rtcweb-security-arch) to IESG for\npublication as Proposed Standard\ndraft-ietf-rtcweb-security-arch"}, "context_segments": []}, {"current_segment": {"sid": 565, "labels": "InformationProviding,ContextSetting,ProposeAction,ExtensionOfPrevious", "content": "\nOld: Jan 2013\nNew: Sep 2014\nSend Signalling Negotiation and NAT Traversal (draft-ietf-rtcweb-jsep)\nto IESG for publication as Proposed Standard\ndraft-ietf-rtcweb-jsep"}, "context_segments": []}, {"current_segment": {"sid": 566, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious", "content": "\nOld: Jan 2013\nNew: April 2014\nAudio Processing and Audio Codecs (draft-ietf-rtcweb-audio) to IESG for\npublication as Proposed Standard\ndraft-ietf-rtcweb-audio"}, "context_segments": []}, {"current_segment": {"sid": 567, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious", "content": "\nJan 2013\nNew: Dec 2014\nVideo Processing and Video Codecs (draft-ietf-rtcweb-video) to IESG for\npublication as Proposed Standard Video Processing and Video Codecs\n(draft-ietf-rtcweb-video) to IESG for publication as Proposed Standard"}, "context_segments": []}, {"current_segment": {"sid": 568, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,ExtensionOfPrevious", "content": "\nComment: Needs editing to remove double listing. I still think we will\nneed to produce this document."}, "context_segments": []}, {"current_segment": {"sid": 750, "labels": "ExtensionOfPrevious,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\nNaturally, I expect multiple use cases to be added (and perhaps even\nsome use cases marked up with \"RTCWEB can't do this\") before we're finished."}, "context_segments": []}, {"current_segment": {"sid": 5278, "labels": "Social,Social", "content": "Hi,"}, "context_segments": [{"sid": 750, "labels": "ExtensionOfPrevious,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\nNaturally, I expect multiple use cases to be added (and perhaps even\nsome use cases marked up with \"RTCWEB can't do this\") before we're finished."}]}, {"current_segment": {"sid": 7700, "labels": "ExtensionOfPrevious,InformationProviding,ProposeAction", "content": "\nThe IESG would also like the IRTF to review the comments in the\ndatatracker related to this document and determine whether or not they\nmerit incorporation into the document. Comments may exist in both the\nballot and the history log."}, "context_segments": [{"sid": 750, "labels": "ExtensionOfPrevious,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\nNaturally, I expect multiple use cases to be added (and perhaps even\nsome use cases marked up with \"RTCWEB can't do this\") before we're finished."}, {"sid": 5278, "labels": "Social,Social", "content": "Hi,"}]}, {"current_segment": {"sid": 751, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nWe would like to adopt a WG document with the purpose for describing use\ncases for the RTCWEB work. This document would be targeted as\npublication as an Inforamtional RFC eventually."}, "context_segments": []}, {"current_segment": {"sid": 5279, "labels": "InformationProviding,ContextSetting,ProposeAction,Social,InformationProviding,ProposeAction", "content": "\nAnother way of looking at this with the introduction of video is to have\nthe UAS capable to compose a Video picture/clip from the \"Text list\" of\navailable movies, and then the client use DTMF or voice to select the\nmovie (no more problems w/ proxies as the information are exchanged in a\nstandard way on the data channel)... Regarding RTSP many flaws have been\nidentified, pls see\nhttp://www.ietf.org/internet-drafts/draft-ietf-mmusic-rfc2326bis-09.txt"}, "context_segments": [{"sid": 751, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nWe would like to adopt a WG document with the purpose for describing use\ncases for the RTCWEB work. This document would be targeted as\npublication as an Inforamtional RFC eventually."}]}, {"current_segment": {"sid": 7701, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe IESG review is documented at:\nhttps://datatracker.ietf.org/doc/conflict-review-irtf-cfrg-eddsa/"}, "context_segments": [{"sid": 751, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nWe would like to adopt a WG document with the purpose for describing use\ncases for the RTCWEB work. This document would be targeted as\npublication as an Inforamtional RFC eventually."}, {"sid": 5279, "labels": "InformationProviding,ContextSetting,ProposeAction,Social,InformationProviding,ProposeAction", "content": "\nAnother way of looking at this with the introduction of video is to have\nthe UAS capable to compose a Video picture/clip from the \"Text list\" of\navailable movies, and then the client use DTMF or voice to select the\nmovie (no more problems w/ proxies as the information are exchanged in a\nstandard way on the data channel)... Regarding RTSP many flaws have been\nidentified, pls see\nhttp://www.ietf.org/internet-drafts/draft-ietf-mmusic-rfc2326bis-09.txt"}]}, {"current_segment": {"sid": 752, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThe candidate document for this is:\nWeb Real-Time Communication Use-cases and Requirements\nhttps://datatracker.ietf.org/doc/draft-holmberg-rtcweb-ucreqs/"}, "context_segments": []}, {"current_segment": {"sid": 7702, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA URL of the reviewed Internet Draft is:\nhttps://datatracker.ietf.org/doc/draft-irtf-cfrg-eddsa/"}, "context_segments": [{"sid": 752, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThe candidate document for this is:\nWeb Real-Time Communication Use-cases and Requirements\nhttps://datatracker.ietf.org/doc/draft-holmberg-rtcweb-ucreqs/"}]}, {"current_segment": {"sid": 753, "labels": "Agreement,Agreement,InformationProviding", "content": "\nAgreed"}, "context_segments": [{"sid": 752, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThe candidate document for this is:\nWeb Real-Time Communication Use-cases and Requirements\nhttps://datatracker.ietf.org/doc/draft-holmberg-rtcweb-ucreqs/"}, {"sid": 7702, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA URL of the reviewed Internet Draft is:\nhttps://datatracker.ietf.org/doc/draft-irtf-cfrg-eddsa/"}]}, {"current_segment": {"sid": 754, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nBased on our interim last week it was clear that there are some use\ncases that clearly needs development. However, the WG chairs believe\nthat future development of the document can be done as WG item."}, "context_segments": []}, {"current_segment": {"sid": 7703, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe process for such documents is described in RFC 5743"}, "context_segments": [{"sid": 754, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nBased on our interim last week it was clear that there are some use\ncases that clearly needs development. However, the WG chairs believe\nthat future development of the document can be done as WG item."}]}, {"current_segment": {"sid": 755, "labels": "ExtensionOfPrevious,InformationSeeking,ExtensionOfPrevious,ContextSetting,ProposeAction,Social,InformationProviding", "content": "\nWG participants please indicate if you agree in adopting this document\nas a basis, or if not, what the short comings you would like to see\naddressed prior to adoption. Once more, the document will be continued\nto be developed under the WG control and this is far from any final\nversion."}, "context_segments": []}, {"current_segment": {"sid": 7704, "labels": "Thanking,Thanking,Social", "content": "\nThank you,"}, "context_segments": [{"sid": 755, "labels": "ExtensionOfPrevious,InformationSeeking,ExtensionOfPrevious,ContextSetting,ProposeAction,Social,InformationProviding", "content": "\nWG participants please indicate if you agree in adopting this document\nas a basis, or if not, what the short comings you would like to see\naddressed prior to adoption. Once more, the document will be continued\nto be developed under the WG control and this is far from any final\nversion."}]}, {"current_segment": {"sid": 756, "labels": "InformationSeeking,InformationProviding,ExtensionOfPrevious,ProposeAction,Social", "content": "\nPlease provide your view no later than Friday the 24th."}, "context_segments": []}, {"current_segment": {"sid": 7705, "labels": "InformationProviding,InformationProviding", "content": "The IESG has completed a review of draft-irtf-cfrg-eddsa-08 consistent\nwith RFC5742."}, "context_segments": [{"sid": 756, "labels": "InformationSeeking,InformationProviding,ExtensionOfPrevious,ProposeAction,Social", "content": "\nPlease provide your view no later than Friday the 24th."}]}, {"current_segment": {"sid": 757, "labels": "Agreement,Agreement,InformationProviding", "content": "+1"}, "context_segments": []}, {"current_segment": {"sid": 7706, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe IESG has no problem with the publication of 'Edwards-curve Digital\nSignature Algorithm (EdDSA) ' <draft-irtf-cfrg-eddsa-08.txt> as an\nInformational RFC."}, "context_segments": [{"sid": 757, "labels": "Agreement,Agreement,InformationProviding", "content": "+1"}]}, {"current_segment": {"sid": 758, "labels": "Social", "content": "Hi Mary,\n"}, "context_segments": []}, {"current_segment": {"sid": 7707, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThe IESG has concluded that there is no conflict between this document\nand IETF work."}, "context_segments": [{"sid": 758, "labels": "Social", "content": "Hi Mary,\n"}]}, {"current_segment": {"sid": 759, "labels": "Agreement,Agreement,InformationProviding", "content": "Agreed."}, "context_segments": []}, {"current_segment": {"sid": 760, "labels": "Agreement,Agreement,InformationProviding", "content": "I also agree with adopting this document and will contribute to the development of the use cases."}, "context_segments": []}, {"current_segment": {"sid": 761, "labels": "Agreement,Agreement,InformationProviding", "content": "I agree with adopting the document as a WG starting point."}, "context_segments": []}, {"current_segment": {"sid": 762, "labels": "InformationProviding,InformationProviding,ContextSetting,StateDecision", "content": "\nI have reviewed the input from the WG participants, and there has all\nbeen in support for adopting this document as WG item. So hereby I\ndeclare https://datatracker.ietf.org/doc/draft-holmberg-rtcweb-ucreqs/ a\nWG document. At this point the WG chairs request no changes in the\ndocument editor team."}, "context_segments": []}, {"current_segment": {"sid": 763, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nIn addition there has been input on how to improve the document which we\nrequest the editors to take into account."}, "context_segments": []}, {"current_segment": {"sid": 764, "labels": "NeutralResponse,InformationProviding,ContextSetting,ProposeAction", "content": "I think the document is a good starting point, although, I personally would\nprefer that the mapping would should the use cases that were used to derive\nthe requirements versus the requirements that are derived from the use case.\nOtherise, you have to   search through the use cases to see the one from\nwhich the requirement was derived. Or perhaps having the mapping both\ndirections."}, "context_segments": []}, {"current_segment": {"sid": 765, "labels": "NeutralResponse,ProposeAction,InformationProviding", "content": "\nWe can fix that.\n"}, "context_segments": [{"sid": 764, "labels": "NeutralResponse,InformationProviding,ContextSetting,ProposeAction", "content": "I think the document is a good starting point, although, I personally would\nprefer that the mapping would should the use cases that were used to derive\nthe requirements versus the requirements that are derived from the use case.\nOtherise, you have to   search through the use cases to see the one from\nwhich the requirement was derived. Or perhaps having the mapping both\ndirections."}]}, {"current_segment": {"sid": 766, "labels": "ExtensionOfPrevious,ExtensionOfPrevious,ContextSetting,ProposeAction,InformationProviding", "content": "\nAlso, I would suggest some reformatting so that new use cases can be easily\nadded - i.e., it doesn't look like the list is a result of the\n<list>...</list> xml formatting. If that's not the case, I still don't like\nthis dashy list style."}, "context_segments": []}, {"current_segment": {"sid": 767, "labels": "NeutralResponse,ProposeAction,Thanking,InformationProviding,Social", "content": "\nWe can fix that too.\n\nThanks!\n"}, "context_segments": [{"sid": 766, "labels": "ExtensionOfPrevious,ExtensionOfPrevious,ContextSetting,ProposeAction,InformationProviding", "content": "\nAlso, I would suggest some reformatting so that new use cases can be easily\nadded - i.e., it doesn't look like the list is a result of the\n<list>...</list> xml formatting. If that's not the case, I still don't like\nthis dashy list style."}]}, {"current_segment": {"sid": 768, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nEditors, please submit the document as\ndraft-ietf-rtcweb-use-cases-and-requirements-00.txt."}, "context_segments": []}, {"current_segment": {"sid": 890, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nTitle           : Web Real-Time Communication Use-cases and Requirements\nAuthor(s)       : Christer Holmberg\nStefan Hakansson\nGoran AP Eriksson\nFilename        : draft-ietf-rtcweb-use-cases-and-requirements-09.txt\nPages           : 28\nDate            : 2012-06-27"}, "context_segments": []}, {"current_segment": {"sid": 5334, "labels": "Social", "content": "Hello Folks,"}, "context_segments": [{"sid": 890, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nTitle           : Web Real-Time Communication Use-cases and Requirements\nAuthor(s)       : Christer Holmberg\nStefan Hakansson\nGoran AP Eriksson\nFilename        : draft-ietf-rtcweb-use-cases-and-requirements-09.txt\nPages           : 28\nDate            : 2012-06-27"}]}, {"current_segment": {"sid": 7807, "labels": "Question,InformationProviding,ProposeAction,InformationProviding,ProposeAction,InformationSeeking", "content": "\nI think using anything else than identity / SHA-512 as prehash\nin Ed448 is a bad idea.\n\nWell, I think *any* fixed prehash is a bad idea, but identity and\nrandomized prehash were both rejected in favour of appeasing legacy\nI/U/F APIs and encouraging DoS against verifiers, so given that...\n\nThe reason isn't so much that SHA3-512 is hilariously slow (Blake2b\nis well known to be a speed demon), but due to practical\nconsiderations the prehash is going to leak out of the \"box\", so\nnow applications need to deal with more casess.\n\nE.g. TLS 1.2 has apparently been designed to leak the prehash\nthat way (TLS 1.3 retains the basic structure, but the amounts\nof data to sign are much smaller).\n\nCan you elaborate on this leak?  I'm not familiar enough with the\ndetails of TLS 1.2 to know what you're referring to.\n\nIf it's just the SignatureAndHashAlgorithm list, in which one could\nconceivably mix Ed448 with a prehash of, e.g., SHA-1 (which is still\nthere in the TLS 1.3 draft, apparently), that doesn't preclude the\nCFRG from recommending that Ed448 be mixed only with SHA3-512."}, "context_segments": [{"sid": 890, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nTitle           : Web Real-Time Communication Use-cases and Requirements\nAuthor(s)       : Christer Holmberg\nStefan Hakansson\nGoran AP Eriksson\nFilename        : draft-ietf-rtcweb-use-cases-and-requirements-09.txt\nPages           : 28\nDate            : 2012-06-27"}, {"sid": 5334, "labels": "Social", "content": "Hello Folks,"}]}, {"current_segment": {"sid": 7808, "labels": "InformationProviding,Agreement,InformationProviding,Agreement", "content": "\nWell, agreed. I consider signature-level online operation a bad\nidea.\n\nAnd with regards to those legacy APIs, I suspect PKCS#11 is major\none, and it tends to cause problems everywhere it touches (e.g. Firefox\nTHS fix got delayed some time in order to deal wit PCKS#11 issues).\n"}, "context_segments": [{"sid": 890, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nTitle           : Web Real-Time Communication Use-cases and Requirements\nAuthor(s)       : Christer Holmberg\nStefan Hakansson\nGoran AP Eriksson\nFilename        : draft-ietf-rtcweb-use-cases-and-requirements-09.txt\nPages           : 28\nDate            : 2012-06-27"}, {"sid": 5334, "labels": "Social", "content": "Hello Folks,"}, {"sid": 7807, "labels": "Question,InformationProviding,ProposeAction,InformationProviding,ProposeAction,InformationSeeking", "content": "\nI think using anything else than identity / SHA-512 as prehash\nin Ed448 is a bad idea.\n\nWell, I think *any* fixed prehash is a bad idea, but identity and\nrandomized prehash were both rejected in favour of appeasing legacy\nI/U/F APIs and encouraging DoS against verifiers, so given that...\n\nThe reason isn't so much that SHA3-512 is hilariously slow (Blake2b\nis well known to be a speed demon), but due to practical\nconsiderations the prehash is going to leak out of the \"box\", so\nnow applications need to deal with more casess.\n\nE.g. TLS 1.2 has apparently been designed to leak the prehash\nthat way (TLS 1.3 retains the basic structure, but the amounts\nof data to sign are much smaller).\n\nCan you elaborate on this leak?  I'm not familiar enough with the\ndetails of TLS 1.2 to know what you're referring to.\n\nIf it's just the SignatureAndHashAlgorithm list, in which one could\nconceivably mix Ed448 with a prehash of, e.g., SHA-1 (which is still\nthere in the TLS 1.3 draft, apparently), that doesn't preclude the\nCFRG from recommending that Ed448 be mixed only with SHA3-512."}]}, {"current_segment": {"sid": 891, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nAbstract:\nThis document describes web based real-time communication use-cases.\nBased on the use-cases, the document also derives requirements\nrelated to the browser, and the API used by web applications to\nrequest and control media stream and data exchange services provided\nby the browser."}, "context_segments": []}, {"current_segment": {"sid": 5335, "labels": "StateDecision,StateDecision,InformationProviding", "content": "I would be willing to review\ndraft-ietf-payload-vp8-08\nand/or\ndraft-ietf-avtcore-avp-codecs-02"}, "context_segments": [{"sid": 891, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nAbstract:\nThis document describes web based real-time communication use-cases.\nBased on the use-cases, the document also derives requirements\nrelated to the browser, and the API used by web applications to\nrequest and control media stream and data exchange services provided\nby the browser."}]}, {"current_segment": {"sid": 7809, "labels": "InformationProviding,Answer,InformationProviding,NeutralResponse", "content": "\nTLS 1.2 spec impiles (altough it doesn't state this explicitly) that\nTLS protocol code itself does the HashAlgorithm hashing of the\nsignature and then passes the hash to be signed.\n"}, "context_segments": [{"sid": 891, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nAbstract:\nThis document describes web based real-time communication use-cases.\nBased on the use-cases, the document also derives requirements\nrelated to the browser, and the API used by web applications to\nrequest and control media stream and data exchange services provided\nby the browser."}, {"sid": 5335, "labels": "StateDecision,StateDecision,InformationProviding", "content": "I would be willing to review\ndraft-ietf-payload-vp8-08\nand/or\ndraft-ietf-avtcore-avp-codecs-02"}, {"sid": 7807, "labels": "Question,InformationProviding,ProposeAction,InformationProviding,ProposeAction,InformationSeeking", "content": "\nI think using anything else than identity / SHA-512 as prehash\nin Ed448 is a bad idea.\n\nWell, I think *any* fixed prehash is a bad idea, but identity and\nrandomized prehash were both rejected in favour of appeasing legacy\nI/U/F APIs and encouraging DoS against verifiers, so given that...\n\nThe reason isn't so much that SHA3-512 is hilariously slow (Blake2b\nis well known to be a speed demon), but due to practical\nconsiderations the prehash is going to leak out of the \"box\", so\nnow applications need to deal with more casess.\n\nE.g. TLS 1.2 has apparently been designed to leak the prehash\nthat way (TLS 1.3 retains the basic structure, but the amounts\nof data to sign are much smaller).\n\nCan you elaborate on this leak?  I'm not familiar enough with the\ndetails of TLS 1.2 to know what you're referring to.\n\nIf it's just the SignatureAndHashAlgorithm list, in which one could\nconceivably mix Ed448 with a prehash of, e.g., SHA-1 (which is still\nthere in the TLS 1.3 draft, apparently), that doesn't preclude the\nCFRG from recommending that Ed448 be mixed only with SHA3-512."}]}, {"current_segment": {"sid": 892, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThe IETF datatracker status page for this draft is:\nhttps://datatracker.ietf.org/doc/draft-ietf-rtcweb-use-cases-and-requirements"}, "context_segments": []}, {"current_segment": {"sid": 5336, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": "\nhere is a list of Drafts which our ADs would like us to provide a\nreview; nonr of them are on next IESG telechat, thus we can set the due\ndate to June 25th for all of them."}, "context_segments": [{"sid": 892, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThe IETF datatracker status page for this draft is:\nhttps://datatracker.ietf.org/doc/draft-ietf-rtcweb-use-cases-and-requirements"}]}, {"current_segment": {"sid": 7810, "labels": "Question,InformationProviding,ProposeAction,Question,InformationProviding,NeutralResponse,InformationSeeking", "content": "\nOr one could perhaps specify that al EdDSA signatures always have\nHashAlgorithm of 0 (None). No current signature primitive uses\nHA0, but it is explicitly specified for future signature primitives.\nEd25519 and Ed448 definitely always use HA0. But does e.g.\nEd25519ph use HA0 or HA6 (SHA-512)? There is no SHA3-512 currently.\n"}, "context_segments": [{"sid": 892, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThe IETF datatracker status page for this draft is:\nhttps://datatracker.ietf.org/doc/draft-ietf-rtcweb-use-cases-and-requirements"}, {"sid": 5336, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": "\nhere is a list of Drafts which our ADs would like us to provide a\nreview; nonr of them are on next IESG telechat, thus we can set the due\ndate to June 25th for all of them."}, {"sid": 7807, "labels": "Question,InformationProviding,ProposeAction,InformationProviding,ProposeAction,InformationSeeking", "content": "\nI think using anything else than identity / SHA-512 as prehash\nin Ed448 is a bad idea.\n\nWell, I think *any* fixed prehash is a bad idea, but identity and\nrandomized prehash were both rejected in favour of appeasing legacy\nI/U/F APIs and encouraging DoS against verifiers, so given that...\n\nThe reason isn't so much that SHA3-512 is hilariously slow (Blake2b\nis well known to be a speed demon), but due to practical\nconsiderations the prehash is going to leak out of the \"box\", so\nnow applications need to deal with more casess.\n\nE.g. TLS 1.2 has apparently been designed to leak the prehash\nthat way (TLS 1.3 retains the basic structure, but the amounts\nof data to sign are much smaller).\n\nCan you elaborate on this leak?  I'm not familiar enough with the\ndetails of TLS 1.2 to know what you're referring to.\n\nIf it's just the SignatureAndHashAlgorithm list, in which one could\nconceivably mix Ed448 with a prehash of, e.g., SHA-1 (which is still\nthere in the TLS 1.3 draft, apparently), that doesn't preclude the\nCFRG from recommending that Ed448 be mixed only with SHA3-512."}]}, {"current_segment": {"sid": 893, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThere's also a htmlized version available at:\nhttp://tools.ietf.org/html/draft-ietf-rtcweb-use-cases-and-requirements-09"}, "context_segments": []}, {"current_segment": {"sid": 5337, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nI start with the \"long\" one:"}, "context_segments": [{"sid": 893, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThere's also a htmlized version available at:\nhttp://tools.ietf.org/html/draft-ietf-rtcweb-use-cases-and-requirements-09"}]}, {"current_segment": {"sid": 7811, "labels": "InformationProviding,Social", "content": "\n-Ilari"}, "context_segments": [{"sid": 893, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThere's also a htmlized version available at:\nhttp://tools.ietf.org/html/draft-ietf-rtcweb-use-cases-and-requirements-09"}, {"sid": 5337, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nI start with the \"long\" one:"}, {"sid": 7807, "labels": "Question,InformationProviding,ProposeAction,InformationProviding,ProposeAction,InformationSeeking", "content": "\nI think using anything else than identity / SHA-512 as prehash\nin Ed448 is a bad idea.\n\nWell, I think *any* fixed prehash is a bad idea, but identity and\nrandomized prehash were both rejected in favour of appeasing legacy\nI/U/F APIs and encouraging DoS against verifiers, so given that...\n\nThe reason isn't so much that SHA3-512 is hilariously slow (Blake2b\nis well known to be a speed demon), but due to practical\nconsiderations the prehash is going to leak out of the \"box\", so\nnow applications need to deal with more casess.\n\nE.g. TLS 1.2 has apparently been designed to leak the prehash\nthat way (TLS 1.3 retains the basic structure, but the amounts\nof data to sign are much smaller).\n\nCan you elaborate on this leak?  I'm not familiar enough with the\ndetails of TLS 1.2 to know what you're referring to.\n\nIf it's just the SignatureAndHashAlgorithm list, in which one could\nconceivably mix Ed448 with a prehash of, e.g., SHA-1 (which is still\nthere in the TLS 1.3 draft, apparently), that doesn't preclude the\nCFRG from recommending that Ed448 be mixed only with SHA3-512."}]}, {"current_segment": {"sid": 894, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nA diff from previous version is available at:\nhttp://tools.ietf.org/rfcdiff?url2=draft-ietf-rtcweb-use-cases-and-requirements-09"}, "context_segments": []}, {"current_segment": {"sid": 5338, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\n1) draft-ietf-mmusic-rfc2326bis-34 Real Time Streaming Protocol 2.0 (RTSP)"}, "context_segments": [{"sid": 894, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nA diff from previous version is available at:\nhttp://tools.ietf.org/rfcdiff?url2=draft-ietf-rtcweb-use-cases-and-requirements-09"}]}, {"current_segment": {"sid": 895, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nInternet-Drafts are also available by anonymous FTP at:\nftp://ftp.ietf.org/internet-drafts/"}, "context_segments": []}, {"current_segment": {"sid": 5339, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\nwich might e a candidate for a Joint Review."}, "context_segments": [{"sid": 895, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nInternet-Drafts are also available by anonymous FTP at:\nftp://ftp.ietf.org/internet-drafts/"}]}, {"current_segment": {"sid": 5340, "labels": "StateDecision,Agreement,ProposeAction,InformationProviding", "content": "\nI can review that one, but I agree that a Joint Review would be a good\nidea since it is so massive.\n"}, "context_segments": [{"sid": 895, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nInternet-Drafts are also available by anonymous FTP at:\nftp://ftp.ietf.org/internet-drafts/"}, {"sid": 5339, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\nwich might e a candidate for a Joint Review."}]}, {"current_segment": {"sid": 896, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Real-Time Communication in WEB-browsers Working Group of the IETF."}, "context_segments": []}, {"current_segment": {"sid": 5341, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nThen we have:"}, "context_segments": [{"sid": 896, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Real-Time Communication in WEB-browsers Working Group of the IETF."}]}, {"current_segment": {"sid": 5342, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\n2) draft-ietf-abfab-eapapplicability-03 Update to the EAP Applicability\nStatement for ABFAB"}, "context_segments": []}, {"current_segment": {"sid": 5343, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\n3) draft-ietf-avtcore-avp-codecs-02 Update to Recommended Codecs for the RTP\nProfile for Audio and Video Conferences with Minimal Control (RTP/AVP)"}, "context_segments": []}, {"current_segment": {"sid": 5344, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\n4) draft-ietf-avtcore-idms-09 Inter-destination Media Synchronization using\nthe RTP Control Protocol (RTCP)"}, "context_segments": []}, {"current_segment": {"sid": 5345, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\n5) draft-ietf-payload-vp8-08 RTP Payload Format for VP8 Video"}, "context_segments": []}, {"current_segment": {"sid": 5346, "labels": "InformationProviding,ExtensionOfPrevious", "content": "\nAs you see we have a lot of multimedia this time!"}, "context_segments": []}, {"current_segment": {"sid": 5347, "labels": "InformationSeeking,ProposeAction,StateDecision,InformationProviding", "content": "\nVolunteers, before I send the assignments tomorrow?"}, "context_segments": []}, {"current_segment": {"sid": 5348, "labels": "Thanking,Social", "content": "\nthanks indeed,"}, "context_segments": []}, {"current_segment": {"sid": 4110, "labels": "ContextSetting,InformationProviding,ContextSetting", "content": "In -tls13-11 section 7.2 [1] there is this.."}, "context_segments": []}, {"current_segment": {"sid": 6846, "labels": "Social", "content": "Hi,"}, "context_segments": [{"sid": 4110, "labels": "ContextSetting,InformationProviding,ContextSetting", "content": "In -tls13-11 section 7.2 [1] there is this.."}]}, {"current_segment": {"sid": 4111, "labels": "ContextSetting,InformationProviding,ExtensionOfPrevious", "content": "\n7.2.  Updating Traffic Keys and IVs"}, "context_segments": []}, {"current_segment": {"sid": 6847, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nWe have now submitted an updated version of the RTSP 1.1 draft. Until it\nbecomes availalbe through IETF you can find it here:"}, "context_segments": [{"sid": 4111, "labels": "ContextSetting,InformationProviding,ExtensionOfPrevious", "content": "\n7.2.  Updating Traffic Keys and IVs"}]}, {"current_segment": {"sid": 4112, "labels": "InformationProviding,InformationProviding", "content": "\nOnce the handshake is complete, ..."}, "context_segments": []}, {"current_segment": {"sid": 6848, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nhttp://standards.ericsson.net/westerlund/draft-ietf-mmusic-rfc2326bis-10.txt"}, "context_segments": [{"sid": 4112, "labels": "InformationProviding,InformationProviding", "content": "\nOnce the handshake is complete, ..."}]}, {"current_segment": {"sid": 4113, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nOnce traffic_secret_N+1 and its associated traffic keys have been\ncomputed, implementations SHOULD delete traffic_secret_N.  Once the\ndirectional keys are no longer needed, they SHOULD be deleted as\nwell."}, "context_segments": []}, {"current_segment": {"sid": 6849, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nYou can also get a side by side DIFF here:\nWarning this is an 1.7 mb large file.\nhttp://standards.ericsson.net/westerlund/diff-rtsp-core-09-10.html"}, "context_segments": [{"sid": 4113, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nOnce traffic_secret_N+1 and its associated traffic keys have been\ncomputed, implementations SHOULD delete traffic_secret_N.  Once the\ndirectional keys are no longer needed, they SHOULD be deleted as\nwell."}]}, {"current_segment": {"sid": 4114, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,InformationProviding,InformationSeeking", "content": "\n..and it isn't clear to me what is meant by \"directional keys\" in the\nparagraph above (that is the only occurance of the term I find)?"}, "context_segments": []}, {"current_segment": {"sid": 6850, "labels": "ExtensionOfPrevious,ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nThe major changes in this version are:"}, "context_segments": [{"sid": 4114, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,InformationProviding,InformationSeeking", "content": "\n..and it isn't clear to me what is meant by \"directional keys\" in the\nparagraph above (that is the only occurance of the term I find)?"}]}, {"current_segment": {"sid": 4115, "labels": "Question,ContextSetting,Question,InformationSeeking,InformationProviding", "content": "\nis the term meant as a forward reference to this table in S 7.3 and thus\nto the notion of \"client write key\" and \"server write key\" ?"}, "context_segments": []}, {"current_segment": {"sid": 6851, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n- Making into RTSP 1.1\n- Removing PING and implementing the agreed keep-alive resolution\n- Added a chapter on proxies\n- Clarfications around changing transport parameters.\n- Changed syntax for RTP-Info"}, "context_segments": [{"sid": 4115, "labels": "Question,ContextSetting,Question,InformationSeeking,InformationProviding", "content": "\nis the term meant as a forward reference to this table in S 7.3 and thus\nto the notion of \"client write key\" and \"server write key\" ?"}]}, {"current_segment": {"sid": 4116, "labels": "Answer,InformationProviding,Answer", "content": "\nYes.\n\n-Ben\n"}, "context_segments": [{"sid": 4115, "labels": "Question,ContextSetting,Question,InformationSeeking,InformationProviding", "content": "\nis the term meant as a forward reference to this table in S 7.3 and thus\nto the notion of \"client write key\" and \"server write key\" ?"}, {"sid": 6851, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n- Making into RTSP 1.1\n- Removing PING and implementing the agreed keep-alive resolution\n- Added a chapter on proxies\n- Clarfications around changing transport parameters.\n- Changed syntax for RTP-Info"}]}, {"current_segment": {"sid": 4117, "labels": "InformationProviding,InformationProviding", "content": "\n| Key Type         | Purpose            |\n| Client Write Key | \"client write key\" |\n| Server Write Key | \"server write key\" |"}, "context_segments": []}, {"current_segment": {"sid": 6852, "labels": "ExtensionOfPrevious,InformationSeeking,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,Social", "content": "\nThis version resolves most of the open issues. However a few does stil\nremain. I also expect review will find a number of smaller issues.\nPlease review and send comments to the MMUSIC mailing list."}, "context_segments": [{"sid": 4117, "labels": "InformationProviding,InformationProviding", "content": "\n| Key Type         | Purpose            |\n| Client Write Key | \"client write key\" |\n| Server Write Key | \"server write key\" |"}]}, {"current_segment": {"sid": 4118, "labels": "Thanking,Thanking,Social", "content": "\nthx,"}, "context_segments": []}, {"current_segment": {"sid": 4222, "labels": "ContextSetting,InformationProviding", "content": "Hello,\n\nI'm not sure if this should be included, so not making a PR yet.\n\nComplete examples for requests may help implementers (of both servers\nand clients) to understand the specifications. All existing examples\nhave pseudo-code like base64url({...}) and no untruncated keys or\nsignatures.\n\nI wrote two examples, one for account creation, another for key\nroll-over to demonstrate nested JWS:\n\nhttps://github.com/joernheissler/acme/commit/a8a303ddbe3280b49ce8f10508dcdf95a6dc6de9\n\nThat commit also adds \"--- back\" (Backmatter to get Appendices in the\nrendered document) and I'm not happy with the wording on top.\n\nTo check correctness of the signatures and make the requests"}, "context_segments": []}, {"current_segment": {"sid": 6873, "labels": "Social,Social", "content": "Hi Thomas,\n"}, "context_segments": [{"sid": 4222, "labels": "ContextSetting,InformationProviding", "content": "Hello,\n\nI'm not sure if this should be included, so not making a PR yet.\n\nComplete examples for requests may help implementers (of both servers\nand clients) to understand the specifications. All existing examples\nhave pseudo-code like base64url({...}) and no untruncated keys or\nsignatures.\n\nI wrote two examples, one for account creation, another for key\nroll-over to demonstrate nested JWS:\n\nhttps://github.com/joernheissler/acme/commit/a8a303ddbe3280b49ce8f10508dcdf95a6dc6de9\n\nThat commit also adds \"--- back\" (Backmatter to get Appendices in the\nrendered document) and I'm not happy with the wording on top.\n\nTo check correctness of the signatures and make the requests"}]}, {"current_segment": {"sid": 4223, "labels": "Question,Question,InformationProviding,InformationSeeking", "content": "\nhttps://gist.github.com/joernheissler/04d9dcfb3a99e318871e451c9043f2dc\n\nDo you think those examples should be included? And if so, is there any\ntime left to actually do it?\n"}, "context_segments": []}, {"current_segment": {"sid": 6874, "labels": "NeutralResponse,ContextSetting,StateDecision,InformationProviding", "content": ">Magnus:\n>I finally have found some time to respond to your email from Dec 16., albeit\n>briefly:\n>1. I have logged a bug (672160) against item 7 below."}, "context_segments": [{"sid": 4223, "labels": "Question,Question,InformationProviding,InformationSeeking", "content": "\nhttps://gist.github.com/joernheissler/04d9dcfb3a99e318871e451c9043f2dc\n\nDo you think those examples should be included? And if so, is there any\ntime left to actually do it?\n"}]}, {"current_segment": {"sid": 4224, "labels": "Answer,ProposeAction,InformationProviding,Answer,ProposeAction", "content": "Hey Joern,\n\nThis is a probably a good thing to have.  I think that rather than putting\nthese in the main spec, it might be better to have them in a second draft.\nThis is a pretty common pattern.  For example, for TLS 1.3, there's a \"test\nvectors\" document separate from the main spec [0].  There are a few\ndocuments with example \"call flows\" for SIP [1][2].  ACME is probably\nsomewhere in the middle of those two cases.\n\n--Richard\n\n[0] https://tools.ietf.org/html/draft-ietf-tls-tls13-vectors-03\n[1] https://tools.ietf.org/html/rfc3665\n[2] https://tools.ietf.org/html/rfc5589\n"}, "context_segments": []}, {"current_segment": {"sid": 6875, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,ProposeAction", "content": "\nI think that RTCP reporting from client to server shall be supported as\ndefault even on a interleaved TCP channel, so this needs to be clarified.\n"}, "context_segments": [{"sid": 4224, "labels": "Answer,ProposeAction,InformationProviding,Answer,ProposeAction", "content": "Hey Joern,\n\nThis is a probably a good thing to have.  I think that rather than putting\nthese in the main spec, it might be better to have them in a second draft.\nThis is a pretty common pattern.  For example, for TLS 1.3, there's a \"test\nvectors\" document separate from the main spec [0].  There are a few\ndocuments with example \"call flows\" for SIP [1][2].  ACME is probably\nsomewhere in the middle of those two cases.\n\n--Richard\n\n[0] https://tools.ietf.org/html/draft-ietf-tls-tls13-vectors-03\n[1] https://tools.ietf.org/html/rfc3665\n[2] https://tools.ietf.org/html/rfc5589\n"}]}, {"current_segment": {"sid": 4225, "labels": "Agreement,Agreement,ProposeAction,InformationProviding", "content": "I agree; the test vectors are a good idea, and should be part of another\ndocument."}, "context_segments": [{"sid": 4224, "labels": "Answer,ProposeAction,InformationProviding,Answer,ProposeAction", "content": "Hey Joern,\n\nThis is a probably a good thing to have.  I think that rather than putting\nthese in the main spec, it might be better to have them in a second draft.\nThis is a pretty common pattern.  For example, for TLS 1.3, there's a \"test\nvectors\" document separate from the main spec [0].  There are a few\ndocuments with example \"call flows\" for SIP [1][2].  ACME is probably\nsomewhere in the middle of those two cases.\n\n--Richard\n\n[0] https://tools.ietf.org/html/draft-ietf-tls-tls13-vectors-03\n[1] https://tools.ietf.org/html/rfc3665\n[2] https://tools.ietf.org/html/rfc5589\n"}, {"sid": 6875, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,ProposeAction", "content": "\nI think that RTCP reporting from client to server shall be supported as\ndefault even on a interleaved TCP channel, so this needs to be clarified.\n"}]}, {"current_segment": {"sid": 6876, "labels": "Question,ContextSetting,InformationSeeking,InformationProviding", "content": ">3. Regarding item 17 below (about Server sending TEARDOWN to Client\n>and also optionally END_OF_STREAM),  are you in favor of our proposals\n>(meaning\n>allowing TEARDOWN on S->C and also add END_OF_STREAM?"}, "context_segments": []}, {"current_segment": {"sid": 6877, "labels": "InformationSeeking,InformationProviding,Answer,ContextSetting,ProposeAction,Social,InformationProviding,ProposeAction", "content": "I think we should do our best to keep a consistent usage of the methods\nand also avoid multiple ways of doing the same. In this case I think\nusing REDIRECT would be the preferred way, although an address is\nmissing to where to redirect to. This seems just to be a special case of\nREDIRECT that  needs to be explained.\n\nRegarding END_OF_STREAM, I think such a protocol extension can be added\nand also be quite useful. I would envisage a that it would simple be\nsent to report the last packet in a stream for the current playing\ncontext. Similar to what RTP-Info does at stream start.\n\nIf you would like such functionality please write a draft on it that\nworks as an extension to RTSP.\n"}, "context_segments": []}, {"current_segment": {"sid": 6878, "labels": "StateDecision,Social,InformationProviding", "content": ">We will send you more comments/additions once we have come up with draft\n>text for other issues (e.g., items 1 and 18 below).\n>See you tomorrow on the telecom."}, "context_segments": []}, {"current_segment": {"sid": 6879, "labels": "InformationProviding,ContextSetting", "content": ">2. There was only one typo re item 14 below (and you said you found it)."}, "context_segments": []}, {"current_segment": {"sid": 6880, "labels": "NeutralResponse,InformationProviding", "content": "\nGood,\n"}, "context_segments": []}, {"current_segment": {"sid": 6881, "labels": "NeutralResponse,InformationProviding", "content": "Ok."}, "context_segments": []}, {"current_segment": {"sid": 5498, "labels": "InformationProviding", "content": "\nThe Real Time Streaming Protocol, or RTSP, is an application-level\nprotocol for control over the delivery of data with real-time\nproperties.  RTSP provides an extensible framework to enable\ncontrolled, on-demand delivery of real-time data, such as audio and\nvideo.  Sources of data can include both live data feeds and stored\nclips.  This protocol is intended to control multiple data delivery\nsessions, provide a means for choosing delivery channels such as UDP,\nmulticast UDP and TCP, and provide a means for choosing delivery\nmechanisms based upon RTP (RFC 3550)."}, "context_segments": []}, {"current_segment": {"sid": 7948, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "CFRG IRTF Research Group met on Monday. Short status of RG documents was\npresented, the most important being:"}, "context_segments": [{"sid": 5498, "labels": "InformationProviding", "content": "\nThe Real Time Streaming Protocol, or RTSP, is an application-level\nprotocol for control over the delivery of data with real-time\nproperties.  RTSP provides an extensible framework to enable\ncontrolled, on-demand delivery of real-time data, such as audio and\nvideo.  Sources of data can include both live data feeds and stored\nclips.  This protocol is intended to control multiple data delivery\nsessions, provide a means for choosing delivery channels such as UDP,\nmulticast UDP and TCP, and provide a means for choosing delivery\nmechanisms based upon RTP (RFC 3550)."}]}, {"current_segment": {"sid": 5499, "labels": "InformationProviding", "content": "\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-mmusic-rfc2326bis-15.txt"}, "context_segments": []}, {"current_segment": {"sid": 7949, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n1) Elliptic Curves for Security (draft-irtf-cfrg-curves-11) is in RFC\nEditor's queue."}, "context_segments": [{"sid": 5499, "labels": "InformationProviding", "content": "\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-mmusic-rfc2326bis-15.txt"}]}, {"current_segment": {"sid": 5500, "labels": "InformationProviding,ProposeAction", "content": "\nTo remove yourself from the I-D Announcement list, send a message to\ni-d-announce-request@ietf.org with the word unsubscribe in the body of\nthe message.\nYou can also visit https://www1.ietf.org/mailman/listinfo/I-D-announce\nto change your subscription settings."}, "context_segments": []}, {"current_segment": {"sid": 7950, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n2) Edwards-curve Digital Signature Algorithm (draft-irtf-cfrg-eddsa-00)\nneeds to specify KDF and pre-hash functions for ed448, but otherwise it\nis heading in the right direction. Definition of ed25519 is stable at\nthis point."}, "context_segments": [{"sid": 5500, "labels": "InformationProviding,ProposeAction", "content": "\nTo remove yourself from the I-D Announcement list, send a message to\ni-d-announce-request@ietf.org with the word unsubscribe in the body of\nthe message.\nYou can also visit https://www1.ietf.org/mailman/listinfo/I-D-announce\nto change your subscription settings."}]}, {"current_segment": {"sid": 5501, "labels": "InformationProviding,ProposeAction", "content": "\nInternet-Drafts are also available by anonymous FTP. Login with the\nusername \"anonymous\" and a password of your e-mail address. After\nlogging in, type \"cd internet-drafts\" and then\n\"get draft-ietf-mmusic-rfc2326bis-15.txt\"."}, "context_segments": []}, {"current_segment": {"sid": 7951, "labels": "InformationProviding,InformationProviding", "content": "\nThere was one presentation on \"FSU: Identity-based Authenticated Key\nExchange\"."}, "context_segments": [{"sid": 5501, "labels": "InformationProviding,ProposeAction", "content": "\nInternet-Drafts are also available by anonymous FTP. Login with the\nusername \"anonymous\" and a password of your e-mail address. After\nlogging in, type \"cd internet-drafts\" and then\n\"get draft-ietf-mmusic-rfc2326bis-15.txt\"."}]}, {"current_segment": {"sid": 5502, "labels": "InformationProviding", "content": "\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html\nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt"}, "context_segments": []}, {"current_segment": {"sid": 7952, "labels": "InformationProviding,InformationProviding", "content": "\nThe rest of the meeting was spent discussing which topics CFRG should\nwork on next after finishing currently outstanding EC work."}, "context_segments": [{"sid": 5502, "labels": "InformationProviding", "content": "\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html\nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt"}]}, {"current_segment": {"sid": 5503, "labels": "InformationProviding", "content": "\nInternet-Drafts can also be obtained by e-mail."}, "context_segments": []}, {"current_segment": {"sid": 7953, "labels": "InformationProviding,InformationProviding", "content": "\nWe finished 30 minutes early."}, "context_segments": [{"sid": 5503, "labels": "InformationProviding", "content": "\nInternet-Drafts can also be obtained by e-mail."}]}, {"current_segment": {"sid": 5504, "labels": "InformationProviding,ProposeAction", "content": "\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-mmusic-rfc2326bis-15.txt\"."}, "context_segments": []}, {"current_segment": {"sid": 5505, "labels": "InformationProviding,ProposeAction", "content": "\nNOTE:\tThe mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages."}, "context_segments": []}, {"current_segment": {"sid": 5506, "labels": "InformationProviding", "content": "\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft."}, "context_segments": []}, {"current_segment": {"sid": 5507, "labels": "InformationProviding", "content": "A New Internet-Draft is available from the on-line Internet-Drafts\ndirectories.\nThis draft is a work item of the Multiparty Multimedia Session Control Working Group of the IETF."}, "context_segments": []}, {"current_segment": {"sid": 5508, "labels": "InformationProviding", "content": "\nTitle\t\t: Real Time Streaming Protocol 2.0 (RTSP)\nAuthor(s)\t: H. Schulzrinne, et al.\nFilename\t: draft-ietf-mmusic-rfc2326bis-15.txt\nPages\t\t: 215\nDate\t\t: 2007-6-26"}, "context_segments": []}, {"current_segment": {"sid": 5509, "labels": "InformationProviding", "content": "\nThis memorandum defines RTSP version 2.0 which is a revision of the\nProposed Standard RTSP version 1.0 which is defined in RFC 2326."}, "context_segments": []}, {"current_segment": {"sid": 1092, "labels": "Social", "content": "Hi,"}, "context_segments": []}, {"current_segment": {"sid": 5510, "labels": "InformationProviding", "content": "Jonathan,\n"}, "context_segments": [{"sid": 1092, "labels": "Social", "content": "Hi,"}]}, {"current_segment": {"sid": 1093, "labels": "Social", "content": "Hi,\n"}, "context_segments": []}, {"current_segment": {"sid": 5511, "labels": "InformationProviding", "content": "Jonathan Rosenberg wrote:\n> Ah, yet another case of deviation between RTSP and SIP, all for no\n> reason. Grr."}, "context_segments": [{"sid": 1093, "labels": "Social", "content": "Hi,\n"}]}, {"current_segment": {"sid": 1094, "labels": "InformationProviding,InformationProviding,ContextSetting,Apologising,Social", "content": "\nI am new to rtcweb so pl excuse my lack of knowledge."}, "context_segments": []}, {"current_segment": {"sid": 5512, "labels": "Agreement,ContextSetting,InformationProviding,Agreement", "content": "\nYes, that's exactly what I thought yesterday when I discovered it:\nGrrrr!\n"}, "context_segments": [{"sid": 1094, "labels": "InformationProviding,InformationProviding,ContextSetting,Apologising,Social", "content": "\nI am new to rtcweb so pl excuse my lack of knowledge."}]}, {"current_segment": {"sid": 1095, "labels": "ExtensionOfPrevious,InformationProviding,ContextSetting", "content": "\n1)  Refer\nF33     The browser must be able to initiate and\naccept a media session where the data needed\nfor establishment can be carried in SIP."}, "context_segments": []}, {"current_segment": {"sid": 5513, "labels": "ClarificationElicitation,InformationSeeking", "content": "> So, are you saying you propose that we adopt a new PING method for doing\n> this in SIP?"}, "context_segments": [{"sid": 1095, "labels": "ExtensionOfPrevious,InformationProviding,ContextSetting", "content": "\n1)  Refer\nF33     The browser must be able to initiate and\naccept a media session where the data needed\nfor establishment can be carried in SIP."}]}, {"current_segment": {"sid": 1096, "labels": "ExtensionOfPrevious,Question,InformationSeeking,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nIn other places in other documents it is stated that browser is\ngiven freedom to do signaling it likes. Then this requirement will\nbe met with signaling gateway. And there is no work in progress for\nthat. Whether IETF mandates for browser to understand SIP or not?"}, "context_segments": []}, {"current_segment": {"sid": 5514, "labels": "InformationProviding,Answer,ContextSetting,ProposeAction,InformationProviding,Answer,ProposeAction", "content": "\nSince the entities involved in session timer have to support session\ntimer, it would be alright to use a new method which would be specific\nto this extension. PING would be a good choice.\n\nIn any event, I believe that having RTSP and SIP aligned on this issue\nis a good thing.\n\nFYI: this is the definition of the PING method in RTSP:\n\n10.12 PING\n\nThis method is a bi-directional mechanism for server or client live-\nness checking. It has no side effects. The issuer of the request MUST\ninclude a session header with the session ID of the session that is\nbeing checked for liveness.\n\nhttp://www.ietf.org/internet-drafts/draft-ietf-mmusic-rfc2326bis-02.txt\n"}, "context_segments": [{"sid": 1096, "labels": "ExtensionOfPrevious,Question,InformationSeeking,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nIn other places in other documents it is stated that browser is\ngiven freedom to do signaling it likes. Then this requirement will\nbe met with signaling gateway. And there is no work in progress for\nthat. Whether IETF mandates for browser to understand SIP or not?"}]}, {"current_segment": {"sid": 1097, "labels": "Answer,InformationProviding,Answer", "content": "\nNot.\n\nIETF does mandate the browser to understand SDP, though (as part of JSEP).\n"}, "context_segments": [{"sid": 1096, "labels": "ExtensionOfPrevious,Question,InformationSeeking,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nIn other places in other documents it is stated that browser is\ngiven freedom to do signaling it likes. Then this requirement will\nbe met with signaling gateway. And there is no work in progress for\nthat. Whether IETF mandates for browser to understand SIP or not?"}, {"sid": 5514, "labels": "InformationProviding,Answer,ContextSetting,ProposeAction,InformationProviding,Answer,ProposeAction", "content": "\nSince the entities involved in session timer have to support session\ntimer, it would be alright to use a new method which would be specific\nto this extension. PING would be a good choice.\n\nIn any event, I believe that having RTSP and SIP aligned on this issue\nis a good thing.\n\nFYI: this is the definition of the PING method in RTSP:\n\n10.12 PING\n\nThis method is a bi-directional mechanism for server or client live-\nness checking. It has no side effects. The issuer of the request MUST\ninclude a session header with the session ID of the session that is\nbeing checked for liveness.\n\nhttp://www.ietf.org/internet-drafts/draft-ietf-mmusic-rfc2326bis-02.txt\n"}]}, {"current_segment": {"sid": 1098, "labels": "ExtensionOfPrevious,InformationProviding,ContextSetting,ProposeAction", "content": "\n2) It will be better if 1-800-Go-Fedex (Fedex call) is referred as\nIVR call and Fedex should be taken out as SKYPE was taken out."}, "context_segments": []}, {"current_segment": {"sid": 1099, "labels": "Question,Question,InformationProviding,InformationSeeking", "content": "\nWhich version did you look at? Skype has been removed from the latest version (-14). Fedex is still there, though.\n"}, "context_segments": [{"sid": 1098, "labels": "ExtensionOfPrevious,InformationProviding,ContextSetting,ProposeAction", "content": "\n2) It will be better if 1-800-Go-Fedex (Fedex call) is referred as\nIVR call and Fedex should be taken out as SKYPE was taken out."}]}, {"current_segment": {"sid": 1100, "labels": "Thanking,Social", "content": "\nThanks\nSamir"}, "context_segments": []}, {"current_segment": {"sid": 1290, "labels": "InformationProviding", "content": "FYI - We submitted this draft today it relates to the requirements in the use case draft for rtcweb to work in the presence of firewalls and http proxies etc."}, "context_segments": []}, {"current_segment": {"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, "context_segments": []}, {"current_segment": {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}]}, {"current_segment": {"sid": 1293, "labels": "NeutralResponse,InformationProviding", "content": "\nI am also pessimistic on PCP being deployed and would rather not\nconfuse the WebRTC community into thinking PCP is requirement for\nWebRTC.  I believe TURN is much better solution.  As mobile network\noperator, i feel much more comfortable offering TURN as a solution to\ncustomers than PCP.\n\nCB\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}]}, {"current_segment": {"sid": 1294, "labels": "NeutralResponse,InformationProviding", "content": "\nNot to contradict with your point, but to pile on it...\nEven if 100% of the Firewalls were to support PCP, you'd still want to do STUN/TURN/ICE methinks, because\n\n1) you never know that your local Firewall is the *only* Firewall-ish thing between you and the public Internet or some network reachable by both parties.  This problem already happens with UPnP and NAT-PMP today, and has been noted before in BEHAVE or MMUSIC, I think.\n\n2) There's a big difference between 100% of Firewalls implementing PCP, and it being actually enabled/turned-on in 100% of them.\n\n3) you don't know if the IP path across the Internet works for a given address family - this has been given as the reason STUN/ICE needs to be required for v4/v6 dual-stack implementations, to test reachability across the IPv6 Internet before trying to use it; regardless of NATs/Firewalls.\n\n-hadriel"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}]}, {"current_segment": {"sid": 1295, "labels": "NeutralResponse,InformationProviding", "content": "\nI'm sure STUN and TURN servers are not universally deployed ('100%') in\nISP networks either.\n\nBut I'm not proposing dropping STUN/TURN in lieu of PCP, but using PCP as\nan additional technique. Maybe you misunderstood what I was proposing.\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}]}, {"current_segment": {"sid": 1296, "labels": "NeutralResponse,InformationProviding", "content": "\nIt is not required for an ISP to deploy a TURN server the webrtc TURN server is much more likely to be deployed by the web application provider which will instruct the browser to use it when accessing its service.\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}, {"sid": 1295, "labels": "NeutralResponse,InformationProviding", "content": "\nI'm sure STUN and TURN servers are not universally deployed ('100%') in\nISP networks either.\n\nBut I'm not proposing dropping STUN/TURN in lieu of PCP, but using PCP as\nan additional technique. Maybe you misunderstood what I was proposing.\n"}]}, {"current_segment": {"sid": 1297, "labels": "NeutralResponse,InformationProviding", "content": "\nThe line between Application providers and ISPs is very blurry today.\nApplication provider can be over the top or it can be the ISP itself.\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}, {"sid": 1295, "labels": "NeutralResponse,InformationProviding", "content": "\nI'm sure STUN and TURN servers are not universally deployed ('100%') in\nISP networks either.\n\nBut I'm not proposing dropping STUN/TURN in lieu of PCP, but using PCP as\nan additional technique. Maybe you misunderstood what I was proposing.\n"}, {"sid": 1296, "labels": "NeutralResponse,InformationProviding", "content": "\nIt is not required for an ISP to deploy a TURN server the webrtc TURN server is much more likely to be deployed by the web application provider which will instruct the browser to use it when accessing its service.\n"}]}, {"current_segment": {"sid": 1298, "labels": "NeutralResponse,InformationProviding", "content": "\nUnderstood but would need to understand what the benefits of doing so would be.\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}, {"sid": 1295, "labels": "NeutralResponse,InformationProviding", "content": "\nI'm sure STUN and TURN servers are not universally deployed ('100%') in\nISP networks either.\n\nBut I'm not proposing dropping STUN/TURN in lieu of PCP, but using PCP as\nan additional technique. Maybe you misunderstood what I was proposing.\n"}]}, {"current_segment": {"sid": 1299, "labels": "Agreement,InformationProviding", "content": "\nYes, certainly.\n\nA protocol that allows a host to explicit control FW/NAT mappings/pinholes\n(both for incoming and outgoing connections IPv4/IPv6), including\nlifetime, knowing when such device restart/reboot, is more deterministic.\nClient is always free to use STUN/TURN.\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}, {"sid": 1295, "labels": "NeutralResponse,InformationProviding", "content": "\nI'm sure STUN and TURN servers are not universally deployed ('100%') in\nISP networks either.\n\nBut I'm not proposing dropping STUN/TURN in lieu of PCP, but using PCP as\nan additional technique. Maybe you misunderstood what I was proposing.\n"}, {"sid": 1298, "labels": "NeutralResponse,InformationProviding", "content": "\nUnderstood but would need to understand what the benefits of doing so would be.\n"}]}, {"current_segment": {"sid": 1300, "labels": "NeutralResponse,InformationProviding", "content": "\nSTUN and TURN don't require any support from ISPs. Both protocols are used today.\nYour co-worker Jonathan Rosenberg worked on these mechanisms and Cisco also supports them ;-)\n\nCiao"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}, {"sid": 1295, "labels": "NeutralResponse,InformationProviding", "content": "\nI'm sure STUN and TURN servers are not universally deployed ('100%') in\nISP networks either.\n\nBut I'm not proposing dropping STUN/TURN in lieu of PCP, but using PCP as\nan additional technique. Maybe you misunderstood what I was proposing.\n"}]}, {"current_segment": {"sid": 1301, "labels": "Question,InformationSeeking", "content": "\nIf ISPs want to provide RTCweb like services don't they need STUN and TURN\nServers so that ICE can gather candidates?\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}, {"sid": 1295, "labels": "NeutralResponse,InformationProviding", "content": "\nI'm sure STUN and TURN servers are not universally deployed ('100%') in\nISP networks either.\n\nBut I'm not proposing dropping STUN/TURN in lieu of PCP, but using PCP as\nan additional technique. Maybe you misunderstood what I was proposing.\n"}, {"sid": 1300, "labels": "NeutralResponse,InformationProviding", "content": "\nSTUN and TURN don't require any support from ISPs. Both protocols are used today.\nYour co-worker Jonathan Rosenberg worked on these mechanisms and Cisco also supports them ;-)\n\nCiao"}]}, {"current_segment": {"sid": 1306, "labels": "NeutralResponse,InformationProviding", "content": "\nYes, today. But that did not stop design decisions to include these\nprotocols in ICE at a they time were not deployed at all.\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}, {"sid": 1295, "labels": "NeutralResponse,InformationProviding", "content": "\nI'm sure STUN and TURN servers are not universally deployed ('100%') in\nISP networks either.\n\nBut I'm not proposing dropping STUN/TURN in lieu of PCP, but using PCP as\nan additional technique. Maybe you misunderstood what I was proposing.\n"}, {"sid": 1300, "labels": "NeutralResponse,InformationProviding", "content": "\nSTUN and TURN don't require any support from ISPs. Both protocols are used today.\nYour co-worker Jonathan Rosenberg worked on these mechanisms and Cisco also supports them ;-)\n\nCiao"}]}, {"current_segment": {"sid": 1308, "labels": "Agreement,InformationProviding", "content": "\nCertainly.\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}, {"sid": 1295, "labels": "NeutralResponse,InformationProviding", "content": "\nI'm sure STUN and TURN servers are not universally deployed ('100%') in\nISP networks either.\n\nBut I'm not proposing dropping STUN/TURN in lieu of PCP, but using PCP as\nan additional technique. Maybe you misunderstood what I was proposing.\n"}, {"sid": 1300, "labels": "NeutralResponse,InformationProviding", "content": "\nSTUN and TURN don't require any support from ISPs. Both protocols are used today.\nYour co-worker Jonathan Rosenberg worked on these mechanisms and Cisco also supports them ;-)\n\nCiao"}]}, {"current_segment": {"sid": 1309, "labels": "NeutralResponse,InformationProviding", "content": "\nI believe it should be considered as a viable option now since it is a\nspecific protocol to control NATs/Firewalls and Flow-aware devices\nrequired Pv6 CPE requirements document, Broadband Forum and 3GPP specs.\n"}, "context_segments": [{"sid": 1291, "labels": "Question,InformationSeeking", "content": "\nWhy not use Port Control Protocol (PCP) to control Firewalls and NATs\nexplicitly?"}, {"sid": 1292, "labels": "Agreement,InformationProviding", "content": "We can switch to that as soon as 100% of firewalls support it - until\nthen, we have to be able to rely on other techniques.\n\nThat's the deployment problem in a nutshell... I don't understand how\nthe first firewall gets an advantage from having PCP, given that none of\nthe apps support it, and I don't understand how the first app gets an\nadvantage from having PCP, given that no firewalls support it.\n\nIf PCP succeeds despite my misgivings, we can certainly revisit the issue.\n"}]}, {"current_segment": {"sid": 1310, "labels": "Agreement,InformationProviding", "content": "Agree with you on e2e IPv6 would be ideal. PCP is well suited to control\nIPv6 firewalls and it is one of the main use-cases as part of IPV6 CPE\nrequirements RFC. Unless you think with IPv6 there will no IPv6 firewalls.\n"}, "context_segments": []}, {"current_segment": {"sid": 1311, "labels": "NeutralResponse,InformationProviding", "content": "\nThat is my plan. Ipv6 e2e ftw.\n\nCB\n"}, "context_segments": [{"sid": 1310, "labels": "Agreement,InformationProviding", "content": "Agree with you on e2e IPv6 would be ideal. PCP is well suited to control\nIPv6 firewalls and it is one of the main use-cases as part of IPV6 CPE\nrequirements RFC. Unless you think with IPv6 there will no IPv6 firewalls.\n"}]}, {"current_segment": {"sid": 1312, "labels": "NeutralResponse,InformationProviding", "content": "\nThat is my plan. Ipv6 e2e ftw.\n\n[TR] Even with IPv6, there is no guarantee that NPTv6 will not be deployed. So PCP/STUN is still required to gather server-reflexive candidates. Even without NPTv6, Firewalls would block UDP flows -  PCP would address that problem. TURN should be only used as last resort if all other techniques fail because it could result in media latency, single point of failure etc.\n\n--Tiru.\n\nCB\n"}, "context_segments": [{"sid": 1310, "labels": "Agreement,InformationProviding", "content": "Agree with you on e2e IPv6 would be ideal. PCP is well suited to control\nIPv6 firewalls and it is one of the main use-cases as part of IPV6 CPE\nrequirements RFC. Unless you think with IPv6 there will no IPv6 firewalls.\n"}]}, {"current_segment": {"sid": 1313, "labels": "NeutralResponse,InformationProviding", "content": "|It is not required for an ISP to deploy a TURN server the webrtc TURN server\n|is much more likely to be deployed by the web application provider which will\n|instruct the browser to use it when accessing its service."}, "context_segments": []}, {"current_segment": {"sid": 1314, "labels": "NeutralResponse,InformationProviding", "content": "\nRight, and the application provider could be also an enterprise hosting a TURN server for a number of reasons in addition to NAT/firewall traversal -- media anchoring, monitoring, recording etc. I think TURN servers aren't going away, especially with WebRTC where the session signaling protocol between the browser and the web server could be proprietary (and encrypted), making ALG techniques in NATs/Firewalls/SBCs fail miserably."}, "context_segments": []}, {"current_segment": {"sid": 1315, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nLook forward to feedback and hope that this can be considered for adoption by the working group."}, "context_segments": []}, {"current_segment": {"sid": 1316, "labels": "NeutralResponse,InformationProviding", "content": "\nICE/STUN/TURN and PCP are not really competitors or alternatives to each other."}, "context_segments": []}, {"current_segment": {"sid": 1317, "labels": "Agreement,InformationProviding", "content": "\nGood point. http://tools.ietf.org/html/rfc6544#section-5.3 explains to gather candidates also using PCP in addition to using STUN/TURN. ICE connectivity checks\nwill reveal if PCP Unaware NAT exists or not.\n"}, "context_segments": [{"sid": 1316, "labels": "NeutralResponse,InformationProviding", "content": "\nICE/STUN/TURN and PCP are not really competitors or alternatives to each other."}]}, {"current_segment": {"sid": 1318, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nA browser or any other client will anyway need to implement ICE/STUN/TURN to work its way through non-PCP supporting NATs, which will be the majority for a long time even if PCP became succesfull. The benefit of the ICE/STUN/TURN approach is that every organization or individual who deploys NATs or firewalls will not need to deploy STUN and TURN servers, but they can be deployed independently e.g. by the WebRTC service provider."}, "context_segments": []}, {"current_segment": {"sid": 1319, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nHowever, PCP, even gradually deployed, would still be useful as well. As Reinaldo is saying, it would improve robustness it produces explict NAT mappings with explicit durations. Also, it can serve as an alternative to STUN/TURN in case the browser happens to be behind a PCP-capable NAT/FW. So, PCP can be seen as an optimization and should be used when it is available. PCP can also help clients behind NAT/FW to reduce their keep-alive rate which is applicable to WebRTC as well. However, as depicted in [1], knowing when a client can entirely rely on PCP is not always so easy to detect."}, "context_segments": []}, {"current_segment": {"sid": 1320, "labels": "Answer,InformationProviding", "content": "http://datatracker.ietf.org/doc/draft-reddy-pcp-optimize-keepalives/?incl"}, "context_segments": [{"sid": 1319, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nHowever, PCP, even gradually deployed, would still be useful as well. As Reinaldo is saying, it would improve robustness it produces explict NAT mappings with explicit durations. Also, it can serve as an alternative to STUN/TURN in case the browser happens to be behind a PCP-capable NAT/FW. So, PCP can be seen as an optimization and should be used when it is available. PCP can also help clients behind NAT/FW to reduce their keep-alive rate which is applicable to WebRTC as well. However, as depicted in [1], knowing when a client can entirely rely on PCP is not always so easy to detect."}]}, {"current_segment": {"sid": 1321, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nI hope we will see PCP deployment especially in the mobile/cellular access, but as many people have pointed out, the success rate of this type of protocols has been quite low. So it will be a nice surprise rather than something I would count on if it happens."}, "context_segments": []}, {"current_segment": {"sid": 1322, "labels": "Agreement,NeutralResponse,InformationProviding", "content": "\nI absolutely agree with this summary about the usefulness and status of PCP.\n\nMy concern with RTCWEB at the moment is getting things out the door with\nall the features we really need to have, and as few additional features\nas possible.\n\nThat's why I don't want to add PCP into the mix at this time - once\nwe're finished with the basic stuff, we can discuss adding support for\nnew features at our leisure, but making the specs more complex than they\ncurrently are really should be done only when it's a really important\nfeature that needs adding.\n"}, "context_segments": [{"sid": 1321, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nI hope we will see PCP deployment especially in the mobile/cellular access, but as many people have pointed out, the success rate of this type of protocols has been quite low. So it will be a nice surprise rather than something I would count on if it happens."}]}, {"current_segment": {"sid": 1323, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\n[1] http://datatracker.ietf.org/doc/draft-reddy-pcp-optimize-keepalives/?include_text=1."}, "context_segments": []}, {"current_segment": {"sid": 1324, "labels": "NeutralResponse,InformationProviding", "content": "I meant an ISP provided service, not a \"hoping over the ISP\" scenario.\n"}, "context_segments": []}, {"current_segment": {"sid": 1325, "labels": "Agreement,InformationProviding", "content": "\nI also agree with Harald on his proposal that PCP would be considered later.\nIn addition, I like to add the following:"}, "context_segments": []}, {"current_segment": {"sid": 1326, "labels": "NeutralResponse,InformationProviding", "content": "\n1. Let PCP becomes an RFC.\n2. Let there be some use cases/call-flows (as a PCP call-flow IETF draft is\nthere) using PCP for FW/NAT crossing by RTCWEB, SIP (audio/video)\nconferencing, and related real-time applications."}, "context_segments": []}, {"current_segment": {"sid": 1327, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nOnce above two items are completed, a separate draft using PCP for FW/NAT\ncrossing by RTCWEB applications can be written as soon as possible including\nco-existing with ICE/STUN/TURN complementing each other capabilities."}, "context_segments": []}, {"current_segment": {"sid": 1328, "labels": "NeutralResponse,InformationProviding", "content": "I think another advantage of PCP is to reduce call setup time in RTCweb.\nIf a NAT/FW/Middlebox tells us that you have a mapping for 1 hour, during\nthat hour you can reuse that external IP:port across calls over and over,\nor least reuse as your prime ICE candidate.\n"}, "context_segments": []}, {"current_segment": {"sid": 4614, "labels": "Social", "content": "Folks,"}, "context_segments": []}, {"current_segment": {"sid": 4615, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious", "content": "\n- Remove point format negotiation."}, "context_segments": []}, {"current_segment": {"sid": 4616, "labels": "InformationSeeking,InformationProviding,ExtensionOfPrevious,ProposeAction,Thanking,ExtensionOfPrevious,Social", "content": "\nAnd of course a bunch of editorial changes. Thanks to all who sent in\ncomments and PRs. Comments welcome!"}, "context_segments": []}, {"current_segment": {"sid": 4617, "labels": "InformationProviding,ContextSetting,ContextSetting", "content": "\nI've just published draft-04\n(https://tools.ietf.org/html/draft-ietf-tls-tls13-04\n<https://tools.ietf.org/id/draft-ietf-tls-tls13-04>). This includes the\nfollowing\nchanges based on WG discussion."}, "context_segments": []}, {"current_segment": {"sid": 4618, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n- Modify key computations to include session hash."}, "context_segments": []}, {"current_segment": {"sid": 4619, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious", "content": "\n- Remove ChangeCipherSpec"}, "context_segments": []}, {"current_segment": {"sid": 4620, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious", "content": "\n- Renumber the new handshake messages to be somewhat more\nconsistent with existing convention and to remove a duplicate\nregistration."}, "context_segments": []}, {"current_segment": {"sid": 4621, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious", "content": "\n- Remove renegotiation."}, "context_segments": []}, {"current_segment": {"sid": 4622, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious", "content": "\n- Update format of signatures with context."}, "context_segments": []}, {"current_segment": {"sid": 1396, "labels": "Social", "content": "Hi,"}, "context_segments": []}, {"current_segment": {"sid": 8104, "labels": "InformationProviding,InformationProviding,Social", "content": "Dear CFRG participants,\nChairs would like to get Ed448 finished and send\ndraft-irtf-cfrg-eddsa to RFC Editor."}, "context_segments": [{"sid": 1396, "labels": "Social", "content": "Hi,"}]}, {"current_segment": {"sid": 1397, "labels": "InformationProviding,ContextSetting", "content": "\nIn the introduction of draft-ietf-rtcweb-rtp-usage-01, one example of\napplication is \"on-demand multimedia streaming\". The draft also recommends\ntools like RFC4588."}, "context_segments": []}, {"current_segment": {"sid": 8105, "labels": "InformationProviding,ProposeAction,InformationProviding", "content": "\nIn order to do that, we need to pick 1) pre-hashing algorithm and 2)\n912-bit internal hash function."}, "context_segments": [{"sid": 1397, "labels": "InformationProviding,ContextSetting", "content": "\nIn the introduction of draft-ietf-rtcweb-rtp-usage-01, one example of\napplication is \"on-demand multimedia streaming\". The draft also recommends\ntools like RFC4588."}]}, {"current_segment": {"sid": 1398, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nLooking at the charter and at the\ndraft-ietf-rtcweb-use-cases-and-requirements-06 (sections 4.2 and 4.3),\nthere is no explicit use-case about it. In other-words, there is no\nuse-case like a user/browser downloads a video file from another browser or\nserver.\nThe words \"real-time communication\" and \"communication\" look fuzzy, as it\nis not clear if mono-directional streaming is included or not in the scope\nof rtcweb communications."}, "context_segments": []}, {"current_segment": {"sid": 8106, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction,StateDecision", "content": "\nChairs would like to ask participants to submit their detailed\nimplementable proposals within 1 week (till November 29th). After that\nwe will have a Quaker poll to settle on one choice for each of the above\n(alternatively chairs can just pick something and ask for objections)."}, "context_segments": [{"sid": 1398, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nLooking at the charter and at the\ndraft-ietf-rtcweb-use-cases-and-requirements-06 (sections 4.2 and 4.3),\nthere is no explicit use-case about it. In other-words, there is no\nuse-case like a user/browser downloads a video file from another browser or\nserver.\nThe words \"real-time communication\" and \"communication\" look fuzzy, as it\nis not clear if mono-directional streaming is included or not in the scope\nof rtcweb communications."}]}, {"current_segment": {"sid": 1399, "labels": "Question,ExtensionOfPrevious,ContextSetting,InformationSeeking,InformationProviding", "content": "\nSo my question is : is the \"on-demand multimedia streaming\"\ncommunication use-case in the scope of the WG or not?"}, "context_segments": []}, {"current_segment": {"sid": 8107, "labels": "InformationProviding,ContextSetting,InformationProviding,NeutralResponse,ContextSetting", "content": "Here are two closely-related proposals for the pre-hashing and internal\nhashing scheme.  For discussion purposes let's call them \"twoshakes-s\"\nand \"twoshakes-d\".  Both are defined in clearly-demarked sections below."}, "context_segments": [{"sid": 1399, "labels": "Question,ExtensionOfPrevious,ContextSetting,InformationSeeking,InformationProviding", "content": "\nSo my question is : is the \"on-demand multimedia streaming\"\ncommunication use-case in the scope of the WG or not?"}]}, {"current_segment": {"sid": 8108, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ContextSetting", "content": "\n#1: twoshakes-s (\"s\" is for \"simple\"):"}, "context_segments": []}, {"current_segment": {"sid": 8109, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nThis scheme uses the SHAKE256 extensible-output functions (XOFs) to\nimplement both the internal hash and prehash. The internal hash uses the\nfirst 912 bits (114 octets) of the output produced by SHAKE256, whereas\nthe prehash uses the first 512 bits (64 octets) of SHAKE256-produced output."}, "context_segments": []}, {"current_segment": {"sid": 8110, "labels": "InformationProviding,InformationProviding", "content": "\nIn PureEdDSA, the prehash PH(M) is the identity function, PH(M)=M. In\nHashEdDSA, the prehash PH(M) is computed as SHAKE256(M, 512), where M is\nthe message to be hashed and the second parameter determines the number\nof bits of output the SHAKE256 XOR produces.  Note that this notation is\nconsistent with the two-parameter definition of SHAKE256 in section 6.3\nof FIPS 202."}, "context_segments": []}, {"current_segment": {"sid": 8111, "labels": "InformationProviding,InformationProviding", "content": "\nThe internal hash H(M) is similarly computed as SHAKE256(M, 912),\nyielding a 912-bit output.  (Note that the M here merely names the\ninternal hash's input parameter, not the message ultimately input to the\nEdDSA scheme.  In its usage by EdDSA this M will be substituted with\n'Prefix || M' or 'R || A || M' in the signing process.)"}, "context_segments": []}, {"current_segment": {"sid": 8112, "labels": "InformationProviding,ContextSetting", "content": "\nDesign justification:"}, "context_segments": []}, {"current_segment": {"sid": 8113, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nThe overall justification for using SHAKE256 for both internal hash and\nprehash, as discussed already on this list, is: (a) implementations need\nonly a single symmetric crypto primitive (Keccak) for both; and (b)\nSHAKE256 operates the underlying Keccak sponge function with a rate and\ncapacity designed to be appropriate for a 256-bit security level, and\nnot at an overly-conservative rate as she SHA3-* hashes do. This latter\nperformance consideration is important mainly for the prehash, since the\nprehash can be used to operate on long messages making its hashing\nthroughput potentially significant (and not necessarily always dominated\nby the cost of the public-key operations)."}, "context_segments": []}, {"current_segment": {"sid": 8114, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThis scheme has the advantage of simplicity and consistency with how the\nEd25519 signature scheme works, only dropping in SHAKE256 with\nappropriate output-size parameters in place of SHA-512.  I do not\nperceive any real security problem with using the same SHAKE256 XOF\n(with different output-size parameters) for the two hashes, because in\npractice part of the input M will always be different for the XOF's\ndifferent uses, yielding implicit domain-separation.  In particular:"}, "context_segments": []}, {"current_segment": {"sid": 8115, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\n- The secret per-message 'r' value gets computed using the internal hash\nas SHAKE256(prefix || M, 912), which depends on the secret and\ncryptographically unique 'prefix'."}, "context_segments": []}, {"current_segment": {"sid": 8116, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\n- The Schnorr challenge gets computed using the internal hash (again) as\nSHAKE256(R || A || M, 912), where R depends on r and in turn on the\nsecret prefix, and hence should be cryptographically unique and\nunpredictable to anyone not holding the private signing key."}, "context_segments": []}, {"current_segment": {"sid": 8117, "labels": "InformationProviding,InformationProviding", "content": "\nArgued another way, if there was a real problem with using SHAKE256 for\nboth the internal hash and prehash in Ed448, it seems the same problem\nwould probably exist with using SHA-512 for both the internal hash and\nprehash in Ed25519."}, "context_segments": []}, {"current_segment": {"sid": 8118, "labels": "InformationProviding,ContextSetting,ProposeAction,InformationProviding,ContextSetting,ProposeAction", "content": "\nStill, in case we would like to make the design a bit more conservative\nwith explicit domain separation, I suggest the following alternative scheme."}, "context_segments": []}, {"current_segment": {"sid": 8119, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\n#2: twoshakes-d (\"d\" is for \"domain-separated\"):"}, "context_segments": []}, {"current_segment": {"sid": 8120, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThis scheme again uses the SHAKE256 extensible-output functions (XOFs)\nto implement both hashes, with the inputs prefixed as specified below\nfor explicit domain separation purposes."}, "context_segments": []}, {"current_segment": {"sid": 8121, "labels": "InformationProviding,ContextSetting,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThe scheme accepts two optional, application-defined parameters for\ncustomization, but applications simply needing a generic signature\nscheme (and APIs offering no convenient way to specify optional\nparameters) can simply use the defaults as specified below:"}, "context_segments": []}, {"current_segment": {"sid": 8122, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\n- Prehash: 1-bit flag, default True\n- Context: octet string of length 0..255, default empty (0-octet)"}, "context_segments": []}, {"current_segment": {"sid": 8123, "labels": "InformationProviding,InformationProviding", "content": "\nIn PureEdDSA, the prehash PH(M) is the identity function, PH(M)=M.\nIn HashEdDSA, the prehash PH(M) is computed as SHAKE256(dom||M, 512),\nwhere dom is a domain separation prefix defined below with the Flags\noctet set to 0x02.  The 512 parameter means use the first 512 bits of\nSHAKE256 output as the hash prehash output."}, "context_segments": []}, {"current_segment": {"sid": 8124, "labels": "InformationProviding,InformationProviding", "content": "\nThe internal hash H(M) is computed as SHAKE256(dom||M, 912), where dom\nis defined below, with the Flags octet it contains set to 0x00 for\nPureEdDSA or to 0x01 for HashEdDSA.  The 912 again means use the first\n912 bits of SHAKE256 output as the internal hash output."}, "context_segments": []}, {"current_segment": {"sid": 8125, "labels": "InformationProviding,InformationProviding", "content": "\nThe domain separation prefix 'dom' in each case above consists of:\n- 8 octets: the ASCII characters \"SigEd448\"\n- 1 octet: Flags, as defined below\n- 1 octet: length of optional Context string, 0-255 (0 meaning empty)\n- 0-255 octets: Context string"}, "context_segments": []}, {"current_segment": {"sid": 8126, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "\nThe Flags octet is defined as follows:\n- Bit 0: Prehash parameter: 0 for PureEdDSA or 1 for HashEdDSA.\n- Bit 1: 0 for the internal hash, 1 for the prehash\n- Bits 2-7: reserved, MUST be zero"}, "context_segments": []}, {"current_segment": {"sid": 8127, "labels": "InformationProviding,ContextSetting", "content": "\nJustification for this design:"}, "context_segments": []}, {"current_segment": {"sid": 8128, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nThe 8-octet 'SigEd448' prefix provides (weak) explicit domain separation\nof EdDSA+Goldilocks's use of SHAKE256 from other independent uses of\nSHAKE256.  It is not by any means essential to the scheme's security but\nis included merely as a low-cost conservative precaution."}, "context_segments": []}, {"current_segment": {"sid": 8129, "labels": "InformationProviding,InformationProviding", "content": "\nThe optional Context parameter enables applications to distinguish\nsignatures intended for use in one context from signatures intended for\nanother.  In particular, if a signature S is generated with one context\nC1, i.e., S = Sign_C1(M), then any attempt to verify S in a different\ncontext C2 != C1 will fail, i.e., Verify_C2(M) = False.  A Context could\nsimply be a well-known application- or protocol-defined name, or a hash\nor random number to allow more fine-grained context separation.  The\ndocument defining how EdDSA is to be used in a given application or\nprotocol is expected to specify how the Context parameter is to be\ndetermined."}, "context_segments": []}, {"current_segment": {"sid": 8130, "labels": "InformationProviding,InformationProviding", "content": "\nThe Flags octet provides explicit domain separation between the three\nuses of SHAKE256 in EdDSA+Goldilocks: namely the prehash (flags=0x02),\nthe PureEdDSA internal hash (flags=0x00), or the HashEdDSA internal hash\n(flags=0x01)."}, "context_segments": []}, {"current_segment": {"sid": 8131, "labels": "InformationProviding,InformationProviding", "content": "\nAny or all of these domain separation provisions could of course be\ndropped without affecting the resulting signature scheme's security in\nany one use-case considered independently, but are included as a\nconservative security precaution that costs little in terms of either\nperformance or implementation complexity.  As such, I feel these\ndomain-separation provisions are useful but am also fine with dropping\nany of them if the balance of the WG feels they are not worth the\ntrouble.  (Or just go with twoshakes-s above.)"}, "context_segments": []}, {"current_segment": {"sid": 8132, "labels": "Social,Social", "content": "Hi Bryan,"}, "context_segments": []}, {"current_segment": {"sid": 8133, "labels": "InformationProviding,NeutralResponse,InformationProviding,NeutralResponse", "content": "\nI have a preference for your second proposal \"twoshakes-d\", for its\ndomain separation between PureEdDSA and HashEdDSA. This would have the\npractical advantage of allowing a single key to be used for both options\n(if certified as such), without input clashes at the internal hash level."}, "context_segments": []}, {"current_segment": {"sid": 8134, "labels": "Agreement,Agreement,InformationProviding", "content": "+1"}, "context_segments": []}, {"current_segment": {"sid": 1563, "labels": "InformationProviding,ProposeAction", "content": "I find it lost in rtcweb mailing list, so I forward it to pntaw list, I think the guys following this group will be interested in this change proposal. I do not like silence too and I hope the usecase and requirement could be published ASAP."}, "context_segments": []}, {"current_segment": {"sid": 5749, "labels": "Thanking,Thanking,Social", "content": "Thanks for the review.\n"}, "context_segments": [{"sid": 1563, "labels": "InformationProviding,ProposeAction", "content": "I find it lost in rtcweb mailing list, so I forward it to pntaw list, I think the guys following this group will be interested in this change proposal. I do not like silence too and I hope the usecase and requirement could be published ASAP."}]}, {"current_segment": {"sid": 1564, "labels": "InformationProviding,ProposeAction", "content": "\nThe change proposal is related to the discussion on pntaw. Also ,I hope the words could be more accurate and the requirement could be clearer."}, "context_segments": []}, {"current_segment": {"sid": 5750, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "The MMUSIC WG is currently doing an WG Last Call on RTSP 2.0. The WG\nlast call ends on May 16th, 2012."}, "context_segments": [{"sid": 1564, "labels": "InformationProviding,ProposeAction", "content": "\nThe change proposal is related to the discussion on pntaw. Also ,I hope the words could be more accurate and the requirement could be clearer."}]}, {"current_segment": {"sid": 1565, "labels": "Question,ProposeAction,InformationSeeking,InformationProviding", "content": "\nSo ,any ideas about it?"}, "context_segments": []}, {"current_segment": {"sid": 5751, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nhttps://datatracker.ietf.org/doc/draft-ietf-mmusic-rfc2326bis/"}, "context_segments": [{"sid": 1565, "labels": "Question,ProposeAction,InformationSeeking,InformationProviding", "content": "\nSo ,any ideas about it?"}]}, {"current_segment": {"sid": 1566, "labels": "Question,InformationSeeking", "content": "\nTo Magnus:\nWhat will happen if there is no response?"}, "context_segments": []}, {"current_segment": {"sid": 5752, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nThis document includes the definition (Appendix F) and registration of\nthe text/parameters format."}, "context_segments": [{"sid": 1566, "labels": "Question,InformationSeeking", "content": "\nTo Magnus:\nWhat will happen if there is no response?"}]}, {"current_segment": {"sid": 5753, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\n22.16.  Media Type Registration for text/parameters"}, "context_segments": []}, {"current_segment": {"sid": 5754, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nType name:  text"}, "context_segments": []}, {"current_segment": {"sid": 5755, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nSubtype name:  parameters"}, "context_segments": []}, {"current_segment": {"sid": 5756, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nRequired parameters:"}, "context_segments": []}, {"current_segment": {"sid": 5757, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nOptional parameters:"}, "context_segments": []}, {"current_segment": {"sid": 5758, "labels": "InformationProviding,ProposeAction,InformationProviding,ContextSetting,ProposeAction", "content": "\nWell, text types usually have a 'charset' parameter, and applications\nare known to treat, say, a HTTP response with\n\nContent-Type: text/parameters;charset=iso-8859-1\n\nAs ISO-8859-1 encoded document, even though I gather they are to use\nUTF-8 to decode the document. If you don't want a 'charset' parameter,\nthis problem should be noted in the Security or Interoperability con-\nsiderations.\n"}, "context_segments": [{"sid": 5757, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nOptional parameters:"}]}, {"current_segment": {"sid": 5759, "labels": "InformationProviding,Agreement,InformationProviding,Agreement,ProposeAction", "content": "\nYes, you are correct. I guess having the charset being applicable to the\nvalues of the parameters would be very reasonable. The parameters\nthemselves are in this format restricted to visible 7-bit US-ASCII\ncharacters.\n"}, "context_segments": [{"sid": 5757, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nOptional parameters:"}, {"sid": 5758, "labels": "InformationProviding,ProposeAction,InformationProviding,ContextSetting,ProposeAction", "content": "\nWell, text types usually have a 'charset' parameter, and applications\nare known to treat, say, a HTTP response with\n\nContent-Type: text/parameters;charset=iso-8859-1\n\nAs ISO-8859-1 encoded document, even though I gather they are to use\nUTF-8 to decode the document. If you don't want a 'charset' parameter,\nthis problem should be noted in the Security or Interoperability con-\nsiderations.\n"}]}, {"current_segment": {"sid": 5760, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nEncoding considerations:"}, "context_segments": []}, {"current_segment": {"sid": 5761, "labels": "InformationProviding,InformationProviding,ProposeAction", "content": "\nThis field needs a value (probably \"8bit\" or \"binary\").\nBj\u00f6rn H\u00f6hrmann \u00b7 mailto:bjoern@hoehrmann.de \u00b7 http://bjoern.hoehrmann.de\nAm Badedeich 7 \u00b7 Telefon: +49(0)160/4415681 \u00b7 http://www.bjoernsworld.de\n25899 Dageb\u00fcll \u00b7 PGP Pub. KeyID: 0xA4357E78 \u00b7 http://www.websitedev.de/"}, "context_segments": [{"sid": 5760, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nEncoding considerations:"}]}, {"current_segment": {"sid": 5762, "labels": "InformationProviding,NeutralResponse,InformationProviding,NeutralResponse", "content": "\nThat would be 8bit if I interpret that definition correctly. This will\nonly contain UTF8 text.\n"}, "context_segments": [{"sid": 5760, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nEncoding considerations:"}, {"sid": 5761, "labels": "InformationProviding,InformationProviding,ProposeAction", "content": "\nThis field needs a value (probably \"8bit\" or \"binary\").\nBj\u00f6rn H\u00f6hrmann \u00b7 mailto:bjoern@hoehrmann.de \u00b7 http://bjoern.hoehrmann.de\nAm Badedeich 7 \u00b7 Telefon: +49(0)160/4415681 \u00b7 http://www.bjoernsworld.de\n25899 Dageb\u00fcll \u00b7 PGP Pub. KeyID: 0xA4357E78 \u00b7 http://www.websitedev.de/"}]}, {"current_segment": {"sid": 5763, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nSecurity considerations:  This format may carry any type of\nparameters.  Some can have security requirements, like privacy,\nconfidentiality or integrity requirements.  The format has no\nbuilt in security protection.  For the usage it was defined the\ntransport can be protected between server and client using TLS.\nHowever, care must be take to consider if also the proxies are\ntrusted with the parameters in case hop-by-hop security is used.\nIf stored as file in file system the necessary precautions needs\nto be taken in relation to the parameters requirements including\nobject security such as S/MIME [RFC5751]."}, "context_segments": []}, {"current_segment": {"sid": 5764, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nInteroperability considerations:  This media type was mentioned as a\nfictional example in RFC 2326 but was not formally specified.\nThis has resulted in usage of this media type which may not match\nits formal definition."}, "context_segments": []}, {"current_segment": {"sid": 5765, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nPublished specification:  RFC XXXX, Appendix F."}, "context_segments": []}, {"current_segment": {"sid": 5766, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nApplications that use this media type:  Applications that use RTSP\nand have additional parameters they like to read and set using the\nRTSP GET_PARAMETER and SET_PARAMETER methods."}, "context_segments": []}, {"current_segment": {"sid": 5767, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nAdditional information:"}, "context_segments": []}, {"current_segment": {"sid": 5768, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nMagic number(s):"}, "context_segments": []}, {"current_segment": {"sid": 5769, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nFile extension(s):"}, "context_segments": []}, {"current_segment": {"sid": 5770, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nMacintosh file type code(s):"}, "context_segments": []}, {"current_segment": {"sid": 5771, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nPerson & email address to contact for further information:  Magnus\nWesterlund (magnus.westerlund@ericsson.com)"}, "context_segments": []}, {"current_segment": {"sid": 5772, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nIntended usage:   Common"}, "context_segments": []}, {"current_segment": {"sid": 5773, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nRestrictions on usage:   None"}, "context_segments": []}, {"current_segment": {"sid": 5019, "labels": "ContextSetting,InformationProviding", "content": "(fixing missed ietf@ietf.org)\n"}, "context_segments": []}, {"current_segment": {"sid": 7007, "labels": "Social,Social", "content": "Hello,"}, "context_segments": [{"sid": 5019, "labels": "ContextSetting,InformationProviding", "content": "(fixing missed ietf@ietf.org)\n"}]}, {"current_segment": {"sid": 5020, "labels": "InformationProviding,ContextSetting", "content": "On Friday, 16 February 2018 18:06:41 CET The IESG wrote:\n> The IESG has received a request from the Transport Layer Security WG (tls)\n> to consider the following document: - 'The Transport Layer Security (TLS)\n> Protocol Version 1.3'\n>   <draft-ietf-tls-tls13-24.txt> as Proposed Standard"}, "context_segments": []}, {"current_segment": {"sid": 7008, "labels": "InformationSeeking,ContextSetting,Question,InformationProviding", "content": "\nI am currently working on an RTSP/RTP implementation,\nand I wonder what a streaming server is meant to do\nwith RTP timestamps after an RTSP PAUSE followed\n(after a few seconds, for example), by a PLAY."}, "context_segments": [{"sid": 5020, "labels": "InformationProviding,ContextSetting", "content": "On Friday, 16 February 2018 18:06:41 CET The IESG wrote:\n> The IESG has received a request from the Transport Layer Security WG (tls)\n> to consider the following document: - 'The Transport Layer Security (TLS)\n> Protocol Version 1.3'\n>   <draft-ietf-tls-tls13-24.txt> as Proposed Standard"}]}, {"current_segment": {"sid": 5021, "labels": "Question,ContextSetting,InformationProviding,ContextSetting,ProposeAction,InformationSeeking", "content": "\nThe current draft states that if the server recognises an identity but is\nunable to verify corresponding binder, it \"MUST abort the handshake\"\nat the same time, they \"SHOULD select as single PSK and validate solely the\nbinder that corresponds to that PSK\"\n(Page 60, draft-ietf-tls-tls13-24).\n\nThat allows for trivial enumeration of externally established identities - the\nattacker just needs to send to the server a list of identity guesses, with\nrandom data as binders, if the server recognises any identity it will abort\nconnection, if it doesn't, it will continue to a non-PSK handshake.\n\nBehaviour like this is generally considered a vulnerability:\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0190\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5229\n\nI was wondering if the document shouldn't recommend ignoring any and all\nidentities for which binders do not verify to prevent this kind of attack.\n"}, "context_segments": []}, {"current_segment": {"sid": 7009, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,InformationProviding,ExtensionOfPrevious", "content": "\nThere are 2 possibilities for the first RTP packet\nafter the PLAY:\n- Its timestamp is the last RTP packet's timestamp +\nduration of the last RTP packet\n- Or: the previous value + duration in \"real time\"\nbetween PAUSE and PLAY"}, "context_segments": [{"sid": 5021, "labels": "Question,ContextSetting,InformationProviding,ContextSetting,ProposeAction,InformationSeeking", "content": "\nThe current draft states that if the server recognises an identity but is\nunable to verify corresponding binder, it \"MUST abort the handshake\"\nat the same time, they \"SHOULD select as single PSK and validate solely the\nbinder that corresponds to that PSK\"\n(Page 60, draft-ietf-tls-tls13-24).\n\nThat allows for trivial enumeration of externally established identities - the\nattacker just needs to send to the server a list of identity guesses, with\nrandom data as binders, if the server recognises any identity it will abort\nconnection, if it doesn't, it will continue to a non-PSK handshake.\n\nBehaviour like this is generally considered a vulnerability:\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0190\nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5229\n\nI was wondering if the document shouldn't recommend ignoring any and all\nidentities for which binders do not verify to prevent this kind of attack.\n"}]}, {"current_segment": {"sid": 7010, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nI tried to find some information on the internet, and\napparently the second option is more likely. The\nproblem is that I can't find any RFC or other standard\ndocuments elaborating on this situation..."}, "context_segments": []}, {"current_segment": {"sid": 7011, "labels": "InformationProviding,NeutralResponse,InformationProviding,Answer", "content": "\nThe second option is correct. RFC 3550 section 5.1.\n"}, "context_segments": [{"sid": 7010, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nI tried to find some information on the internet, and\napparently the second option is more likely. The\nproblem is that I can't find any RFC or other standard\ndocuments elaborating on this situation..."}]}, {"current_segment": {"sid": 7012, "labels": "InformationSeeking,ExtensionOfPrevious,ProposeAction,Thanking,Thanking,InformationProviding,Social", "content": "\nThank you very much for your help!"}, "context_segments": []}, {"current_segment": {"sid": 7013, "labels": "InformationProviding,InformationProviding", "content": "This is also documented in the annex \"B.2.4 Handling RTP Timestamps\nafter PAUSE\" of draft-ietf-mmusic-rfc2326bis-14."}, "context_segments": []}, {"current_segment": {"sid": 7014, "labels": "InformationProviding,NeutralResponse,InformationProviding", "content": "\nI came across this document before and I was really wondering whether\nthis is the best story the IETF can come up with."}, "context_segments": []}, {"current_segment": {"sid": 7015, "labels": "InformationProviding,Disagreement,InformationProviding", "content": "\nThe argument that RTP is used in a number of different environments, as\na basis for not offering a solid security story is rather weak. The same\ncould be said about many other protocols the IETF develops, even about\nTLS itself."}, "context_segments": []}, {"current_segment": {"sid": 7016, "labels": "InformationProviding,Disagreement,InformationProviding,Disagreement", "content": "\nI strongly disagree with that. TLS is a solution you choose to apply or\nnot. If your RTP application is a multicast one, then we can't do\nDTLS-SRTP, because it is can't function in such an environment. Similar\nobservations can be made about a number of different deployment cases.\n"}, "context_segments": [{"sid": 7015, "labels": "InformationProviding,Disagreement,InformationProviding", "content": "\nThe argument that RTP is used in a number of different environments, as\na basis for not offering a solid security story is rather weak. The same\ncould be said about many other protocols the IETF develops, even about\nTLS itself."}]}, {"current_segment": {"sid": 7017, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,InformationProviding,ProposeAction", "content": "\nHave a look at TLS to see an alternative path that one could go instead.\nIt mandates a certain ciphersuite and adds the following qualification:"}, "context_segments": []}, {"current_segment": {"sid": 7018, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nMandatory Cipher Suites"}, "context_segments": []}, {"current_segment": {"sid": 7019, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ProposeAction", "content": "\nIn the absence of an application profile standard specifying\notherwise, a TLS-compliant application MUST implement the cipher\nsuite TLS_RSA_WITH_AES_128_CBC_SHA (see Appendix A.5 for the\ndefinition)."}, "context_segments": []}, {"current_segment": {"sid": 7020, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nIf there are deployments or standardization organizations believe that\nthey do not require security (because it just runs within their own\n\"secure\" network* or because it requires a different solution solution,\nlike the 3GPP that allows lawful intercept) then that is not a good\nreason for the IETF not mandating something."}, "context_segments": []}, {"current_segment": {"sid": 7021, "labels": "InformationProviding,Disagreement,InformationProviding", "content": "\nI am wondering what motivated you write the document in this specific\nstyle. I believe I understand the motivation for Magnus."}, "context_segments": []}, {"current_segment": {"sid": 7022, "labels": "InformationProviding,NeutralResponse,InformationProviding,ProposeAction", "content": "\nMy motivation for writing SRTP-not-mandatory document was as WG chair to\nnot have to argue with the Security ADs each time an RTP document passed\nthe IESG about the security sections. If you are doing an RTP extensions\nyou need to discuss what that implies security wise and what security\nrequirements it has. However, it is not the appropriate place to mandate\na particular solution and key-management.\n\nWhat have been missing in IETF is to write the different \"This is what\nyou shall do, given that your RTP application class is foo\". There is\nclearly a need for such a document for SIP established sessions. But I\ndon't volunteer to write it.\n\nIf you look at draft-ietf-mmusic-rfc2326bis, that actually normatively\nrequire anyone supporting RTP with RTSP 2.0 to implement SRTP and MIKEY\nbased keying because that makes sense for RTSP.\n"}, "context_segments": [{"sid": 7021, "labels": "InformationProviding,Disagreement,InformationProviding", "content": "\nI am wondering what motivated you write the document in this specific\nstyle. I believe I understand the motivation for Magnus."}]}, {"current_segment": {"sid": 7023, "labels": "Social,Social", "content": "\nCiao"}, "context_segments": []}, {"current_segment": {"sid": 7024, "labels": "Social,InformationProviding", "content": "Hannes,"}, "context_segments": []}, {"current_segment": {"sid": 7025, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction", "content": "On draft-ietf-avt-srtp-not-mandatory:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  Clearly, this is not the best moment in history to be making\nthis sort of argument, given the increased focus on .  However, I think\nthis document makes the case pretty clearly.  It helps to have\ndraft-ietf-avtcore-rtp-security-options as a positive statement to go\nalongside this document."}, "context_segments": []}, {"current_segment": {"sid": 7026, "labels": "InformationProviding,Disagreement,InformationProviding,NeutralResponse", "content": "\nNote that the srtp-not-mandatory draft is explicitly not saying \"strong security is not mandatory\", rather it's saying that \"strong security is mandatory, but the appropriate way of providing it depends on the context, and SRTP is not always the answer\".\n"}, "context_segments": [{"sid": 7025, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction", "content": "On draft-ietf-avt-srtp-not-mandatory:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  Clearly, this is not the best moment in history to be making\nthis sort of argument, given the increased focus on .  However, I think\nthis document makes the case pretty clearly.  It helps to have\ndraft-ietf-avtcore-rtp-security-options as a positive statement to go\nalongside this document."}]}, {"current_segment": {"sid": 7027, "labels": "InformationProviding,Agreement,InformationProviding,Agreement", "content": "\nI agree.  It helps though, to be able to say \"SRTP is not always the answer\n... but something in this set of things should be.\"\n"}, "context_segments": [{"sid": 7025, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction", "content": "On draft-ietf-avt-srtp-not-mandatory:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  Clearly, this is not the best moment in history to be making\nthis sort of argument, given the increased focus on .  However, I think\nthis document makes the case pretty clearly.  It helps to have\ndraft-ietf-avtcore-rtp-security-options as a positive statement to go\nalongside this document."}, {"sid": 7026, "labels": "InformationProviding,Disagreement,InformationProviding,NeutralResponse", "content": "\nNote that the srtp-not-mandatory draft is explicitly not saying \"strong security is not mandatory\", rather it's saying that \"strong security is mandatory, but the appropriate way of providing it depends on the context, and SRTP is not always the answer\".\n"}]}, {"current_segment": {"sid": 7028, "labels": "InformationProviding,NeutralResponse,InformationProviding,ProposeAction", "content": "\nI think you need to say, hopefully something in this set should be. It\nis not certain that we actually have the security mechanism required for\na particular application context.\n"}, "context_segments": [{"sid": 7025, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction", "content": "On draft-ietf-avt-srtp-not-mandatory:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  Clearly, this is not the best moment in history to be making\nthis sort of argument, given the increased focus on .  However, I think\nthis document makes the case pretty clearly.  It helps to have\ndraft-ietf-avtcore-rtp-security-options as a positive statement to go\nalongside this document."}, {"sid": 7026, "labels": "InformationProviding,Disagreement,InformationProviding,NeutralResponse", "content": "\nNote that the srtp-not-mandatory draft is explicitly not saying \"strong security is not mandatory\", rather it's saying that \"strong security is mandatory, but the appropriate way of providing it depends on the context, and SRTP is not always the answer\".\n"}, {"sid": 7027, "labels": "InformationProviding,Agreement,InformationProviding,Agreement", "content": "\nI agree.  It helps though, to be able to say \"SRTP is not always the answer\n... but something in this set of things should be.\"\n"}]}, {"current_segment": {"sid": 7029, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,InformationProviding,InformationSeeking", "content": "\nOn draft-ietf-avtcore-rtp-security-options:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  One question to discuss briefly before IETF LC:  My major\nconcern is that it seems like there's a lot of old stuff in here.  Has the\nWG considered explicitly marking each of the mechanisms with some sort of\nrecommendation level?  I would like to avoid having someone choose SDES in\na case where they could use DTLS-SRTP, for example."}, "context_segments": []}, {"current_segment": {"sid": 7030, "labels": "InformationProviding,Answer,InformationProviding,Answer,Agreement,ProposeAction", "content": "\nSuch recommendations would be very helpful, but depend on the scenario. Section 5 gives some pointers, but really we need security architecture drafts for particular use cases of RTP (like the WebRTC security arch, for example).\n"}, "context_segments": [{"sid": 7029, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,InformationProviding,InformationSeeking", "content": "\nOn draft-ietf-avtcore-rtp-security-options:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  One question to discuss briefly before IETF LC:  My major\nconcern is that it seems like there's a lot of old stuff in here.  Has the\nWG considered explicitly marking each of the mechanisms with some sort of\nrecommendation level?  I would like to avoid having someone choose SDES in\na case where they could use DTLS-SRTP, for example."}]}, {"current_segment": {"sid": 7031, "labels": "InformationProviding,Agreement,NeutralResponse,ProposeAction,Question,InformationProviding,Agreement,ProposeAction,InformationSeeking", "content": "\nI agree that if you're going to make detailed recommendations, you need\nmore specifics.  It seems like you could provide some general guidance\nthough.  Could we something like the following?\n-- Arrange the mechanisms in the document in an ordered list\n-- \"If more than one mechanism would work for your application, use the\nhigher-pref one\"\n-- Throw certain things in a NOT RECOMMENDED bucket, like ZRTP and the\nlegacy stuff in S3.2\n\nPart of the advice should also be a reference to BCP 107 [1], \"Guidelines\nfor Cryptographic Key Management\".  Namely, things that provide automated\nkey management should be preferred over things that don't.\n\n--Richard\n\n[1] <http://tools.ietf.org/html/bcp107>\n"}, "context_segments": [{"sid": 7029, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,InformationProviding,InformationSeeking", "content": "\nOn draft-ietf-avtcore-rtp-security-options:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  One question to discuss briefly before IETF LC:  My major\nconcern is that it seems like there's a lot of old stuff in here.  Has the\nWG considered explicitly marking each of the mechanisms with some sort of\nrecommendation level?  I would like to avoid having someone choose SDES in\na case where they could use DTLS-SRTP, for example."}, {"sid": 7030, "labels": "InformationProviding,Answer,InformationProviding,Answer,Agreement,ProposeAction", "content": "\nSuch recommendations would be very helpful, but depend on the scenario. Section 5 gives some pointers, but really we need security architecture drafts for particular use cases of RTP (like the WebRTC security arch, for example).\n"}]}, {"current_segment": {"sid": 7032, "labels": "InformationProviding,Disagreement,InformationProviding,Answer,Disagreement", "content": "\nFirst of all this is an informational document, it was not written as a\nrecommendation document. It is a survey with some general guidelines.\n"}, "context_segments": [{"sid": 7029, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,InformationProviding,InformationSeeking", "content": "\nOn draft-ietf-avtcore-rtp-security-options:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  One question to discuss briefly before IETF LC:  My major\nconcern is that it seems like there's a lot of old stuff in here.  Has the\nWG considered explicitly marking each of the mechanisms with some sort of\nrecommendation level?  I would like to avoid having someone choose SDES in\na case where they could use DTLS-SRTP, for example."}, {"sid": 7030, "labels": "InformationProviding,Answer,InformationProviding,Answer,Agreement,ProposeAction", "content": "\nSuch recommendations would be very helpful, but depend on the scenario. Section 5 gives some pointers, but really we need security architecture drafts for particular use cases of RTP (like the WebRTC security arch, for example).\n"}, {"sid": 7031, "labels": "InformationProviding,Agreement,NeutralResponse,ProposeAction,Question,InformationProviding,Agreement,ProposeAction,InformationSeeking", "content": "\nI agree that if you're going to make detailed recommendations, you need\nmore specifics.  It seems like you could provide some general guidance\nthough.  Could we something like the following?\n-- Arrange the mechanisms in the document in an ordered list\n-- \"If more than one mechanism would work for your application, use the\nhigher-pref one\"\n-- Throw certain things in a NOT RECOMMENDED bucket, like ZRTP and the\nlegacy stuff in S3.2\n\nPart of the advice should also be a reference to BCP 107 [1], \"Guidelines\nfor Cryptographic Key Management\".  Namely, things that provide automated\nkey management should be preferred over things that don't.\n\n--Richard\n\n[1] <http://tools.ietf.org/html/bcp107>\n"}]}, {"current_segment": {"sid": 7033, "labels": "Question,NeutralResponse,Question,InformationSeeking,InformationProviding", "content": "\nAccording to which application context should that list be arranged for?\n"}, "context_segments": [{"sid": 7029, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,InformationProviding,InformationSeeking", "content": "\nOn draft-ietf-avtcore-rtp-security-options:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  One question to discuss briefly before IETF LC:  My major\nconcern is that it seems like there's a lot of old stuff in here.  Has the\nWG considered explicitly marking each of the mechanisms with some sort of\nrecommendation level?  I would like to avoid having someone choose SDES in\na case where they could use DTLS-SRTP, for example."}, {"sid": 7030, "labels": "InformationProviding,Answer,InformationProviding,Answer,Agreement,ProposeAction", "content": "\nSuch recommendations would be very helpful, but depend on the scenario. Section 5 gives some pointers, but really we need security architecture drafts for particular use cases of RTP (like the WebRTC security arch, for example).\n"}, {"sid": 7031, "labels": "InformationProviding,Agreement,NeutralResponse,ProposeAction,Question,InformationProviding,Agreement,ProposeAction,InformationSeeking", "content": "\nI agree that if you're going to make detailed recommendations, you need\nmore specifics.  It seems like you could provide some general guidance\nthough.  Could we something like the following?\n-- Arrange the mechanisms in the document in an ordered list\n-- \"If more than one mechanism would work for your application, use the\nhigher-pref one\"\n-- Throw certain things in a NOT RECOMMENDED bucket, like ZRTP and the\nlegacy stuff in S3.2\n\nPart of the advice should also be a reference to BCP 107 [1], \"Guidelines\nfor Cryptographic Key Management\".  Namely, things that provide automated\nkey management should be preferred over things that don't.\n\n--Richard\n\n[1] <http://tools.ietf.org/html/bcp107>\n"}]}, {"current_segment": {"sid": 7034, "labels": "InformationProviding,Disagreement,NeutralResponse,InformationProviding,NeutralResponse", "content": "\nThe issue is that one mechanism is more suitable in the context of\nmulticast but, maybe another is more suitable in another application\ncontext. And there are relative ordering will vary.\n"}, "context_segments": [{"sid": 7029, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,InformationProviding,InformationSeeking", "content": "\nOn draft-ietf-avtcore-rtp-security-options:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  One question to discuss briefly before IETF LC:  My major\nconcern is that it seems like there's a lot of old stuff in here.  Has the\nWG considered explicitly marking each of the mechanisms with some sort of\nrecommendation level?  I would like to avoid having someone choose SDES in\na case where they could use DTLS-SRTP, for example."}, {"sid": 7030, "labels": "InformationProviding,Answer,InformationProviding,Answer,Agreement,ProposeAction", "content": "\nSuch recommendations would be very helpful, but depend on the scenario. Section 5 gives some pointers, but really we need security architecture drafts for particular use cases of RTP (like the WebRTC security arch, for example).\n"}, {"sid": 7031, "labels": "InformationProviding,Agreement,NeutralResponse,ProposeAction,Question,InformationProviding,Agreement,ProposeAction,InformationSeeking", "content": "\nI agree that if you're going to make detailed recommendations, you need\nmore specifics.  It seems like you could provide some general guidance\nthough.  Could we something like the following?\n-- Arrange the mechanisms in the document in an ordered list\n-- \"If more than one mechanism would work for your application, use the\nhigher-pref one\"\n-- Throw certain things in a NOT RECOMMENDED bucket, like ZRTP and the\nlegacy stuff in S3.2\n\nPart of the advice should also be a reference to BCP 107 [1], \"Guidelines\nfor Cryptographic Key Management\".  Namely, things that provide automated\nkey management should be preferred over things that don't.\n\n--Richard\n\n[1] <http://tools.ietf.org/html/bcp107>\n"}]}, {"current_segment": {"sid": 7035, "labels": "InformationProviding,Disagreement,Question,InformationProviding,ContextSetting,InformationSeeking", "content": "\nSection 3.2 says:\n\nThis\nmethod can provide confidentiality but, as discussed in Section 9 of\n[RFC3550], it has extremely weak security properties and is not to be\nused.\n\nIsn't this clear enough? I don't want to use RFC 2119 language in an\nInformational document that is a description, and not a recommendation\ndocument.\n\nFor ZRTP what are your grounds for issuing the NOT RECOMMENDED. I think\nwe accurately describes its status."}, "context_segments": [{"sid": 7029, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,InformationProviding,InformationSeeking", "content": "\nOn draft-ietf-avtcore-rtp-security-options:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  One question to discuss briefly before IETF LC:  My major\nconcern is that it seems like there's a lot of old stuff in here.  Has the\nWG considered explicitly marking each of the mechanisms with some sort of\nrecommendation level?  I would like to avoid having someone choose SDES in\na case where they could use DTLS-SRTP, for example."}, {"sid": 7030, "labels": "InformationProviding,Answer,InformationProviding,Answer,Agreement,ProposeAction", "content": "\nSuch recommendations would be very helpful, but depend on the scenario. Section 5 gives some pointers, but really we need security architecture drafts for particular use cases of RTP (like the WebRTC security arch, for example).\n"}, {"sid": 7031, "labels": "InformationProviding,Agreement,NeutralResponse,ProposeAction,Question,InformationProviding,Agreement,ProposeAction,InformationSeeking", "content": "\nI agree that if you're going to make detailed recommendations, you need\nmore specifics.  It seems like you could provide some general guidance\nthough.  Could we something like the following?\n-- Arrange the mechanisms in the document in an ordered list\n-- \"If more than one mechanism would work for your application, use the\nhigher-pref one\"\n-- Throw certain things in a NOT RECOMMENDED bucket, like ZRTP and the\nlegacy stuff in S3.2\n\nPart of the advice should also be a reference to BCP 107 [1], \"Guidelines\nfor Cryptographic Key Management\".  Namely, things that provide automated\nkey management should be preferred over things that don't.\n\n--Richard\n\n[1] <http://tools.ietf.org/html/bcp107>\n"}]}, {"current_segment": {"sid": 7036, "labels": "InformationProviding,Agreement,InformationProviding,StateDecision", "content": "\nYes, this we can add to section 4. Securing RTP Applications.\n"}, "context_segments": [{"sid": 7029, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,InformationProviding,InformationSeeking", "content": "\nOn draft-ietf-avtcore-rtp-security-options:\nI have reviewed this draft in preparation for IETF Last Call and IESG\nprocessing.  One question to discuss briefly before IETF LC:  My major\nconcern is that it seems like there's a lot of old stuff in here.  Has the\nWG considered explicitly marking each of the mechanisms with some sort of\nrecommendation level?  I would like to avoid having someone choose SDES in\na case where they could use DTLS-SRTP, for example."}, {"sid": 7030, "labels": "InformationProviding,Answer,InformationProviding,Answer,Agreement,ProposeAction", "content": "\nSuch recommendations would be very helpful, but depend on the scenario. Section 5 gives some pointers, but really we need security architecture drafts for particular use cases of RTP (like the WebRTC security arch, for example).\n"}, {"sid": 7031, "labels": "InformationProviding,Agreement,NeutralResponse,ProposeAction,Question,InformationProviding,Agreement,ProposeAction,InformationSeeking", "content": "\nI agree that if you're going to make detailed recommendations, you need\nmore specifics.  It seems like you could provide some general guidance\nthough.  Could we something like the following?\n-- Arrange the mechanisms in the document in an ordered list\n-- \"If more than one mechanism would work for your application, use the\nhigher-pref one\"\n-- Throw certain things in a NOT RECOMMENDED bucket, like ZRTP and the\nlegacy stuff in S3.2\n\nPart of the advice should also be a reference to BCP 107 [1], \"Guidelines\nfor Cryptographic Key Management\".  Namely, things that provide automated\nkey management should be preferred over things that don't.\n\n--Richard\n\n[1] <http://tools.ietf.org/html/bcp107>\n"}]}, {"current_segment": {"sid": 7037, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "\nIf the authors could follow up on that one point, we should be able to get\nthese both into LC soon."}, "context_segments": []}, {"current_segment": {"sid": 7038, "labels": "ContextSetting,Social,ProposeAction,InformationProviding", "content": "Richard and WG,\n\nSee inline\n"}, "context_segments": []}, {"current_segment": {"sid": 7039, "labels": "InformationProviding,Disagreement,InformationProviding,Answer", "content": "\nI think that the purpose of the security option is as the name says to list\nthe options and not recommend anything leaving it to the specific deployment\nlike RTCweb to make recommendation. In this case if we try to recommend\norder it may just cause further discussion about the order and priority\nwhich is what we wanted to avoid in this work in the first place"}, "context_segments": []}, {"current_segment": {"sid": 7040, "labels": "Social,Social", "content": "Hi Richard,"}, "context_segments": []}, {"current_segment": {"sid": 7041, "labels": "Social,Social", "content": "Hi Colin,"}, "context_segments": []}, {"current_segment": {"sid": 7042, "labels": "InformationProviding,NeutralResponse,ProposeAction,Thanking,InformationProviding,Agreement,ProposeAction,Thanking,Social", "content": "Hey Magnus,\n\nThat looks much better.  Thanks for the text.  I will put this out to LC\nalong with -srtp-not-mandatory.\n\n--Richard\n"}, "context_segments": []}, {"current_segment": {"sid": 7043, "labels": "Social,InformationProviding", "content": "Richard and WG,"}, "context_segments": []}, {"current_segment": {"sid": 7044, "labels": "InformationProviding,NeutralResponse,ProposeAction,Question,InformationProviding,ProposeAction,InformationSeeking", "content": "Can we seriously not come up with some general principles here?  There are\nalready some in the document, e.g., in the IPsec section.\n\n-- In general, SRTP-based solutions are preferable to things that tunnel\nRTP over something else, because tunnel solutions have additional\nvulnerabilities.\n-- In general, mechanisms that provide automated key management are\npreferable to things that don't [BCP107]\n\nAnd it seems like we should clearly deprecate the legacy RTP mechanism\n(S3.2), and clearly indicate that new IETF protocols should use DTLS-SRTP\ninstead of ZRTP (in cases where both are applicable).\n"}, "context_segments": []}, {"current_segment": {"sid": 7045, "labels": "InformationProviding,NeutralResponse,InformationProviding,StateDecision", "content": "\nWe have updated the RTP Security Options document. This adds three\nguidance sub-sections regarding automated key-management, tunnels vs\nend-to-end security and plain text key considerations."}, "context_segments": []}, {"current_segment": {"sid": 7046, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nI also fixes a missing reference. All visible in the diff:\nhttp://www.ietf.org/rfcdiff?url2=draft-ietf-avtcore-rtp-security-options-09"}, "context_segments": []}, {"current_segment": {"sid": 7047, "labels": "ExtensionOfPrevious,ProposeAction,ProposeAction,InformationProviding", "content": "\nI hope everyone can take a look at these changes and react if they are\nwrong or non-acceptable."}, "context_segments": []}, {"current_segment": {"sid": 7048, "labels": "InformationProviding,Disagreement,ProposeAction,InformationProviding,ProposeAction,UnderstandingNegative", "content": "\nThe goal of the draft is not to justify a lack of strong security. It is to explain why SRTP is not an appropriate mechanism for providing strong security for all use cases of RTP, and highlight that some scenarios need alternative strong security mechanisms. The rtp-security-options draft talks about what those options might be. If there are sections in the draft that don't make that clear, please let me know, and we can try to improve the text."}, "context_segments": []}, {"current_segment": {"sid": 7049, "labels": "InformationProviding,Disagreement,InformationProviding,NeutralResponse", "content": "\nThe draft says nothing about the cipher suites to be used. Both SRTP and the other security options mandate strong cipher suites, and there are no proposals to change that."}, "context_segments": []}, {"current_segment": {"sid": 7050, "labels": "InformationProviding,InformationProviding", "content": "In Table 4 (Section 8.1.1: Status Code and Reason Phrase), the 451\nresponse (\"Parameter Not Understood\") is listed as being applicable\nto the \"SET_PARAMETER\" command only.  However, elsewhere in the text,\nit is described as being applicable to the \"GET_PARAMETER\" command\nalso."}, "context_segments": []}, {"current_segment": {"sid": 1642, "labels": "InformationProviding,InformationProviding", "content": "@gloinul"}, "context_segments": []}, {"current_segment": {"sid": 5805, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nA list of Internet-Drafts directories can be found in\nhttp://www.ietf.org/shadow.html\nor ftp://ftp.ietf.org/ietf/1shadow-sites.txt"}, "context_segments": [{"sid": 1642, "labels": "InformationProviding,InformationProviding", "content": "@gloinul"}]}, {"current_segment": {"sid": 1643, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,Disagreement,ProposeAction,InformationProviding", "content": "\nSecondly, trying to combine the ECN response of multiple packets is less than straightforward and exposes one to the risk above. It can also make one more likely to treat a specific ECN number as CE than none duplicated packets. Also the downside of dropping any duplicate packet even if CE marked is not significant. If you have a congestion event that results in the next packet is marked also, then the CE event will be reported one packet later.\n\nECN for RTP (https://www.rfc-editor.org/rfc/rfc6679.txt) actually tracks duplication and loss as seen by receiver to give all variables, but the retrospective on that RFC is that is overly causes.\n\nI would argue that QUIC need a basic duplication handling, and that ECN processing happens after the packet has been decrypted and authenticated to avoid any type of injection attacks, and require additional checking mechanism for it being a valid source sent packet.\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-394712102"}, "context_segments": []}, {"current_segment": {"sid": 5806, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nInternet-Drafts can also be obtained by e-mail."}, "context_segments": [{"sid": 1643, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,Disagreement,ProposeAction,InformationProviding", "content": "\nSecondly, trying to combine the ECN response of multiple packets is less than straightforward and exposes one to the risk above. It can also make one more likely to treat a specific ECN number as CE than none duplicated packets. Also the downside of dropping any duplicate packet even if CE marked is not significant. If you have a congestion event that results in the next packet is marked also, then the CE event will be reported one packet later.\n\nECN for RTP (https://www.rfc-editor.org/rfc/rfc6679.txt) actually tracks duplication and loss as seen by receiver to give all variables, but the retrospective on that RFC is that is overly causes.\n\nI would argue that QUIC need a basic duplication handling, and that ECN processing happens after the packet has been decrypted and authenticated to avoid any type of injection attacks, and require additional checking mechanism for it being a valid source sent packet.\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-394712102"}]}, {"current_segment": {"sid": 1644, "labels": "Thanking,Thanking,Social", "content": "Thank you for the explanation."}, "context_segments": []}, {"current_segment": {"sid": 5807, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nSend a message to:\nmailserv@ietf.org.\nIn the body type:\n\"FILE /internet-drafts/draft-ietf-mmusic-rfc2326bis-05.txt\"."}, "context_segments": [{"sid": 1644, "labels": "Thanking,Thanking,Social", "content": "Thank you for the explanation."}]}, {"current_segment": {"sid": 1645, "labels": "InformationProviding,StateDecision,NeutralResponse", "content": "\nI now see that we need to decrypt the packet before updating the ECN counter."}, "context_segments": []}, {"current_segment": {"sid": 5808, "labels": "InformationProviding,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\nNOTE:\tThe mail server at ietf.org can return the document in\nMIME-encoded form by using the \"mpack\" utility.  To use this\nfeature, insert the command \"ENCODING mime\" before the \"FILE\"\ncommand.  To decode the response(s), you will need \"munpack\" or\na MIME-compliant mail reader.  Different MIME-compliant mail readers\nexhibit different behavior, especially when dealing with\n\"multipart\" MIME messages (i.e. documents which have been split\nup into multiple messages), so check your local documentation on\nhow to manipulate these messages."}, "context_segments": [{"sid": 1645, "labels": "InformationProviding,StateDecision,NeutralResponse", "content": "\nI now see that we need to decrypt the packet before updating the ECN counter."}]}, {"current_segment": {"sid": 1646, "labels": "InformationProviding,NeutralResponse,NeutralResponse", "content": "\nAnd I think that detecting duplicates on an endpoint is not that complicated now that we have PNE, which means that we can assume that packet numbers will be used mostly contiguously (we might need to specify how frequently packet numbers can be skipped to detect optimistic ack attacks)."}, "context_segments": []}, {"current_segment": {"sid": 5809, "labels": "InformationProviding,ContextSetting,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nBelow is the data which will enable a MIME compliant mail reader\nimplementation to automatically retrieve the ASCII version of the\nInternet-Draft."}, "context_segments": [{"sid": 1646, "labels": "InformationProviding,NeutralResponse,NeutralResponse", "content": "\nAnd I think that detecting duplicates on an endpoint is not that complicated now that we have PNE, which means that we can assume that packet numbers will be used mostly contiguously (we might need to specify how frequently packet numbers can be skipped to detect optimistic ack attacks)."}]}, {"current_segment": {"sid": 1647, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-394731145"}, "context_segments": []}, {"current_segment": {"sid": 5810, "labels": "Social,Social", "content": "Hi,"}, "context_segments": [{"sid": 1647, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-394731145"}]}, {"current_segment": {"sid": 1648, "labels": "InformationProviding,ProposeAction,NeutralResponse", "content": "I think this discussion of duplicates illustrates a more fundamental issue with ECN: it is a signal from outside the encryption envelope that affects the behavior of the encrypted communication. In theory, all kinds of games are possible: adversarial ECN marking by an on-path device; copying of packets and reinjection with adversarial ECN markings by a man-on-the-side; copying of packets and reinjection with different IP headers and ports by an on-path device or a man on the side, possibly with the goal of messing up per-path ECN behavior. IMHO, the handling of ECN should be robust against these attacks, and the protection of ECN should not come from assumptions about how devices might or might not filter duplicate packets."}, "context_segments": []}, {"current_segment": {"sid": 5811, "labels": "InformationProviding,ProposeAction,InformationProviding,ContextSetting", "content": "\nI would like to make you aware of that the 05 text versions contains a\nnumber of erroneous formatted tables. This is the known occurrences:"}, "context_segments": [{"sid": 1648, "labels": "InformationProviding,ProposeAction,NeutralResponse", "content": "I think this discussion of duplicates illustrates a more fundamental issue with ECN: it is a signal from outside the encryption envelope that affects the behavior of the encrypted communication. In theory, all kinds of games are possible: adversarial ECN marking by an on-path device; copying of packets and reinjection with adversarial ECN markings by a man-on-the-side; copying of packets and reinjection with different IP headers and ports by an on-path device or a man on the side, possibly with the goal of messing up per-path ECN behavior. IMHO, the handling of ECN should be robust against these attacks, and the protection of ECN should not come from assumptions about how devices might or might not filter duplicate packets."}]}, {"current_segment": {"sid": 1649, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction,ContextSetting,Question,InformationSeeking", "content": "Packet duplication sometimes occur and it has a potential for affecting the ECN counter for what markings that arrive within a connection. Thus, it would be good if the requirements on how a QUIC implementation handle packets that are detected as duplicates.\n\nThere also appear that there are current text in the transport draft that makes assumption about handling of duplicate packets:\n\n6.10.4.1.  Detecting a Stateless Reset\n\nA client detects a potential stateless reset when a packet with a\nshort header either cannot be decrypted or is marked as a duplicate\npacket.\n\nThe other mention of packet duplication, also pointing to an action that is this:\n\n6.8.3.2.  Handling Address Spoofing by an On-path Attacker\n\nAn on-path attacker could cause a spurious connection migration by\ncopying and forwarding a packet with a spoofed address such that it\narrives before the original packet.  The packet with the spoofed\naddress will be seen to come from a migrating connection, and the\noriginal packet will be seen as a duplicate and dropped.\n\nThese two pieces appear to indicate that packet duplicates should:\n1. Be detected by receiver, at least within the window of PN between highest seen and some window into the past.\n2. The packet marked as duplicate\n3. Duplicate are dropped, but only after having been somewhat processed (see 6.10.4.1).\n\nTo my understanding the smallest window a receiver could have for tracking packets, is what is in ACKs that hasn't been ACKed yet. But that could be extremely short into the past, which could be short in time, compared to the expected re-ordering or packet life time in the network. Independently of window size, if a packet would arrive with a PN that is prior to the current window the receiver have, the receiver has discard the state for the packet number, and thus can't determine if it was ACKed or not, and thus needs to be discarded without further processing. Is that correctly assumed.\n\nThus, it would be good if these assumptions and needed functionality was collected in its own paragraphs somewhere in the specification.\n"}, "context_segments": []}, {"current_segment": {"sid": 5812, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nPage 24, status codes.\nPage 26, table lines\nPage 51, Adjusted Packet diagram does not fit on one page.\nPage 62, 63, Header table.\nPage 99, Message syntax\nPage 100, 101, Message syntax\npage 114, Table 7, init state\nPage 115, Table 8, Ready State\nPage 116, Table 9, Play State"}, "context_segments": [{"sid": 1649, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction,ContextSetting,Question,InformationSeeking", "content": "Packet duplication sometimes occur and it has a potential for affecting the ECN counter for what markings that arrive within a connection. Thus, it would be good if the requirements on how a QUIC implementation handle packets that are detected as duplicates.\n\nThere also appear that there are current text in the transport draft that makes assumption about handling of duplicate packets:\n\n6.10.4.1.  Detecting a Stateless Reset\n\nA client detects a potential stateless reset when a packet with a\nshort header either cannot be decrypted or is marked as a duplicate\npacket.\n\nThe other mention of packet duplication, also pointing to an action that is this:\n\n6.8.3.2.  Handling Address Spoofing by an On-path Attacker\n\nAn on-path attacker could cause a spurious connection migration by\ncopying and forwarding a packet with a spoofed address such that it\narrives before the original packet.  The packet with the spoofed\naddress will be seen to come from a migrating connection, and the\noriginal packet will be seen as a duplicate and dropped.\n\nThese two pieces appear to indicate that packet duplicates should:\n1. Be detected by receiver, at least within the window of PN between highest seen and some window into the past.\n2. The packet marked as duplicate\n3. Duplicate are dropped, but only after having been somewhat processed (see 6.10.4.1).\n\nTo my understanding the smallest window a receiver could have for tracking packets, is what is in ACKs that hasn't been ACKed yet. But that could be extremely short into the past, which could be short in time, compared to the expected re-ordering or packet life time in the network. Independently of window size, if a packet would arrive with a PN that is prior to the current window the receiver have, the receiver has discard the state for the packet number, and thus can't determine if it was ACKed or not, and thus needs to be discarded without further processing. Is that correctly assumed.\n\nThus, it would be good if these assumptions and needed functionality was collected in its own paragraphs somewhere in the specification.\n"}]}, {"current_segment": {"sid": 1650, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405"}, "context_segments": []}, {"current_segment": {"sid": 5813, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ProposeAction,Social", "content": "\nYou will have to live with these errors or read the pdf or PS version.\nPlease note that the change bars in the documents are in relation to the\n04 draft version. The major changes are in the methods chapter where a\nlot of rewrite has been performed."}, "context_segments": [{"sid": 1650, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405"}]}, {"current_segment": {"sid": 1651, "labels": "InformationProviding,InformationProviding", "content": "The main point I like to stress, is that there will be a number of long lived connections that never will rekey if they are only based on sent packets. Even if one send 136 packets per second, the sender rekeys only once every year. And there are plenty of applications that will send less than a packet a second on average. The attack outlined is not affecting the number of sent packets by the sender in any significant way, it will only result in sending a lot of packets to the receiver and watch for signs of successful forgery by monitoring what the receiver emits back to the sender. Thus, if one can send 10000 packets a second to the receiver, then one will have had the possibility of sending ~2^38 packet by the time of rekeying. So still a low probability of success but not insignificant."}, "context_segments": []}, {"current_segment": {"sid": 5814, "labels": "StateDecision,InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nWe will post a new corrected version after the meeting."}, "context_segments": [{"sid": 1651, "labels": "InformationProviding,InformationProviding", "content": "The main point I like to stress, is that there will be a number of long lived connections that never will rekey if they are only based on sent packets. Even if one send 136 packets per second, the sender rekeys only once every year. And there are plenty of applications that will send less than a packet a second on average. The attack outlined is not affecting the number of sent packets by the sender in any significant way, it will only result in sending a lot of packets to the receiver and watch for signs of successful forgery by monitoring what the receiver emits back to the sender. Thus, if one can send 10000 packets a second to the receiver, then one will have had the possibility of sending ~2^38 packet by the time of rekeying. So still a low probability of success but not insignificant."}]}, {"current_segment": {"sid": 1652, "labels": "InformationProviding,NeutralResponse", "content": "I think the logic is that, if the packet number appears to be a duplicate, you don't attempt decryption and treat it as if decryption failed.  Packets where decryption fails get checked as potential Stateless Resets, then discarded."}, "context_segments": []}, {"current_segment": {"sid": 5815, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "A New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Multiparty Multimedia Session Control Working Group of the IETF."}, "context_segments": [{"sid": 1652, "labels": "InformationProviding,NeutralResponse", "content": "I think the logic is that, if the packet number appears to be a duplicate, you don't attempt decryption and treat it as if decryption failed.  Packets where decryption fails get checked as potential Stateless Resets, then discarded."}]}, {"current_segment": {"sid": 1653, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-395294672"}, "context_segments": []}, {"current_segment": {"sid": 5816, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nTitle\t\t: Real Time Streaming Protocol (RTSP)\nAuthor(s)\t: H. Schulzrinne\nFilename\t: draft-ietf-mmusic-rfc2326bis-05.txt,.ps,.pdf\nPages\t\t: 147\nDate\t\t: 2003-10-27"}, "context_segments": [{"sid": 1653, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-395294672"}]}, {"current_segment": {"sid": 1654, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398042975"}, "context_segments": []}, {"current_segment": {"sid": 5817, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nThis memorandum is a revision of RFC 2326, which is currently a Pro-\nposed Standard.\nThe Real Time Streaming Protocol, or RTSP, is an application-level\nprotocol for control over the delivery of data with real-time\nproperties. RTSP provides an extensible framework to enable con-\ntrolled, on-demand delivery of real-time data, such as audio and\nvideo. Sources of data can include both live data feeds and stored\nclips. This protocol is intended to control multiple data delivery\nsessions, provide a means for choosing delivery channels such as UDP,\nmulticast UDP and TCP, and provide a means for choosing delivery\nmechanisms based upon RTP (RFC 1889)."}, "context_segments": [{"sid": 1654, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398042975"}]}, {"current_segment": {"sid": 1655, "labels": "InformationProviding,ContextSetting,Answer", "content": "As discussed in https://github.com/quicwg/base-drafts/issues/1439#issuecomment-397589048, my understanding is that the ECN support in the form proposed in #1372 is the only issue that makes duplicate detection a requirement rather than an option."}, "context_segments": []}, {"current_segment": {"sid": 5818, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nA URL for this Internet-Draft is:\nhttp://www.ietf.org/internet-drafts/draft-ietf-mmusic-rfc2326bis-05.txt"}, "context_segments": [{"sid": 1655, "labels": "InformationProviding,ContextSetting,Answer", "content": "As discussed in https://github.com/quicwg/base-drafts/issues/1439#issuecomment-397589048, my understanding is that the ECN support in the form proposed in #1372 is the only issue that makes duplicate detection a requirement rather than an option."}]}, {"current_segment": {"sid": 1656, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious,ProposeAction", "content": "\nOf course, if that's not stated explicitly somewhere, it ought to be...."}, "context_segments": []}, {"current_segment": {"sid": 5819, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nTo remove yourself from the IETF Announcement list, send a message to\nietf-announce-request with the word unsubscribe in the body of the message."}, "context_segments": [{"sid": 1656, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious,ProposeAction", "content": "\nOf course, if that's not stated explicitly somewhere, it ought to be...."}]}, {"current_segment": {"sid": 1657, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-393607492"}, "context_segments": []}, {"current_segment": {"sid": 5820, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious", "content": "\nInternet-Drafts are also available by anonymous FTP. Login with the username\n\"anonymous\" and a password of your e-mail address. After logging in,\ntype \"cd internet-drafts\" and then\n\"get draft-ietf-mmusic-rfc2326bis-05.txt\"."}, "context_segments": [{"sid": 1657, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-393607492"}]}, {"current_segment": {"sid": 1658, "labels": "InformationProviding,Agreement,NeutralResponse", "content": "As to detection of duplicates further back, you're correct that *if* you discard that state, you won't be able to detect duplicate packets.  An implementation that receives a packet older than it can identify then has a choice:  Either it discards the packet, or processes it.  Processing a duplicate packet is merely sub-optimal, not fatal, since each frame inside should also be recognized as superfluous."}, "context_segments": []}, {"current_segment": {"sid": 1659, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,ExtensionOfPrevious,ProposeAction", "content": "\nConsidering that, I think that we have a chance of closing the issue without adding any requirements if we adopt a different encoding scheme that lets the sender detect duplicates as discussed #1439."}, "context_segments": []}, {"current_segment": {"sid": 1660, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-397590223"}, "context_segments": []}, {"current_segment": {"sid": 1661, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-393608227"}, "context_segments": []}, {"current_segment": {"sid": 1662, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "An important clarification about this attack: The attack on AES-GCM is definitely valid for truncated authentication tags. However, my co-author clarified to me that this is not an issue for untruncated tags. So as long as QUIC uses 128 bit authentication tags for AES-GCM we should have no issue from a cryptographic perspective.\n\nI still think not having any requirement on replay protection at the main protocol level puts a lot of responsibility on the designers of extensions as well as implementers to ensure that things truly are idempotent when sent input.\n\n@kazuho\n"}, "context_segments": []}, {"current_segment": {"sid": 1663, "labels": "InformationProviding,Agreement,Agreement,NeutralResponse", "content": "Mike is right about discarding duplicate packets, and I thought that text existed, but I can't find it."}, "context_segments": []}, {"current_segment": {"sid": 1664, "labels": "InformationProviding", "content": "@gloinul"}, "context_segments": []}, {"current_segment": {"sid": 1665, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-393651575"}, "context_segments": []}, {"current_segment": {"sid": 1666, "labels": "InformationProviding,ProposeAction,NeutralResponse,ProposeAction", "content": "We can probably crib something from DTLS.  The usual method is to maintain a bitvector for the last N packets, and to drop anything that appears to be before that vector starts.  The point about stateless reset is a good one, and one I discovered when implementing it.  It's highly likely that a stateless reset will appear to be a duplicate."}, "context_segments": []}, {"current_segment": {"sid": 1667, "labels": "InformationProviding,ContextSetting", "content": "In regards to @kazuho comment:\n"}, "context_segments": []}, {"current_segment": {"sid": 1668, "labels": "Question,InformationProviding,Agreement,ProposeAction,ClarificationElicitation,Question,Agreement,ProposeAction,InformationProviding,InformationSeeking", "content": "\nSo, do I assume correctly, that you will still throw away packets that are several RTTs old, i.e. that have a PN number older than any state? Or do you generate an ACK for that old packet that is so old, and try to find if there is any unconsumed buffers to put any data in?\n\nYou might be right in that all existing frames have a behavior that if one applies it twice it already have the handling rules to suppress the duplicate or not cause any downside of being applied twice. I looked through the frame types and the only ones that I think have some impact are:\n* Path_Challenge: A non duplication detecting receiver, will issue two Path_Response frames in response to a single PN. The sender of the Path_Challenge should not react badly to this.\n\nAlso, I haven't considered if there are any new requirements with the handshake packets and the interaction with TLS?\n\nI would note that AES-GCM do have this weakness (Fergueson  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf) that if one manage to know that one successfully forged a packet so that it passed the authentication verification, then one learns a number of bits of the authentication key, making the next forgery simpler. If it is possible to run such an attack by sending modified duplicates with forged authentication tags resulting in a response, then this can be exploited (https://link.springer.com/chapter/10.1007/978-3-319-31517-1_7). So QUIC will not use truncated tags, but QUIC connections may be very long lived in certain environments. Thus making it possible to maintain an attack for a sufficient time to possible have any result. Thus, I think for safety reasons packet duplication suppression after decryption should be mandatory to prevent this information leakage and not put that onto the individual frame types to consider if they will result in reveal of a successful forgery of a modified duplicate packet.\n\nI also noted that when we discussed this at the Interim it appeared that most, if not all except @kazuho was thinking that duplication suppression was expected in the receiver. If this is not required, then think the actual requirements on each frame type individually needs to be very clear.\n\nIt would be good to come to a conclusion on this issue so that we can determine what is needed for the ECN addition (#1372).\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398014741"}, "context_segments": []}, {"current_segment": {"sid": 1669, "labels": "InformationProviding,Answer,NeutralResponse,ProposeAction", "content": "\nMy argument is that doing either would be fine.\n"}, "context_segments": [{"sid": 1668, "labels": "Question,InformationProviding,Agreement,ProposeAction,ClarificationElicitation,Question,Agreement,ProposeAction,InformationProviding,InformationSeeking", "content": "\nSo, do I assume correctly, that you will still throw away packets that are several RTTs old, i.e. that have a PN number older than any state? Or do you generate an ACK for that old packet that is so old, and try to find if there is any unconsumed buffers to put any data in?\n\nYou might be right in that all existing frames have a behavior that if one applies it twice it already have the handling rules to suppress the duplicate or not cause any downside of being applied twice. I looked through the frame types and the only ones that I think have some impact are:\n* Path_Challenge: A non duplication detecting receiver, will issue two Path_Response frames in response to a single PN. The sender of the Path_Challenge should not react badly to this.\n\nAlso, I haven't considered if there are any new requirements with the handshake packets and the interaction with TLS?\n\nI would note that AES-GCM do have this weakness (Fergueson  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf) that if one manage to know that one successfully forged a packet so that it passed the authentication verification, then one learns a number of bits of the authentication key, making the next forgery simpler. If it is possible to run such an attack by sending modified duplicates with forged authentication tags resulting in a response, then this can be exploited (https://link.springer.com/chapter/10.1007/978-3-319-31517-1_7). So QUIC will not use truncated tags, but QUIC connections may be very long lived in certain environments. Thus making it possible to maintain an attack for a sufficient time to possible have any result. Thus, I think for safety reasons packet duplication suppression after decryption should be mandatory to prevent this information leakage and not put that onto the individual frame types to consider if they will result in reveal of a successful forgery of a modified duplicate packet.\n\nI also noted that when we discussed this at the Interim it appeared that most, if not all except @kazuho was thinking that duplication suppression was expected in the receiver. If this is not required, then think the actual requirements on each frame type individually needs to be very clear.\n\nIt would be good to come to a conclusion on this issue so that we can determine what is needed for the ECN addition (#1372).\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398014741"}]}, {"current_segment": {"sid": 1670, "labels": "InformationProviding,NeutralResponse,NeutralResponse", "content": "\nMy understanding is that the following statement in the transport draft section 5 covers this: \"All QUIC frames are idempotent. That is, a valid frame does not cause undesirable side effects or errors when received more than once.\"\n"}, "context_segments": [{"sid": 1668, "labels": "Question,InformationProviding,Agreement,ProposeAction,ClarificationElicitation,Question,Agreement,ProposeAction,InformationProviding,InformationSeeking", "content": "\nSo, do I assume correctly, that you will still throw away packets that are several RTTs old, i.e. that have a PN number older than any state? Or do you generate an ACK for that old packet that is so old, and try to find if there is any unconsumed buffers to put any data in?\n\nYou might be right in that all existing frames have a behavior that if one applies it twice it already have the handling rules to suppress the duplicate or not cause any downside of being applied twice. I looked through the frame types and the only ones that I think have some impact are:\n* Path_Challenge: A non duplication detecting receiver, will issue two Path_Response frames in response to a single PN. The sender of the Path_Challenge should not react badly to this.\n\nAlso, I haven't considered if there are any new requirements with the handshake packets and the interaction with TLS?\n\nI would note that AES-GCM do have this weakness (Fergueson  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf) that if one manage to know that one successfully forged a packet so that it passed the authentication verification, then one learns a number of bits of the authentication key, making the next forgery simpler. If it is possible to run such an attack by sending modified duplicates with forged authentication tags resulting in a response, then this can be exploited (https://link.springer.com/chapter/10.1007/978-3-319-31517-1_7). So QUIC will not use truncated tags, but QUIC connections may be very long lived in certain environments. Thus making it possible to maintain an attack for a sufficient time to possible have any result. Thus, I think for safety reasons packet duplication suppression after decryption should be mandatory to prevent this information leakage and not put that onto the individual frame types to consider if they will result in reveal of a successful forgery of a modified duplicate packet.\n\nI also noted that when we discussed this at the Interim it appeared that most, if not all except @kazuho was thinking that duplication suppression was expected in the receiver. If this is not required, then think the actual requirements on each frame type individually needs to be very clear.\n\nIt would be good to come to a conclusion on this issue so that we can determine what is needed for the ECN addition (#1372).\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398014741"}]}, {"current_segment": {"sid": 1671, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction", "content": "\nThis text is only in master and was not in -12, so I didn't see it at the time I wrote the ECN PR. I think the extensibility text probably needs an RFC 2119 requirement on that any new frame types needs to fulfill that requirement. But, to fulfill that for ECN, at least if there are no strict requirement on duplication suppression do requires the ECN specification to change. Either to do receiver side suppression of the ECN field value so that it doesn't matter, or change the encoding so that one handles the duplicated packets correctly.\n"}, "context_segments": [{"sid": 1668, "labels": "Question,InformationProviding,Agreement,ProposeAction,ClarificationElicitation,Question,Agreement,ProposeAction,InformationProviding,InformationSeeking", "content": "\nSo, do I assume correctly, that you will still throw away packets that are several RTTs old, i.e. that have a PN number older than any state? Or do you generate an ACK for that old packet that is so old, and try to find if there is any unconsumed buffers to put any data in?\n\nYou might be right in that all existing frames have a behavior that if one applies it twice it already have the handling rules to suppress the duplicate or not cause any downside of being applied twice. I looked through the frame types and the only ones that I think have some impact are:\n* Path_Challenge: A non duplication detecting receiver, will issue two Path_Response frames in response to a single PN. The sender of the Path_Challenge should not react badly to this.\n\nAlso, I haven't considered if there are any new requirements with the handshake packets and the interaction with TLS?\n\nI would note that AES-GCM do have this weakness (Fergueson  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf) that if one manage to know that one successfully forged a packet so that it passed the authentication verification, then one learns a number of bits of the authentication key, making the next forgery simpler. If it is possible to run such an attack by sending modified duplicates with forged authentication tags resulting in a response, then this can be exploited (https://link.springer.com/chapter/10.1007/978-3-319-31517-1_7). So QUIC will not use truncated tags, but QUIC connections may be very long lived in certain environments. Thus making it possible to maintain an attack for a sufficient time to possible have any result. Thus, I think for safety reasons packet duplication suppression after decryption should be mandatory to prevent this information leakage and not put that onto the individual frame types to consider if they will result in reveal of a successful forgery of a modified duplicate packet.\n\nI also noted that when we discussed this at the Interim it appeared that most, if not all except @kazuho was thinking that duplication suppression was expected in the receiver. If this is not required, then think the actual requirements on each frame type individually needs to be very clear.\n\nIt would be good to come to a conclusion on this issue so that we can determine what is needed for the ECN addition (#1372).\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398014741"}, {"sid": 1670, "labels": "InformationProviding,NeutralResponse,NeutralResponse", "content": "\nMy understanding is that the following statement in the transport draft section 5 covers this: \"All QUIC frames are idempotent. That is, a valid frame does not cause undesirable side effects or errors when received more than once.\"\n"}]}, {"current_segment": {"sid": 1672, "labels": "InformationProviding,ProposeAction,NeutralResponse,InformationProviding", "content": "\nThat's correct. Duplication suppression will be required if we adopt the encoding proposed in #1372.\n\nI am merely pointing out that #1372 is the only thing that requires suppression, and that we have a chance of dropping the requirement if we adopt an alternative encoding as we have been discussing in #1439.\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398057102"}, "context_segments": [{"sid": 1668, "labels": "Question,InformationProviding,Agreement,ProposeAction,ClarificationElicitation,Question,Agreement,ProposeAction,InformationProviding,InformationSeeking", "content": "\nSo, do I assume correctly, that you will still throw away packets that are several RTTs old, i.e. that have a PN number older than any state? Or do you generate an ACK for that old packet that is so old, and try to find if there is any unconsumed buffers to put any data in?\n\nYou might be right in that all existing frames have a behavior that if one applies it twice it already have the handling rules to suppress the duplicate or not cause any downside of being applied twice. I looked through the frame types and the only ones that I think have some impact are:\n* Path_Challenge: A non duplication detecting receiver, will issue two Path_Response frames in response to a single PN. The sender of the Path_Challenge should not react badly to this.\n\nAlso, I haven't considered if there are any new requirements with the handshake packets and the interaction with TLS?\n\nI would note that AES-GCM do have this weakness (Fergueson  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf) that if one manage to know that one successfully forged a packet so that it passed the authentication verification, then one learns a number of bits of the authentication key, making the next forgery simpler. If it is possible to run such an attack by sending modified duplicates with forged authentication tags resulting in a response, then this can be exploited (https://link.springer.com/chapter/10.1007/978-3-319-31517-1_7). So QUIC will not use truncated tags, but QUIC connections may be very long lived in certain environments. Thus making it possible to maintain an attack for a sufficient time to possible have any result. Thus, I think for safety reasons packet duplication suppression after decryption should be mandatory to prevent this information leakage and not put that onto the individual frame types to consider if they will result in reveal of a successful forgery of a modified duplicate packet.\n\nI also noted that when we discussed this at the Interim it appeared that most, if not all except @kazuho was thinking that duplication suppression was expected in the receiver. If this is not required, then think the actual requirements on each frame type individually needs to be very clear.\n\nIt would be good to come to a conclusion on this issue so that we can determine what is needed for the ECN addition (#1372).\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398014741"}, {"sid": 1670, "labels": "InformationProviding,NeutralResponse,NeutralResponse", "content": "\nMy understanding is that the following statement in the transport draft section 5 covers this: \"All QUIC frames are idempotent. That is, a valid frame does not cause undesirable side effects or errors when received more than once.\"\n"}, {"sid": 1671, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction", "content": "\nThis text is only in master and was not in -12, so I didn't see it at the time I wrote the ECN PR. I think the extensibility text probably needs an RFC 2119 requirement on that any new frame types needs to fulfill that requirement. But, to fulfill that for ECN, at least if there are no strict requirement on duplication suppression do requires the ECN specification to change. Either to do receiver side suppression of the ECN field value so that it doesn't matter, or change the encoding so that one handles the duplicated packets correctly.\n"}]}, {"current_segment": {"sid": 1673, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398053419"}, "context_segments": [{"sid": 1668, "labels": "Question,InformationProviding,Agreement,ProposeAction,ClarificationElicitation,Question,Agreement,ProposeAction,InformationProviding,InformationSeeking", "content": "\nSo, do I assume correctly, that you will still throw away packets that are several RTTs old, i.e. that have a PN number older than any state? Or do you generate an ACK for that old packet that is so old, and try to find if there is any unconsumed buffers to put any data in?\n\nYou might be right in that all existing frames have a behavior that if one applies it twice it already have the handling rules to suppress the duplicate or not cause any downside of being applied twice. I looked through the frame types and the only ones that I think have some impact are:\n* Path_Challenge: A non duplication detecting receiver, will issue two Path_Response frames in response to a single PN. The sender of the Path_Challenge should not react badly to this.\n\nAlso, I haven't considered if there are any new requirements with the handshake packets and the interaction with TLS?\n\nI would note that AES-GCM do have this weakness (Fergueson  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf) that if one manage to know that one successfully forged a packet so that it passed the authentication verification, then one learns a number of bits of the authentication key, making the next forgery simpler. If it is possible to run such an attack by sending modified duplicates with forged authentication tags resulting in a response, then this can be exploited (https://link.springer.com/chapter/10.1007/978-3-319-31517-1_7). So QUIC will not use truncated tags, but QUIC connections may be very long lived in certain environments. Thus making it possible to maintain an attack for a sufficient time to possible have any result. Thus, I think for safety reasons packet duplication suppression after decryption should be mandatory to prevent this information leakage and not put that onto the individual frame types to consider if they will result in reveal of a successful forgery of a modified duplicate packet.\n\nI also noted that when we discussed this at the Interim it appeared that most, if not all except @kazuho was thinking that duplication suppression was expected in the receiver. If this is not required, then think the actual requirements on each frame type individually needs to be very clear.\n\nIt would be good to come to a conclusion on this issue so that we can determine what is needed for the ECN addition (#1372).\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398014741"}, {"sid": 1670, "labels": "InformationProviding,NeutralResponse,NeutralResponse", "content": "\nMy understanding is that the following statement in the transport draft section 5 covers this: \"All QUIC frames are idempotent. That is, a valid frame does not cause undesirable side effects or errors when received more than once.\"\n"}]}, {"current_segment": {"sid": 1674, "labels": "InformationProviding,NeutralResponse", "content": "\nIf such attack is possible, it would be a vulnerability of the AEAD algorithm. It would be unrelated to if we detect duplicates. It is the task of the AEAD to provide authentication.\n"}, "context_segments": [{"sid": 1668, "labels": "Question,InformationProviding,Agreement,ProposeAction,ClarificationElicitation,Question,Agreement,ProposeAction,InformationProviding,InformationSeeking", "content": "\nSo, do I assume correctly, that you will still throw away packets that are several RTTs old, i.e. that have a PN number older than any state? Or do you generate an ACK for that old packet that is so old, and try to find if there is any unconsumed buffers to put any data in?\n\nYou might be right in that all existing frames have a behavior that if one applies it twice it already have the handling rules to suppress the duplicate or not cause any downside of being applied twice. I looked through the frame types and the only ones that I think have some impact are:\n* Path_Challenge: A non duplication detecting receiver, will issue two Path_Response frames in response to a single PN. The sender of the Path_Challenge should not react badly to this.\n\nAlso, I haven't considered if there are any new requirements with the handshake packets and the interaction with TLS?\n\nI would note that AES-GCM do have this weakness (Fergueson  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf) that if one manage to know that one successfully forged a packet so that it passed the authentication verification, then one learns a number of bits of the authentication key, making the next forgery simpler. If it is possible to run such an attack by sending modified duplicates with forged authentication tags resulting in a response, then this can be exploited (https://link.springer.com/chapter/10.1007/978-3-319-31517-1_7). So QUIC will not use truncated tags, but QUIC connections may be very long lived in certain environments. Thus making it possible to maintain an attack for a sufficient time to possible have any result. Thus, I think for safety reasons packet duplication suppression after decryption should be mandatory to prevent this information leakage and not put that onto the individual frame types to consider if they will result in reveal of a successful forgery of a modified duplicate packet.\n\nI also noted that when we discussed this at the Interim it appeared that most, if not all except @kazuho was thinking that duplication suppression was expected in the receiver. If this is not required, then think the actual requirements on each frame type individually needs to be very clear.\n\nIt would be good to come to a conclusion on this issue so that we can determine what is needed for the ECN addition (#1372).\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398014741"}]}, {"current_segment": {"sid": 1675, "labels": "InformationProviding,ProposeAction,NeutralResponse,ProposeAction,InformationProviding", "content": "\nMy understanding is that the discussion was based on our understanding (at that point) that duplication detection on the receiver is a prerequisite for ECN to work, and that we did not agree on how strictly we should require that to be implemented on the receiver.\n\nConsidering that, I think that it would be fair to argue for looking into if duplication detection is actually required, considering the fact that now we now that ECN can be supported without it.\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398041417"}, "context_segments": [{"sid": 1668, "labels": "Question,InformationProviding,Agreement,ProposeAction,ClarificationElicitation,Question,Agreement,ProposeAction,InformationProviding,InformationSeeking", "content": "\nSo, do I assume correctly, that you will still throw away packets that are several RTTs old, i.e. that have a PN number older than any state? Or do you generate an ACK for that old packet that is so old, and try to find if there is any unconsumed buffers to put any data in?\n\nYou might be right in that all existing frames have a behavior that if one applies it twice it already have the handling rules to suppress the duplicate or not cause any downside of being applied twice. I looked through the frame types and the only ones that I think have some impact are:\n* Path_Challenge: A non duplication detecting receiver, will issue two Path_Response frames in response to a single PN. The sender of the Path_Challenge should not react badly to this.\n\nAlso, I haven't considered if there are any new requirements with the handshake packets and the interaction with TLS?\n\nI would note that AES-GCM do have this weakness (Fergueson  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf) that if one manage to know that one successfully forged a packet so that it passed the authentication verification, then one learns a number of bits of the authentication key, making the next forgery simpler. If it is possible to run such an attack by sending modified duplicates with forged authentication tags resulting in a response, then this can be exploited (https://link.springer.com/chapter/10.1007/978-3-319-31517-1_7). So QUIC will not use truncated tags, but QUIC connections may be very long lived in certain environments. Thus making it possible to maintain an attack for a sufficient time to possible have any result. Thus, I think for safety reasons packet duplication suppression after decryption should be mandatory to prevent this information leakage and not put that onto the individual frame types to consider if they will result in reveal of a successful forgery of a modified duplicate packet.\n\nI also noted that when we discussed this at the Interim it appeared that most, if not all except @kazuho was thinking that duplication suppression was expected in the receiver. If this is not required, then think the actual requirements on each frame type individually needs to be very clear.\n\nIt would be good to come to a conclusion on this issue so that we can determine what is needed for the ECN addition (#1372).\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398014741"}]}, {"current_segment": {"sid": 1676, "labels": "InformationProviding,ProposeAction,InformationProviding", "content": "\nRekeying must happen before that point.\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398016919"}, "context_segments": [{"sid": 1668, "labels": "Question,InformationProviding,Agreement,ProposeAction,ClarificationElicitation,Question,Agreement,ProposeAction,InformationProviding,InformationSeeking", "content": "\nSo, do I assume correctly, that you will still throw away packets that are several RTTs old, i.e. that have a PN number older than any state? Or do you generate an ACK for that old packet that is so old, and try to find if there is any unconsumed buffers to put any data in?\n\nYou might be right in that all existing frames have a behavior that if one applies it twice it already have the handling rules to suppress the duplicate or not cause any downside of being applied twice. I looked through the frame types and the only ones that I think have some impact are:\n* Path_Challenge: A non duplication detecting receiver, will issue two Path_Response frames in response to a single PN. The sender of the Path_Challenge should not react badly to this.\n\nAlso, I haven't considered if there are any new requirements with the handshake packets and the interaction with TLS?\n\nI would note that AES-GCM do have this weakness (Fergueson  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/comments/CWC-GCM/Ferguson2.pdf) that if one manage to know that one successfully forged a packet so that it passed the authentication verification, then one learns a number of bits of the authentication key, making the next forgery simpler. If it is possible to run such an attack by sending modified duplicates with forged authentication tags resulting in a response, then this can be exploited (https://link.springer.com/chapter/10.1007/978-3-319-31517-1_7). So QUIC will not use truncated tags, but QUIC connections may be very long lived in certain environments. Thus making it possible to maintain an attack for a sufficient time to possible have any result. Thus, I think for safety reasons packet duplication suppression after decryption should be mandatory to prevent this information leakage and not put that onto the individual frame types to consider if they will result in reveal of a successful forgery of a modified duplicate packet.\n\nI also noted that when we discussed this at the Interim it appeared that most, if not all except @kazuho was thinking that duplication suppression was expected in the receiver. If this is not required, then think the actual requirements on each frame type individually needs to be very clear.\n\nIt would be good to come to a conclusion on this issue so that we can determine what is needed for the ECN addition (#1372).\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398014741"}]}, {"current_segment": {"sid": 1677, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious", "content": "\nOne thing we need to observe is that we won't be checking that the packet is a true duplicate, only that we've (probably) seen the (apparent) packet number before."}, "context_segments": []}, {"current_segment": {"sid": 1678, "labels": "InformationProviding,Agreement,Disagreement,NeutralResponse,InformationProviding", "content": "\n:+1:\n\nI would like to argue that, the QUIC protocol needs to and will have idempotency against receiving and processing duplicate packets, and that checking for a duplicate should not be a requirement of the protocol.\n\nRegarding the effect to ECN, I tend to think that processing of duplicates at an endpoint is an orthogonal issue to ECN, because both ECN-CE-marked and non-marked packets have the chance of binge dropped or duplicated.\n\nIMO, the requirement in ECN support should be to state that the ECN counters (i.e. ECN(0), ECN(1), ECN-CE) must be updated _prior to_ processing the packet (e.g., decryption, duplicate detection). Then, the sender can get the most information for adjusting the congestion control.\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-393716871"}, "context_segments": [{"sid": 1677, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious", "content": "\nOne thing we need to observe is that we won't be checking that the packet is a true duplicate, only that we've (probably) seen the (apparent) packet number before."}]}, {"current_segment": {"sid": 1679, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious,ProposeAction", "content": "\nAnother thing here is that packets that are ECN marked, but not authenticated, might be carrying a valid congestion signal, but we drop those too.  Think about the usual background radiation on the Internet that passes through a congested link on its way to you.  I don't think that we need to worry about that though."}, "context_segments": []}, {"current_segment": {"sid": 1680, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-393711328"}, "context_segments": []}, {"current_segment": {"sid": 1681, "labels": "InformationProviding,InformationProviding", "content": "Closed #1405 via #1624."}, "context_segments": []}, {"current_segment": {"sid": 1682, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#event-1781753754"}, "context_segments": []}, {"current_segment": {"sid": 1683, "labels": "InformationProviding,Disagreement,Question,InformationSeeking", "content": "@mikkelfj I am uncertain if that happens in a way that will prevent this attack. My assumption when this attack would be possible would be a low rate management connection where any rekeying based on number of legit sent packets may occur very infrequently. I don't find what the rekeying frequency requirements are, does someone have pointer?"}, "context_segments": []}, {"current_segment": {"sid": 1684, "labels": "InformationProviding,NeutralResponse", "content": "The problem with processing ECN before decryption is that you get double-counting if packets are duplicated.  And that happens.  The ECN PR specifically says that you need to detect and discard duplicates to avoid this."}, "context_segments": []}, {"current_segment": {"sid": 1685, "labels": "InformationProviding,Disagreement,Disagreement", "content": "\nYes. I am arguing against that statement, because I do not want to see endpoints being required to detect duplicates.\n"}, "context_segments": [{"sid": 1684, "labels": "InformationProviding,NeutralResponse", "content": "The problem with processing ECN before decryption is that you get double-counting if packets are duplicated.  And that happens.  The ECN PR specifically says that you need to detect and discard duplicates to avoid this."}]}, {"current_segment": {"sid": 1686, "labels": "InformationProviding,NeutralResponse,ExtensionOfPrevious", "content": "\nThe number of tested forges will be dependent on the number of forged duplicate packets the attacker manage to send without raising an alarm that the connection is under attack. But, if there are no such warnings then an attacker could potentially send a large number of attack packets without the target noticing other than it drops a lot of packets due to authentication failure. The attack only consumes PN and thus packets until rekeying when a successful forge has been accomplished."}, "context_segments": []}, {"current_segment": {"sid": 1687, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious,ProposeAction", "content": "\nTo my understanding the protection against this type of attack, is to prevent that a successful forge results in a response. If there are no general duplication protection then using a recently sent packet as attack packet is makes it simpler to cause a response. In fact the response to ECN-CE marks can actually be one thing that provides such a proof if some of the response discussed in #1372 would be allowed. Modifying the payload forging the authentication tag and setting the ECN bits to CE could then trigger an ACK on successful forge. For a connection that mostly idle that ACK will be a good signal for a forge. However, for this type of connection one can likely also target packets with a PING frame. Thus, also getting an ACK response on successful forge."}, "context_segments": []}, {"current_segment": {"sid": 1688, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398022746"}, "context_segments": []}, {"current_segment": {"sid": 1689, "labels": "InformationProviding,ProposeAction,NeutralResponse", "content": "If keys are not updated within about 2^32 packets one might might as well introduce a new plain text option because it would achieve the same with less overhead."}, "context_segments": []}, {"current_segment": {"sid": 1690, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious", "content": "\nAlso, the ECN feedback is based on counting of packets sent vs. those that are acknowledged, so counting ECN-marked chaff would inflate and likely distort the signal."}, "context_segments": []}, {"current_segment": {"sid": 1691, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious", "content": "\nThere is probably a way in which processing ECN signals before decryption could improve signal, but I think that's a different design to what has been proposed."}, "context_segments": []}, {"current_segment": {"sid": 1692, "labels": "InformationProviding,NeutralResponse,ProposeAction,Agreement,InformationProviding,ProposeAction", "content": "\nExactly.\n\nMy argument is based on my opinion that the current proposal is not optimal in sense that it loses the signal that was carried in one of the duplicated packets (one that is being delivered later), while requiring the endpoint to detect duplicates, which IMO is unnecessary.\n\nConsider the case where an endpoint receives two packets that are duplicate, one with the CE bit set and the other one without. The signal sent by the approach used in the PR will depend on the order of the delivery of the two packets. If the packet with the CE bit set is delivered first, the sender will notice more congestion than is should, because the fact that the second packet did not have the CE bit set will not be notified. If the packet without the CE bit set is delivered first, the sender will notice less congestion than it should, because the fact that the second packet did have the CE bit set will not be notified.\n\nThe reason why such issue exists is because you process the packet before updating the counter. I am saying that it might be worth reconsidering the approach, _especially if_ we are going to be required to detect duplicates on the endpoint as a byproduct of the approach.\n\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-393743048"}, "context_segments": [{"sid": 1691, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious", "content": "\nThere is probably a way in which processing ECN signals before decryption could improve signal, but I think that's a different design to what has been proposed."}]}, {"current_segment": {"sid": 1693, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-393731522"}, "context_segments": []}, {"current_segment": {"sid": 1694, "labels": "InformationProviding,InformationProviding", "content": "\n- https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.6.2\n- https://tlswg.github.io/tls13-spec/draft-ietf-tls-tls13.html#rfc.section.5.5\n- https://tlswg.github.io/tls13-spec/draft-ietf-tls-tls13.html#AEAD-LIMITS\n- http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf"}, "context_segments": []}, {"current_segment": {"sid": 1695, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398027221"}, "context_segments": []}, {"current_segment": {"sid": 1696, "labels": "InformationProviding,Agreement,Agreement,InformationProviding", "content": "But I think you are right that QUIC should much more prominently document such a rekeying requirement. For example that a key update MUST happen no later than after 2^32 packet exhanges or earlier if specific AEAD mode requires this (but such modes probably shouldn't be permitted)."}, "context_segments": []}, {"current_segment": {"sid": 1697, "labels": "InformationProviding,ProposeAction,ExtensionOfPrevious,ProposeAction", "content": "\nWhile some crypto modes could surve much more than 2^32 other modes would eventually fail badly (AES-GCM). By forcing an update no later than 2^32 it is easy to avoid implementation mistakes and for the peer to do a hard disconnect if keys are not updated. Silent crypto errors are really bad."}, "context_segments": []}, {"current_segment": {"sid": 1698, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1405#issuecomment-398031584"}, "context_segments": []}, {"current_segment": {"sid": 1721, "labels": "ContextSetting,InformationProviding,InformationProviding", "content": "\nThe document, along with other ballot positions, can be found here:\nhttps://datatracker.ietf.org/doc/draft-ietf-tls-tls13/"}, "context_segments": []}, {"current_segment": {"sid": 5903, "labels": "ContextSetting,Apologising,Apologising,InformationProviding,Social", "content": "\nsorry for jumping in...."}, "context_segments": [{"sid": 1721, "labels": "ContextSetting,InformationProviding,InformationProviding", "content": "\nThe document, along with other ballot positions, can be found here:\nhttps://datatracker.ietf.org/doc/draft-ietf-tls-tls13/"}]}, {"current_segment": {"sid": 1722, "labels": "ProposeAction,InformationProviding,ProposeAction", "content": "\nCOMMENT:"}, "context_segments": []}, {"current_segment": {"sid": 5904, "labels": "InformationProviding,ProposeAction,InformationProviding,UnderstandingNegative", "content": "\nI think one of the sources of confusion is that the attribute a=rtcp: is\nused once for specifying the destination port  and once for specifying a\nreceiving port, and in the same SDP (!). The destination port for RAMS-I\npackets sent by RS and the receiving port for RAMS-T. Which is also why\ndifferent port numbers are used for RAMS-T and -R packets."}, "context_segments": [{"sid": 1722, "labels": "ProposeAction,InformationProviding,ProposeAction", "content": "\nCOMMENT:"}]}, {"current_segment": {"sid": 1723, "labels": "InformationProviding,InformationProviding,ProposeAction", "content": "\nThere has clearly been a lot of work put into this. It's a surprisingly\nunderstandable document, given its length and the complexity of the subject. I\nam balloting yes, but I have a few minor comments and nits. None of these are\nshowstoppers, so please do with them as you will."}, "context_segments": []}, {"current_segment": {"sid": 5905, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,UnderstandingNegative", "content": "\nI think the use of a=rtcp: in SSM is the problem here. Or the fact that\nwe are mixing unicast and multicast, or both."}, "context_segments": [{"sid": 1723, "labels": "InformationProviding,InformationProviding,ProposeAction", "content": "\nThere has clearly been a lot of work put into this. It's a surprisingly\nunderstandable document, given its length and the complexity of the subject. I\nam balloting yes, but I have a few minor comments and nits. None of these are\nshowstoppers, so please do with them as you will."}]}, {"current_segment": {"sid": 1724, "labels": "InformationProviding,InformationProviding", "content": "\n*** Substantive Comments:"}, "context_segments": []}, {"current_segment": {"sid": 5906, "labels": "ExtensionOfPrevious,Social,InformationProviding", "content": "\nHope this helps,"}, "context_segments": [{"sid": 1724, "labels": "InformationProviding,InformationProviding", "content": "\n*** Substantive Comments:"}]}, {"current_segment": {"sid": 1725, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a74.1.2, first paragraph: \" When a client first connects to a server, it is\nREQUIRED to send the\nClientHello as its first message. \""}, "context_segments": []}, {"current_segment": {"sid": 5907, "labels": "InformationProviding", "content": "\nJLR"}, "context_segments": [{"sid": 1725, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a74.1.2, first paragraph: \" When a client first connects to a server, it is\nREQUIRED to send the\nClientHello as its first message. \""}]}, {"current_segment": {"sid": 1726, "labels": "InformationProviding,ContextSetting,InformationProviding,ProposeAction", "content": "\nIs that intended to prohibit the use of STARTTLS or similar application layer\npatterns? (To be clear, this is not an objection, just a clarification request.)"}, "context_segments": []}, {"current_segment": {"sid": 5908, "labels": "Social,Social", "content": "Hi Jose,"}, "context_segments": [{"sid": 1726, "labels": "InformationProviding,ContextSetting,InformationProviding,ProposeAction", "content": "\nIs that intended to prohibit the use of STARTTLS or similar application layer\npatterns? (To be clear, this is not an objection, just a clarification request.)"}]}, {"current_segment": {"sid": 1727, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a74.1.2, legacy_compression_methods: \"Note that TLS 1.3 servers might receive\nTLS 1.2 or prior\nClientHellos which contain other compression methods and MUST\nfollow the procedures for the appropriate prior version of TLS.\""}, "context_segments": []}, {"current_segment": {"sid": 5909, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "There is a new draft of the \"Rapid Acquisition of Multicast RTP Sessions\n(RAMS)\" draft available at\nhttp://www.ietf.org/internet-drafts/draft-versteeg-avt-rapid-synchroniza\ntion-for-rtp-03.txt\n<http://www.ietf.org/internet-drafts/draft-versteeg-avt-rapid-synchroniz\nation-for-rtp-03.txt>"}, "context_segments": [{"sid": 1727, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a74.1.2, legacy_compression_methods: \"Note that TLS 1.3 servers might receive\nTLS 1.2 or prior\nClientHellos which contain other compression methods and MUST\nfollow the procedures for the appropriate prior version of TLS.\""}]}, {"current_segment": {"sid": 1728, "labels": "InformationProviding,Agreement,Social,InformationProviding,NeutralResponse", "content": "> \u00a74.1.2, legacy_compression_methods: \"Note that TLS 1.3 servers might"}, "context_segments": [{"sid": 1727, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a74.1.2, legacy_compression_methods: \"Note that TLS 1.3 servers might receive\nTLS 1.2 or prior\nClientHellos which contain other compression methods and MUST\nfollow the procedures for the appropriate prior version of TLS.\""}, {"sid": 5909, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "There is a new draft of the \"Rapid Acquisition of Multicast RTP Sessions\n(RAMS)\" draft available at\nhttp://www.ietf.org/internet-drafts/draft-versteeg-avt-rapid-synchroniza\ntion-for-rtp-03.txt\n<http://www.ietf.org/internet-drafts/draft-versteeg-avt-rapid-synchroniz\nation-for-rtp-03.txt>"}]}, {"current_segment": {"sid": 5910, "labels": "InformationProviding", "content": "ynchronization-for-rtp-03.txt <http://www.ietf.org/internet-> drafts/draft-versteeg-avt-rapid-synchronization-for-rtp-03.txt>"}, "context_segments": [{"sid": 1727, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a74.1.2, legacy_compression_methods: \"Note that TLS 1.3 servers might receive\nTLS 1.2 or prior\nClientHellos which contain other compression methods and MUST\nfollow the procedures for the appropriate prior version of TLS.\""}, {"sid": 5909, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "There is a new draft of the \"Rapid Acquisition of Multicast RTP Sessions\n(RAMS)\" draft available at\nhttp://www.ietf.org/internet-drafts/draft-versteeg-avt-rapid-synchroniza\ntion-for-rtp-03.txt\n<http://www.ietf.org/internet-drafts/draft-versteeg-avt-rapid-synchroniz\nation-for-rtp-03.txt>"}, {"sid": 1728, "labels": "InformationProviding,Agreement,Social,InformationProviding,NeutralResponse", "content": "> \u00a74.1.2, legacy_compression_methods: \"Note that TLS 1.3 servers might"}]}, {"current_segment": {"sid": 1729, "labels": "ContextSetting,InformationProviding,ContextSetting", "content": "\nIs that intended to require TLS 1.3 servers to always be willing and able to\nnegotiate 1.2? \u00a74.2.1 has a similar assertion:"}, "context_segments": []}, {"current_segment": {"sid": 5911, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,StateDecision,InformationProviding,StateDecision", "content": "\nWe have incorporated the changes from the technical breakout session in\nSan Francisco. The major changes in this version of the draft include\n1- Changing the document title to avoid confusion with other ongoing\n\"synchronization\" drafts\n2- changing the message names to reflect the title change\n3- clarification of the RTCP message semantics, including changes to the\n\"Request\" and \"Inform\" messages\n4- additional description/motivation for the various message flows has\nbeen added\n5- RTP/RTCP muxing has been added"}, "context_segments": [{"sid": 1729, "labels": "ContextSetting,InformationProviding,ContextSetting", "content": "\nIs that intended to require TLS 1.3 servers to always be willing and able to\nnegotiate 1.2? \u00a74.2.1 has a similar assertion:"}]}, {"current_segment": {"sid": 1730, "labels": "InformationProviding,ExtensionOfPrevious,NeutralResponse", "content": "to negotiate 1.2? \u00a74.2.1"}, "context_segments": [{"sid": 1729, "labels": "ContextSetting,InformationProviding,ContextSetting", "content": "\nIs that intended to require TLS 1.3 servers to always be willing and able to\nnegotiate 1.2? \u00a74.2.1 has a similar assertion:"}, {"sid": 5911, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,StateDecision,InformationProviding,StateDecision", "content": "\nWe have incorporated the changes from the technical breakout session in\nSan Francisco. The major changes in this version of the draft include\n1- Changing the document title to avoid confusion with other ongoing\n\"synchronization\" drafts\n2- changing the message names to reflect the title change\n3- clarification of the RTCP message semantics, including changes to the\n\"Request\" and \"Inform\" messages\n4- additional description/motivation for the various message flows has\nbeen added\n5- RTP/RTCP muxing has been added"}]}, {"current_segment": {"sid": 1731, "labels": "InformationProviding,ClarificationElicitation,ExtensionOfPrevious,ClarificationElicitation,InformationSeeking", "content": "\n\"If this extension is not present, servers which are compliant with\nthis specification MUST negotiate TLS 1.2 or prior as specified in\n[RFC5246], even if ClientHello.legacy_version is 0x0304 or later.\""}, "context_segments": []}, {"current_segment": {"sid": 5912, "labels": "InformationProviding,ExtensionOfPrevious,StateDecision,InformationProviding", "content": "\nWe hope to make this a Working Group item, and will change the name of\nthe draft to avoid conflicts with other \"synchronization\" drafts at that\ntime."}, "context_segments": [{"sid": 1731, "labels": "InformationProviding,ClarificationElicitation,ExtensionOfPrevious,ClarificationElicitation,InformationSeeking", "content": "\n\"If this extension is not present, servers which are compliant with\nthis specification MUST negotiate TLS 1.2 or prior as specified in\n[RFC5246], even if ClientHello.legacy_version is 0x0304 or later.\""}]}, {"current_segment": {"sid": 1732, "labels": "ContextSetting,InformationProviding", "content": "\nBut \u00a74.2.3 says:"}, "context_segments": []}, {"current_segment": {"sid": 5913, "labels": "InformationProviding", "content": "\nBill VerSteeg"}, "context_segments": [{"sid": 1732, "labels": "ContextSetting,InformationProviding", "content": "\nBut \u00a74.2.3 says:"}]}, {"current_segment": {"sid": 1733, "labels": "InformationProviding,ContextSetting,Question,ExtensionOfPrevious,Question,InformationSeeking", "content": "\n\"Note that TLS 1.2 defines this extension differently.  TLS 1.3\nimplementations willing to negotiate TLS 1.2 MUST behave in\naccordance with the requirements of [RFC5246] when negotiating that\nversion.\""}, "context_segments": []}, {"current_segment": {"sid": 5914, "labels": "Social,Social", "content": "Hi,"}, "context_segments": [{"sid": 1733, "labels": "InformationProviding,ContextSetting,Question,ExtensionOfPrevious,Question,InformationSeeking", "content": "\n\"Note that TLS 1.2 defines this extension differently.  TLS 1.3\nimplementations willing to negotiate TLS 1.2 MUST behave in\naccordance with the requirements of [RFC5246] when negotiating that\nversion.\""}]}, {"current_segment": {"sid": 1734, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n... which seems inconsistent (noting that this paragraph talks about\n\"implementations\" rather than \"servers\", so perhaps there's a subtle difference?"}, "context_segments": []}, {"current_segment": {"sid": 5915, "labels": "InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationProviding", "content": "Ali,\nThe example SDP is syntactically correct but it does not say that the\nrtp/rtcp mux will be used and it does not give the information to where the\nunicast stream will be sent when the RR sends a RAMS-R."}, "context_segments": [{"sid": 1734, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n... which seems inconsistent (noting that this paragraph talks about\n\"implementations\" rather than \"servers\", so perhaps there's a subtle difference?"}]}, {"current_segment": {"sid": 5916, "labels": "InformationProviding,Answer,ContextSetting,InformationProviding,Agreement,StateDecision", "content": "\nTo my knowledge, the first line in the following SDP tells the RRs on which port they will receive the retransmission/burst packets.\n\nm=video 41002 RTP/AVPF 99\ni=Unicast Retransmission Stream #2 (Ret. and Rapid Acq. Support)\nc=IN IP4 192.0.2.1\na=rtpmap:99 rtx/90000\na=rtcp:41003\na=fmtp:99 apt=98; rtx-time=5000\na=mid:4\n\nThere is a typo, you are right. That \"a=recvonly\" line should only exist in the SDP sent to RRs. In the SDP sent to RS, we should rather have \"a=sendonly\". I will make this correction in the next version.\n\nThe feedback target for the SSM session and the RTCP port for the retransmission session are also defined in the SDP.\n\nHope this clarifies.\n\nBR,\n-acbegen\n"}, "context_segments": [{"sid": 1734, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n... which seems inconsistent (noting that this paragraph talks about\n\"implementations\" rather than \"servers\", so perhaps there's a subtle difference?"}, {"sid": 5915, "labels": "InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationProviding", "content": "Ali,\nThe example SDP is syntactically correct but it does not say that the\nrtp/rtcp mux will be used and it does not give the information to where the\nunicast stream will be sent when the RR sends a RAMS-R."}]}, {"current_segment": {"sid": 1735, "labels": "ContextSetting,ExtensionOfPrevious,InformationProviding", "content": "\n\u00a74.2.1.1: The section is marked for removal. Do you expect that RFC\nimplementations will ever need to interop with draft implementations? If so,\nthe information in this section may continue to be useful for some time."}, "context_segments": []}, {"current_segment": {"sid": 5917, "labels": "Question,InformationProviding,ExtensionOfPrevious,UnderstandingNegative,Question,InformationProviding,InformationSeeking", "content": "\nI am not sure why the unicast stream m-line has a port number with an\nattribute of recvonly. What is the use case for that. The only information\nthat the RR will need is the RTCP port on the RS to where to send the RAMS-R\nmessage."}, "context_segments": [{"sid": 1735, "labels": "ContextSetting,ExtensionOfPrevious,InformationProviding", "content": "\n\u00a74.2.1.1: The section is marked for removal. Do you expect that RFC\nimplementations will ever need to interop with draft implementations? If so,\nthe information in this section may continue to be useful for some time."}]}, {"current_segment": {"sid": 1736, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n\u00a7D.5: This section has a lot of normative requirements that seem important. I\nwonder why it has been relegated to an appendix."}, "context_segments": []}, {"current_segment": {"sid": 5918, "labels": "InformationProviding,Agreement,ProposeAction,InformationProviding,ProposeAction", "content": "Roni-\n\nYes, the document needs updating in this respect. We have two broad\noptions which need to be described in detail.\n\nThe method that I have been assuming does use muxing. The RS sends the\nunicast burst back to the UDP port number on the RR that sent the\nRAMS-R. This allows transparent operation through NAT. There is a single\nUDP port, and the transaction is initiated by the \"client\", so it is NAT\nfriendly.\n\nThere are quite a few ways we could handle the case in which muxing is\nnot used. We could add a parameter to the RAMS-R, use another RTCP\npacket in the same compound packet, define the port numbers as a\nrelationship to the opened port (not attractive), or define something in\nthe SDP (also not attractive). I personally like the \"RAMS-R optional\nfield\" approach, but I think this should be a topic that we consider in\ndetail once we have a WG item.\n"}, "context_segments": [{"sid": 1736, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n\u00a7D.5: This section has a lot of normative requirements that seem important. I\nwonder why it has been relegated to an appendix."}]}, {"current_segment": {"sid": 1737, "labels": "ExtensionOfPrevious,InformationProviding", "content": "> \u00a7D.5: This section has a lot of normative requirements that seem"}, "context_segments": [{"sid": 1736, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n\u00a7D.5: This section has a lot of normative requirements that seem important. I\nwonder why it has been relegated to an appendix."}, {"sid": 5918, "labels": "InformationProviding,Agreement,ProposeAction,InformationProviding,ProposeAction", "content": "Roni-\n\nYes, the document needs updating in this respect. We have two broad\noptions which need to be described in detail.\n\nThe method that I have been assuming does use muxing. The RS sends the\nunicast burst back to the UDP port number on the RR that sent the\nRAMS-R. This allows transparent operation through NAT. There is a single\nUDP port, and the transaction is initiated by the \"client\", so it is NAT\nfriendly.\n\nThere are quite a few ways we could handle the case in which muxing is\nnot used. We could add a parameter to the RAMS-R, use another RTCP\npacket in the same compound packet, define the port numbers as a\nrelationship to the opened port (not attractive), or define something in\nthe SDP (also not attractive). I personally like the \"RAMS-R optional\nfield\" approach, but I think this should be a topic that we consider in\ndetail once we have a WG item.\n"}]}, {"current_segment": {"sid": 5919, "labels": "InformationProviding", "content": "\nbvs\n"}, "context_segments": [{"sid": 1736, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n\u00a7D.5: This section has a lot of normative requirements that seem important. I\nwonder why it has been relegated to an appendix."}]}, {"current_segment": {"sid": 1738, "labels": "Answer,InformationProviding,Answer", "content": "> *** Editorial Comments and nits:\n> \u00a72: \"If (EC)DHE key establishment\n>   is in use, then the ServerHello contains a \"key_share\" extension with\n>   the server\u2019s ephemeral Diffie-Hellman share which MUST be in the same\n>   group as one of the client\u2019s shares. \"\n> missing comma prior to \"which\u201d."}, "context_segments": [{"sid": 1736, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n\u00a7D.5: This section has a lot of normative requirements that seem important. I\nwonder why it has been relegated to an appendix."}, {"sid": 5919, "labels": "InformationProviding", "content": "\nbvs\n"}]}, {"current_segment": {"sid": 1739, "labels": "Question,ProposeAction,ExtensionOfPrevious,Question,InformationProviding,Disagreement,InformationSeeking", "content": "\n*** Editorial Comments and nits:"}, "context_segments": []}, {"current_segment": {"sid": 5920, "labels": "Social,Social", "content": "Hi all,"}, "context_segments": [{"sid": 1739, "labels": "Question,ProposeAction,ExtensionOfPrevious,Question,InformationProviding,Disagreement,InformationSeeking", "content": "\n*** Editorial Comments and nits:"}]}, {"current_segment": {"sid": 1740, "labels": "Question,ContextSetting,InformationProviding,Question,InformationProviding,InformationSeeking", "content": "\n\u00a72: \"If (EC)DHE key establishment\nis in use, then the ServerHello contains a \"key_share\" extension with\nthe server\u2019s ephemeral Diffie-Hellman share which MUST be in the same\ngroup as one of the client\u2019s shares. \""}, "context_segments": []}, {"current_segment": {"sid": 5921, "labels": "Question,InformationProviding,NeutralResponse,Question,InformationProviding,InformationSeeking", "content": "\nWe have separate RTCP ports for the SSM session and the unicast session. Why is it a problem?"}, "context_segments": [{"sid": 1740, "labels": "Question,ContextSetting,InformationProviding,Question,InformationProviding,InformationSeeking", "content": "\n\u00a72: \"If (EC)DHE key establishment\nis in use, then the ServerHello contains a \"key_share\" extension with\nthe server\u2019s ephemeral Diffie-Hellman share which MUST be in the same\ngroup as one of the client\u2019s shares. \""}]}, {"current_segment": {"sid": 5922, "labels": "Question,ClarificationElicitation,InformationProviding,Answer,ContextSetting,ProposeAction,Question,ClarificationElicitation,InformationProviding,Answer,InformationSeeking", "content": "\nIn line 19 you say you specify the dst port for RMS-I (41003), on RR. And you say that would also be the port where the RR sends RMS-T, on RS. That is mixing the semantics of a=rtcp for SSM (listening port at Feedback Target = mcast RTCP dst port) and those of RFC 3605 (dst port). In other words, you are implicitly assuming that specifies symmetric RTCP...no?\n\nAnother thing that was mentioned already:  RMS-T is not sent to same port as RMS-R; is it not the same RTCP session ? Or is this muxing desired? why?\n\nJLR\n"}, "context_segments": [{"sid": 1740, "labels": "Question,ContextSetting,InformationProviding,Question,InformationProviding,InformationSeeking", "content": "\n\u00a72: \"If (EC)DHE key establishment\nis in use, then the ServerHello contains a \"key_share\" extension with\nthe server\u2019s ephemeral Diffie-Hellman share which MUST be in the same\ngroup as one of the client\u2019s shares. \""}, {"sid": 5921, "labels": "Question,InformationProviding,NeutralResponse,Question,InformationProviding,InformationSeeking", "content": "\nWe have separate RTCP ports for the SSM session and the unicast session. Why is it a problem?"}]}, {"current_segment": {"sid": 1741, "labels": "InformationProviding,ContextSetting,InformationSeeking,InformationProviding,ProposeAction", "content": "\nmissing comma prior to \"which\"."}, "context_segments": []}, {"current_segment": {"sid": 5923, "labels": "InformationProviding,ContextSetting,InformationProviding,ContextSetting", "content": "\nThe slightly modified SDP for the next version is below:"}, "context_segments": [{"sid": 1741, "labels": "InformationProviding,ContextSetting,InformationSeeking,InformationProviding,ProposeAction", "content": "\nmissing comma prior to \"which\"."}]}, {"current_segment": {"sid": 5924, "labels": "InformationProviding", "content": "1>         a=group:FID 3 4\n2>         a=rtcp-unicast:rsi\n3>         m=video 41000 RTP/AVPF 98\n4>         i=Primary Multicast Stream #2\n5>         c=IN IP4 233.252.0.2/255\n6>         a=source-filter: incl IN IP4 233.252.0.2 192.0.2.2\n7>         a=recvonly\n8>         a=rtpmap:98 MP2T/90000\n9>         a=rtcp:41001 IN IP4 192.0.2.1\n10>         a=rtcp-fb:98 nack\n11>         a=rtcp-fb:98 nack ssli\n12>         a=ssrc:123321 cname:iptv-ch32@rams.example.com\n13>         a=mid:3\n14>         m=video 41002 RTP/AVPF 99\n15>         i=Unicast Retransmission Stream #2 (Ret. and Rapid"}, "context_segments": [{"sid": 1741, "labels": "InformationProviding,ContextSetting,InformationSeeking,InformationProviding,ProposeAction", "content": "\nmissing comma prior to \"which\"."}, {"sid": 5923, "labels": "InformationProviding,ContextSetting,InformationProviding,ContextSetting", "content": "\nThe slightly modified SDP for the next version is below:"}]}, {"current_segment": {"sid": 1742, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a74.1.1: \"Note that if the PSK can be used without (EC)DHE then non-\noverlap in the \"supported_groups\" parameters need not be fatal, as it\nis in the non-PSK case discussed in the previous paragraph.\""}, "context_segments": []}, {"current_segment": {"sid": 5925, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\na=group:FID 3 4\na=rtcp-unicast:rsi\nm=video 41000 RTP/AVPF 98\ni=Primary Multicast Stream #2\nc=IN IP4 233.252.0.2/255\na=source-filter: incl IN IP4 233.252.0.2 192.0.2.2\na=recvonly\na=rtpmap:98 MP2T/90000\na=rtcp:41001 IN IP4 192.0.2.1\na=rtcp-fb:98 nack\na=rtcp-fb:98 nack ssli\na=ssrc:123321 cname:iptv-ch32@rams.example.com\na=mid:3\nm=video 41002 RTP/AVPF 99\ni=Unicast Retransmission Stream #2 (Ret. and Rapid Acq. Support)\nc=IN IP4 192.0.2.1\na=recvonly\na=rtpmap:99 rtx/90000\na=rtcp:41003\na=fmtp:99 apt=98; rtx-time=5000\na=mid:4"}, "context_segments": [{"sid": 1742, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a74.1.1: \"Note that if the PSK can be used without (EC)DHE then non-\noverlap in the \"supported_groups\" parameters need not be fatal, as it\nis in the non-PSK case discussed in the previous paragraph.\""}]}, {"current_segment": {"sid": 1743, "labels": "ContextSetting,InformationProviding", "content": "\nI read \"need not be fatal\" to mean that it may still be fatal at times. Is that\nthe intent?"}, "context_segments": []}, {"current_segment": {"sid": 5926, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nThis is the SDP we send to RR. For RS, a=recvonly will be a=sendonly."}, "context_segments": [{"sid": 1743, "labels": "ContextSetting,InformationProviding", "content": "\nI read \"need not be fatal\" to mean that it may still be fatal at times. Is that\nthe intent?"}]}, {"current_segment": {"sid": 1744, "labels": "Answer,ContextSetting,Disagreement,InformationProviding,Answer,Disagreement", "content": "> \u00a74.1.1: \"Note that if the PSK can be used without (EC)DHE then non-\n>   overlap in the \"supported_groups\" parameters need not be fatal, as it\n>   is in the non-PSK case discussed in the previous paragraph.\"\n> I read \"need not be fatal\" to mean that it may still be fatal at times. Is that\n> the intent?"}, "context_segments": [{"sid": 1743, "labels": "ContextSetting,InformationProviding", "content": "\nI read \"need not be fatal\" to mean that it may still be fatal at times. Is that\nthe intent?"}, {"sid": 5926, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nThis is the SDP we send to RR. For RS, a=recvonly will be a=sendonly."}]}, {"current_segment": {"sid": 1745, "labels": "ProposeAction,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n\u00a711: The IANA considerations have a number of constructions similar to \"SHALL\nupdate/has updated\". Is that text expected to collapse to \"has updated\" at some\npoint?"}, "context_segments": []}, {"current_segment": {"sid": 5927, "labels": "InformationProviding", "content": "\n-acbegen"}, "context_segments": [{"sid": 1745, "labels": "ProposeAction,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n\u00a711: The IANA considerations have a number of constructions similar to \"SHALL\nupdate/has updated\". Is that text expected to collapse to \"has updated\" at some\npoint?"}]}, {"current_segment": {"sid": 1746, "labels": "NeutralResponse,InformationProviding,Answer", "content": "> \u00a711: The IANA considerations have a number of constructions similar to \"SHALL\n> update/has updated\". Is that text expected to collapse to \"has updated\" at some\n> point?"}, "context_segments": [{"sid": 1745, "labels": "ProposeAction,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n\u00a711: The IANA considerations have a number of constructions similar to \"SHALL\nupdate/has updated\". Is that text expected to collapse to \"has updated\" at some\npoint?"}, {"sid": 5927, "labels": "InformationProviding", "content": "\n-acbegen"}]}, {"current_segment": {"sid": 5928, "labels": "InformationProviding,Disagreement,ProposeAction", "content": "\nHi,\n\nI think that the current draft does not give a description of a system\nthat works since there is no text explaining how the RS knows the\nunicast transport address on the RR to where to send the stream.\n\nIf you mandate the use of RTP/RTCP mux it should say so otherwise the\nRAMS-R should have an optional parameter that supplies this information\nand a flag for using RTP/RTCP mux.\n\nThanks\n\nRoni Even\n"}, "context_segments": [{"sid": 1745, "labels": "ProposeAction,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n\u00a711: The IANA considerations have a number of constructions similar to \"SHALL\nupdate/has updated\". Is that text expected to collapse to \"has updated\" at some\npoint?"}]}, {"current_segment": {"sid": 1747, "labels": "NeutralResponse,InformationProviding,NeutralResponse", "content": "Sean Turner  <SIGNATURES AND QUOTES>"}, "context_segments": [{"sid": 1745, "labels": "ProposeAction,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n\u00a711: The IANA considerations have a number of constructions similar to \"SHALL\nupdate/has updated\". Is that text expected to collapse to \"has updated\" at some\npoint?"}, {"sid": 5928, "labels": "InformationProviding,Disagreement,ProposeAction", "content": "\nHi,\n\nI think that the current draft does not give a description of a system\nthat works since there is no text explaining how the RS knows the\nunicast transport address on the RR to where to send the stream.\n\nIf you mandate the use of RTP/RTCP mux it should say so otherwise the\nRAMS-R should have an optional parameter that supplies this information\nand a flag for using RTP/RTCP mux.\n\nThanks\n\nRoni Even\n"}]}, {"current_segment": {"sid": 5929, "labels": "InformationSeeking,ContextSetting,ProposeAction,ProposeAction,InformationProviding", "content": "Ali,\nCan you please write three addresses from this strange SDP."}, "context_segments": [{"sid": 1745, "labels": "ProposeAction,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n\u00a711: The IANA considerations have a number of constructions similar to \"SHALL\nupdate/has updated\". Is that text expected to collapse to \"has updated\" at some\npoint?"}]}, {"current_segment": {"sid": 1748, "labels": "InformationProviding,InformationProviding", "content": "Eric Rescorla  <SIGNATURES AND QUOTES>"}, "context_segments": [{"sid": 1745, "labels": "ProposeAction,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n\u00a711: The IANA considerations have a number of constructions similar to \"SHALL\nupdate/has updated\". Is that text expected to collapse to \"has updated\" at some\npoint?"}, {"sid": 5929, "labels": "InformationSeeking,ContextSetting,ProposeAction,ProposeAction,InformationProviding", "content": "Ali,\nCan you please write three addresses from this strange SDP."}]}, {"current_segment": {"sid": 1749, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a7E.2.1: [BDFKPPRSZZ16]  : Best citation anchor evar"}, "context_segments": []}, {"current_segment": {"sid": 5930, "labels": "InformationSeeking,ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\n1. The address and port of multicast"}, "context_segments": [{"sid": 1749, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a7E.2.1: [BDFKPPRSZZ16]  : Best citation anchor evar"}]}, {"current_segment": {"sid": 1750, "labels": "NeutralResponse,InformationProviding", "content": "Ben Campbell  <SIGNATURES AND QUOTES>"}, "context_segments": [{"sid": 1749, "labels": "ContextSetting,InformationProviding", "content": "\n\u00a7E.2.1: [BDFKPPRSZZ16]  : Best citation anchor evar"}, {"sid": 5930, "labels": "InformationSeeking,ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\n1. The address and port of multicast"}]}, {"current_segment": {"sid": 1751, "labels": "ClarificationElicitation,ExtensionOfPrevious,ClarificationElicitation,InformationSeeking,InformationProviding", "content": "Ben Campbell  <SIGNATURES AND QUOTES>"}, "context_segments": []}, {"current_segment": {"sid": 5931, "labels": "InformationSeeking,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n2. The address and port of the RS where the RTCP FB should go to"}, "context_segments": [{"sid": 1751, "labels": "ClarificationElicitation,ExtensionOfPrevious,ClarificationElicitation,InformationSeeking,InformationProviding", "content": "Ben Campbell  <SIGNATURES AND QUOTES>"}]}, {"current_segment": {"sid": 5932, "labels": "InformationSeeking,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n3. The address and port on the RR where the unicast stream should be sent to"}, "context_segments": []}, {"current_segment": {"sid": 5933, "labels": "InformationProviding", "content": "Bill,"}, "context_segments": []}, {"current_segment": {"sid": 5934, "labels": "Answer,ContextSetting,InformationProviding", "content": "Here is the SDP."}, "context_segments": []}, {"current_segment": {"sid": 5935, "labels": "InformationProviding,InformationProviding", "content": "\nI think that the current draft does not give a description of a system that\nworks since there is no text explaining how the RS knows the unicast\ntransport address on the RR to where to send the stream."}, "context_segments": []}, {"current_segment": {"sid": 5936, "labels": "ClarificationElicitation,ClarificationElicitation,InformationSeeking", "content": "\nWhat do you mean by \"a system that works\"?\n"}, "context_segments": [{"sid": 5935, "labels": "InformationProviding,InformationProviding", "content": "\nI think that the current draft does not give a description of a system that\nworks since there is no text explaining how the RS knows the unicast\ntransport address on the RR to where to send the stream."}]}, {"current_segment": {"sid": 5937, "labels": "InformationSeeking,InformationProviding,NeutralResponse,StateDecision,InformationProviding,StateDecision", "content": "\nOnce RS receives the request packet from an RR, RS knows its address. Ports are defined in the SDP. If you are asking about \"NAT\" issues, we have a section for it, and we plan to complete it as we move forward. It is not as critical as the other parts for now.\n"}, "context_segments": [{"sid": 5935, "labels": "InformationProviding,InformationProviding", "content": "\nI think that the current draft does not give a description of a system that\nworks since there is no text explaining how the RS knows the unicast\ntransport address on the RR to where to send the stream."}]}, {"current_segment": {"sid": 5938, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "\nIf you mandate the use of RTP/RTCP mux it should say so otherwise the RAMS-R\nshould have an optional parameter that supplies this information and a flag\nfor using RTP/RTCP mux."}, "context_segments": []}, {"current_segment": {"sid": 5939, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,ProposeAction", "content": "\nIMO, we cannot mandate muxing as it is not required to make RAMS work. If muxing is supported, the SDP should reflect it.\n\nBR,\n-acbegen\n"}, "context_segments": [{"sid": 5938, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "\nIf you mandate the use of RTP/RTCP mux it should say so otherwise the RAMS-R\nshould have an optional parameter that supplies this information and a flag\nfor using RTP/RTCP mux."}]}, {"current_segment": {"sid": 5940, "labels": "Agreement,ProposeAction,InformationProviding,ProposeAction", "content": "\nWe can certainly add more detailed explanation to the SDP section. But, let's focus more on the draft rather than a single SDP example that it currently has.\n"}, "context_segments": [{"sid": 5938, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "\nIf you mandate the use of RTP/RTCP mux it should say so otherwise the RAMS-R\nshould have an optional parameter that supplies this information and a flag\nfor using RTP/RTCP mux."}, {"sid": 5939, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,ProposeAction", "content": "\nIMO, we cannot mandate muxing as it is not required to make RAMS work. If muxing is supported, the SDP should reflect it.\n\nBR,\n-acbegen\n"}]}, {"current_segment": {"sid": 5941, "labels": "Thanking,Thanking,Social", "content": "\nThanks"}, "context_segments": []}, {"current_segment": {"sid": 5942, "labels": "InformationProviding,ContextSetting,ProposeAction,InformationProviding,Disagreement", "content": "Ali,\nI think you get it wrong, this SDP is from the RS and not the RR so the RS\ncannot specify to which address it will send it can only specify to which\naddress it can receive RTP stream. In this SDP the relevant information is\nthat the request for retransmission will be sent by the RR to port 41003"}, "context_segments": []}, {"current_segment": {"sid": 5943, "labels": "InformationProviding,NeutralResponse,ContextSetting,InformationProviding", "content": "This is a part of an example SDP sent to RS and RR in a SAP announcement, for example. So, the SDP describes what both parties should do (RR cannot say that he wants to receive this multicast on its favorite port). The individual SDPs sent to RR or RS may include other portions of descriptions that will contain specific information."}, "context_segments": []}, {"current_segment": {"sid": 5944, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "Ali,\nI looked at RTSP\nhttp://tools.ietf.org/html/draft-ietf-mmusic-rfc2326bis-20#appendix-D"}, "context_segments": []}, {"current_segment": {"sid": 5945, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nD.1.2.  Media Streams"}, "context_segments": []}, {"current_segment": {"sid": 5946, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ProposeAction", "content": "\nThe \"m=\" field is used to enumerate the streams.  It is expected that\nall the specified streams will be rendered with appropriate\nsynchronization.  If the session is over multicast, the port number\nindicated SHOULD be used for reception.  The client MAY try to\noverride the destination port, through the Transport header.  The\nservers MAY allow this, the response will indicate if allowed or not.\nIf the session is unicast, the port numbers are the ones RECOMMENDED\nby the server to the client, about which receiver ports to use; the\nclient MUST still include its receiver ports in its SETUP request.\nThe client MAY ignore this recommendation.  If the server has no\npreference, it SHOULD set the port number value to zero."}, "context_segments": []}, {"current_segment": {"sid": 5947, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\nNote that the client has the choice on which port to receive the unicast\nstream, this is why there should be such a parameter in RAMS-R"}, "context_segments": []}, {"current_segment": {"sid": 5948, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nAlso"}, "context_segments": []}, {"current_segment": {"sid": 5949, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\n\" D.1.8.  Connection Information"}, "context_segments": []}, {"current_segment": {"sid": 5950, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ProposeAction", "content": "\nIn SDP, the \"c=\" field contains the destination address for the media\nstream.  For on-demand unicast streams and some multicast streams,\nthe destination address MAY be specified by the client via the SETUP\nrequest, thus overriding any specified address.  To identify streams\nwithout a fixed destination address, where the client is required to\nspecify a destination address, the \"c=\" field SHOULD be set to a null\nvalue.  For addresses of type \"IP4\", this value MUST be \"0.0.0.0\",\nand for type \"IP6\", this value MUST be \"0:0:0:0:0:0:0:0\" (can also be\nwritten as \"::\"), i.e. the unspecified address according to RFC 4291\n[RFC4291].\""}, "context_segments": []}, {"current_segment": {"sid": 5951, "labels": "ContextSetting,InformationProviding", "content": "Inline.\n"}, "context_segments": []}, {"current_segment": {"sid": 5952, "labels": "InformationProviding", "content": ">         m=video 41000 RTP/AVPF 98\n>         i=Primary Multicast Stream #2\n>         c=IN IP4 224.1.1.2/255\n>         a=source-filter: incl IN IP4 224.1.1.2 192.0.2.2\n> Source (192.0.2.2) sends the rtp packets to the multicast\n> group (224.1.1.2)\n> with a dest port 41000.\n>         a=rtpmap:98 MP2T/90000\n>         a=rtcp:41001 IN IP4 192.0.2.1\n> The feedback target (RS) address for this SSM session is\n> 192.0.2.1 and its\n> port is 41001. This is the address/port where RR sends the RAMS-R, or\n> receiver reports for the SSM session.\n>         a=rtcp-fb:98 nack\n>         a=rtcp-fb:98 nack ssli\n>         a=ssrc:123321 cname:iptv-ch32@rams.example.com\n>         a=mid:3\n>         m=video 41002 RTP/AVPF 99\n> The retransmission packets go to port 41002. This is the port\n> RRs listen to\n> for retransmission and RAMS.\n> Roni E: This implies that the multicast source defines the\n> port that all\n> clients MUST use to receive the unicast information from the\n> Burst source."}, "context_segments": []}, {"current_segment": {"sid": 5953, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "\nNow the expectation here is for the address of the stream described by the\nport in the m-line, I do not see any other attribute. Also look at the above\ntext from RTSP. The RS does not know the IP address on the RR to where to\nsend the RTP unicast repair stream. If you assume it is to the IP address\nfrom where the RTCP RAMS-R came from this is not mandated that the client\nwill have such implementation. Furthermore the address that the RS will see\nin the received RTCP RAMS-R packet may have been change by a NAT or SBC."}, "context_segments": []}, {"current_segment": {"sid": 5954, "labels": "InformationProviding,Agreement,ProposeAction,InformationProviding,ProposeAction", "content": "\nYes, that is what it implies (One nit is that I would call it unicast RTP packets rather than information since we may use another port for RTCP packets).\n"}, "context_segments": []}, {"current_segment": {"sid": 5955, "labels": "InformationProviding,ContextSetting", "content": ">         i=Unicast Retransmission Stream #2 (Ret. and Rapid\n> Acq. Support)\n>         c=IN IP4 192.0.2.1\n> This is where the retransmission packets come from, same as\n> the feedback\n> target (in this example).\n> Roni E: If this is the address of the feedback target it\n> belongs to the\n> above m-line (m=video 41002 RTP/AVPF 99) that according to\n> you gives the\n> port on the RR and not on the RS. The problem is that"}, "context_segments": []}, {"current_segment": {"sid": 5956, "labels": "InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationProviding,NeutralResponse", "content": "\nThis line actually specifies the sender for the unicast retransmission session. In our case, it just happens to be the feedback target for the primary SSM session, too. I recall some discussion about using a retransmission source which is different than the feedback target for the SSM. In that case, the address would be different, I guess.\n"}, "context_segments": []}, {"current_segment": {"sid": 5957, "labels": "InformationProviding,ExtensionOfPrevious", "content": "> according to SDP the\n> combination of the c= and port on the m-line provides the\n> transport address\n> to where a stream will be sent so according to SDP this"}, "context_segments": []}, {"current_segment": {"sid": 5958, "labels": "ClarificationElicitation,InformationProviding,NeutralResponse,ProposeAction,Question,InformationProviding,InformationSeeking", "content": "\nThe port on the m line is the port where the retranmission packets are sent. However, c line denotes the source for these packets. RFC 4566 page 13 says that \"... If the session is not multicast, then the connection address contains the unicast IP address of the expected data source or data relay or data sink as determined by additional attribute fields...\"\n\nAm I missing something?\n"}, "context_segments": []}, {"current_segment": {"sid": 5959, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "> m-line specify an\n> address and port on the Feedback Target and not on the RR and\n> only to this\n> address RTP payload type 99 will be sent. I am positive that\n> this is not\n> what you want."}, "context_segments": []}, {"current_segment": {"sid": 5960, "labels": "NeutralResponse,ProposeAction,StateDecision,InformationProviding,StateDecision", "content": "\nThere can be other payload types we might need to send on this retransmission session in the future. In that case, we will add them.\n"}, "context_segments": []}, {"current_segment": {"sid": 5961, "labels": "InformationProviding,ProposeAction", "content": ">         a=rtpmap:99 rtx/90000\n>         a=rtcp:41003\n> This is where the RTCP packets for the retransmission session go. For\n> example, RAMS-I goes to this port on RRs. RAMS-T goes to this\n> port on RS.\n> Roni E: So now you assume that the RR must use the same port\n> as the FT for\n> this communication. I could not find any place that one\n> m-line gives the"}, "context_segments": []}, {"current_segment": {"sid": 5962, "labels": "InformationProviding,ExtensionOfPrevious", "content": "> address for both sides. This RTCP port is on 192.0.2.1 so it\n> will be used\n> for RAMS-R but not for RAMS-I."}, "context_segments": []}, {"current_segment": {"sid": 5963, "labels": "Social,Social", "content": "Hi Roni,"}, "context_segments": []}, {"current_segment": {"sid": 5964, "labels": "Question,InformationProviding,Disagreement,Question,InformationProviding,InformationSeeking", "content": "\nNot the m line, but the \"a=rtcp\" line. Is this wrong?\n"}, "context_segments": []}, {"current_segment": {"sid": 5965, "labels": "InformationSeeking,InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationProviding,ProposeAction", "content": "\nRAMS-R should go to the feedback target address and port for the primary SSM session since it is a feedback message for the SSM session. But, RAMS-T is a feedback message for the retransmission session, thus, it should go to the RTCP port of the retransmission session (41003). I hope this also clarifies your question in the next email. If you think I got the ports wrong, let me know.\n\n-acbegen\n"}, "context_segments": []}, {"current_segment": {"sid": 5966, "labels": "Social,Social", "content": "Hi Roni,\n"}, "context_segments": []}, {"current_segment": {"sid": 5967, "labels": "InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationProviding", "content": "Ali,\nI looked at RFC 4570 and I assume that port 41001 is the port for the\nunicast RTCP reports from the receivers and according to section 3.2.1 of\nthat RFC you also should have a RTCP-unicast specification. This is for the\nmulticast receiver reports."}, "context_segments": []}, {"current_segment": {"sid": 5968, "labels": "Agreement,Agreement,InformationProviding", "content": "\nYes, indeed.\n"}, "context_segments": [{"sid": 5967, "labels": "InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationProviding", "content": "Ali,\nI looked at RFC 4570 and I assume that port 41001 is the port for the\nunicast RTCP reports from the receivers and according to section 3.2.1 of\nthat RFC you also should have a RTCP-unicast specification. This is for the\nmulticast receiver reports."}]}, {"current_segment": {"sid": 5969, "labels": "InformationProviding,Agreement,ContextSetting,Agreement,StateDecision", "content": "\nCorrect. We do have that line in our draft at the top right after the grouping lines:"}, "context_segments": [{"sid": 5967, "labels": "InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationProviding", "content": "Ali,\nI looked at RFC 4570 and I assume that port 41001 is the port for the\nunicast RTCP reports from the receivers and according to section 3.2.1 of\nthat RFC you also should have a RTCP-unicast specification. This is for the\nmulticast receiver reports."}]}, {"current_segment": {"sid": 5970, "labels": "InformationSeeking,InformationProviding,ContextSetting,ProposeAction,InformationProviding", "content": "\nSince I have two hats here then as a WG chair, my intention is to ask the\nlist to start this topic as a WG item"}, "context_segments": []}, {"current_segment": {"sid": 5971, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction,InformationProviding", "content": "\nTaking my WG chair off, my expectation is that a WG document will describe a\nsolution that can be implemented while the current text does not specify how\nto make it work. I do not care if you write that RTP/RTCP mux MUST be used\nby the RS and supported by the RR and update the SDP in the example to\nspecify that this is case."}, "context_segments": []}, {"current_segment": {"sid": 5972, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "\nMy personal preference is to have the RS indicate in the SDP that it wants\nto use multiplexing and to add a flag to RAMS-R that will indicate if\nRTP/RTCP mux is supported by RR and can be used. Only if the RR cannot\nsupport the multiplexing it should indicate it using the flag and add to the\nRAMS-R the transport address to be used (Note that it can be v4 or v6)."}, "context_segments": []}, {"current_segment": {"sid": 5973, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nSDP cannot be used since there is no SDP from RR to RS."}, "context_segments": []}, {"current_segment": {"sid": 5974, "labels": "InformationProviding,ContextSetting,ProposeAction,Thanking,InformationProviding,NeutralResponse,Thanking,Social", "content": "\nThanks for the detailed answer. Admittedly, I don't know much about RTSP beyond its basics. However, I doubt how much it applies in our case. \"Unicast\" in RTSP context mostly refers to video-on-demand kind of applications where the primary distribution is over unicast. In contrast, our primary distribution is over multicast, and we use unicast as a repair stream. Thus, I still believe the SDP we have should work fine. RS gathers the IP address of the RR when it receives the RAMS request. The samething happens when RR sends a NACK for requesting retransmissions."}, "context_segments": []}, {"current_segment": {"sid": 5975, "labels": "InformationProviding,Disagreement,ExtensionOfPrevious,ProposeAction,InformationProviding,Disagreement,ExtensionOfPrevious", "content": "\nThat is not to say that this SDP is the only SDP that will work in this system. There may be others. But, I still don't agree with you when you say that this SDP won't work. My expectation is that we will include other SDP examples as we move forward."}, "context_segments": []}, {"current_segment": {"sid": 5976, "labels": "InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationProviding,ProposeAction", "content": "\nOn your last point, NAT is a different issue and there has to be a way to deal with it. Muxing sounds reasonable, and we may or may not mandate it, I am not sure at this point. An alternative could be that RR opens ports on its NAT device and includes them in the request message it sends. These could be in RAMS-R TLV extensions, or could be a separate RTCP packet solely for this purpose within the same RTCP compound packet that carries the RAMS-R. I believe Bill mentioned these briefly in his earlier email. We are open to suggestions at this point and the NAT section will cover these issues once we have a WG item."}, "context_segments": []}, {"current_segment": {"sid": 5977, "labels": "InformationProviding", "content": "\n-acbegen"}, "context_segments": []}, {"current_segment": {"sid": 5978, "labels": "InformationProviding", "content": "Roni Even"}, "context_segments": []}, {"current_segment": {"sid": 5979, "labels": "InformationProviding", "content": "RTPSessions (RAMS)\" available"}, "context_segments": []}, {"current_segment": {"sid": 5980, "labels": "Social,Social", "content": "Hi Ali,\n"}, "context_segments": []}, {"current_segment": {"sid": 5981, "labels": "Social,Social", "content": "Hi Jose,"}, "context_segments": []}, {"current_segment": {"sid": 5982, "labels": "ContextSetting,ProposeAction,InformationProviding,ProposeAction", "content": "Ali,\nSee inline"}, "context_segments": []}, {"current_segment": {"sid": 5983, "labels": "InformationProviding", "content": "Sessions (RAMS)\" available"}, "context_segments": []}, {"current_segment": {"sid": 5984, "labels": "ContextSetting,InformationProviding", "content": "Ali,\nI will try to explain in simple way"}, "context_segments": []}, {"current_segment": {"sid": 5985, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding", "content": "\nWhen the RS receives the RAMS-R it need to start sending an RTP stream to\nthe RR.\nIn order to send a unicast packet, the RS needs to know a transport address\non the RR to where the RTP stream will be sent. The current draft does not\nsay how the RS knows this address. There is no SDP from RR to RS like you\nmention in your response.\nThis is why I say that the current draft does not specify a solution that\ncan be implemented as a working solution"}, "context_segments": []}, {"current_segment": {"sid": 5986, "labels": "InformationProviding,NeutralResponse,ContextSetting,InformationProviding", "content": "Oh, I see. The burst goes to the port that we would normally send the retransmissions. For example, consider the SDP from the draft:"}, "context_segments": []}, {"current_segment": {"sid": 5987, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,Disagreement,ProposeAction", "content": "Ali,\nYour SDP example will not help anyone who will try to develop interop\napplication, the c-line in the unicast stream and the port should refer to\nthe same device since there is no other attribute in the example that points\nto a different semantics to anyone who will look at it. The semantics that\nyou are using where the c-line is for the RS and the port is for the RR and\nthe RS assuming that the RS somehow knows the IP address of the RR based on\nthe RAMS-R request may work in some cases but should not be the one shown as\nthe primary example and should not be the recommended way, The recommended\nway should be to convey the address of the RR in the RAMS-R and this is the\nreason I pointed to RTSP. The semantics of the SDP in the example is not\ndocumented in your text and is not obvious to anyone who will just look at\nit."}, "context_segments": []}, {"current_segment": {"sid": 5988, "labels": "InformationProviding,NeutralResponse,InformationProviding,Disagreement", "content": "\nI believe this is rather a strong claim, considering that I already mentioned that we would add more SDP examples as we moved forward.\n"}, "context_segments": [{"sid": 5987, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,Disagreement,ProposeAction", "content": "Ali,\nYour SDP example will not help anyone who will try to develop interop\napplication, the c-line in the unicast stream and the port should refer to\nthe same device since there is no other attribute in the example that points\nto a different semantics to anyone who will look at it. The semantics that\nyou are using where the c-line is for the RS and the port is for the RR and\nthe RS assuming that the RS somehow knows the IP address of the RR based on\nthe RAMS-R request may work in some cases but should not be the one shown as\nthe primary example and should not be the recommended way, The recommended\nway should be to convey the address of the RR in the RAMS-R and this is the\nreason I pointed to RTSP. The semantics of the SDP in the example is not\ndocumented in your text and is not obvious to anyone who will just look at\nit."}]}, {"current_segment": {"sid": 5989, "labels": "InformationProviding,ContextSetting,ProposeAction,InformationProviding,Disagreement,UnderstandingNegative", "content": "\nAgain, you are missing the point that we will add more SDP examples as well as discussion for NAT issues. The current SDP is just one example that we came up with, and which, I believe, still works and has been there since version -00. It may be modified, removed or replaced.\n"}, "context_segments": [{"sid": 5987, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,Disagreement,ProposeAction", "content": "Ali,\nYour SDP example will not help anyone who will try to develop interop\napplication, the c-line in the unicast stream and the port should refer to\nthe same device since there is no other attribute in the example that points\nto a different semantics to anyone who will look at it. The semantics that\nyou are using where the c-line is for the RS and the port is for the RR and\nthe RS assuming that the RS somehow knows the IP address of the RR based on\nthe RAMS-R request may work in some cases but should not be the one shown as\nthe primary example and should not be the recommended way, The recommended\nway should be to convey the address of the RR in the RAMS-R and this is the\nreason I pointed to RTSP. The semantics of the SDP in the example is not\ndocumented in your text and is not obvious to anyone who will just look at\nit."}]}, {"current_segment": {"sid": 5990, "labels": "InformationProviding,NeutralResponse,InformationProviding,Agreement", "content": "\nThis is reasonable, rtp/rtcp muxing is also reseanoable and it is indeed very neat, too.\n"}, "context_segments": [{"sid": 5987, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,Disagreement,ProposeAction", "content": "Ali,\nYour SDP example will not help anyone who will try to develop interop\napplication, the c-line in the unicast stream and the port should refer to\nthe same device since there is no other attribute in the example that points\nto a different semantics to anyone who will look at it. The semantics that\nyou are using where the c-line is for the RS and the port is for the RR and\nthe RS assuming that the RS somehow knows the IP address of the RR based on\nthe RAMS-R request may work in some cases but should not be the one shown as\nthe primary example and should not be the recommended way, The recommended\nway should be to convey the address of the RR in the RAMS-R and this is the\nreason I pointed to RTSP. The semantics of the SDP in the example is not\ndocumented in your text and is not obvious to anyone who will just look at\nit."}]}, {"current_segment": {"sid": 5991, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,Disagreement", "content": "\nI also strongly object to mandating that the client MUST use a port defined\nby the server to receive the unicast stream. The RS can recommend a port but\nit is the client (RR) decision to decide which port to use."}, "context_segments": []}, {"current_segment": {"sid": 5992, "labels": "InformationProviding,NeutralResponse,ProposeAction,StateDecision,InformationProviding,ProposeAction", "content": "\nWe are not mandating anything yet as I mentioned several times before. I suggest we drop this discussion and move forward with the draft. Based on the comments/suggestions that may be sent to your email about the SDP example, we will be more than happy to incorporate what AVT decides to do.\n\n-acbegen\n"}, "context_segments": [{"sid": 5991, "labels": "InformationProviding,NeutralResponse,ProposeAction,InformationProviding,Disagreement", "content": "\nI also strongly object to mandating that the client MUST use a port defined\nby the server to receive the unicast stream. The RS can recommend a port but\nit is the client (RR) decision to decide which port to use."}]}, {"current_segment": {"sid": 5993, "labels": "InformationProviding", "content": "Sessions (RAMS)\" available"}, "context_segments": []}, {"current_segment": {"sid": 5994, "labels": "InformationProviding,NeutralResponse,ContextSetting,InformationProviding", "content": "Ali,\nAnother comment\nI thought that RAMS-R and RAMS-T go to the same port but in the example you\nsay that RAMS-R go to port 41001 and RAMS-T go to port 41003"}, "context_segments": []}, {"current_segment": {"sid": 5995, "labels": "InformationProviding", "content": "\n-acbegen"}, "context_segments": []}, {"current_segment": {"sid": 5996, "labels": "InformationProviding,NeutralResponse,ContextSetting,ProposeAction,InformationProviding,Agreement", "content": "Roni-\n\nThese are reasonable approaches, which I need to consider in detail. I\nhave (mostly) been thinking about NAT-friendly solutions, which leads me\nback to muxing. I need to consider the ramifications of NAT on the\nmethods that signal IP addresses and port numbers as part of the\nrun-time for acceleration. The intent is to make acquisition faster, and\nadditional complexity at session instantiation should be avoided (IMHO).\n\nMore to come, once I get my head around the various options.\n\nbvs\n"}, "context_segments": []}, {"current_segment": {"sid": 5997, "labels": "InformationProviding", "content": "\nBill,\n"}, "context_segments": []}, {"current_segment": {"sid": 5998, "labels": "InformationProviding", "content": "\nSince I have two hats here then as a WG chair, my intention is to ask\nthe list to start this topic as a WG item\n"}, "context_segments": []}, {"current_segment": {"sid": 5999, "labels": "InformationProviding", "content": "\nTaking my WG chair off, my expectation is that a WG document will\ndescribe a solution that can be implemented while the current text does\nnot specify how to make it work. I do not care if you write that\nRTP/RTCP mux MUST be used by the RS and supported by the RR and update\nthe SDP in the example to specify that this is case.\n"}, "context_segments": []}, {"current_segment": {"sid": 6000, "labels": "InformationProviding,ProposeAction", "content": "\nMy personal preference is to have the RS indicate in the SDP that it\nwants to use multiplexing and to add a flag to RAMS-R that will indicate\nif RTP/RTCP mux is supported by RR and can be used. Only if the RR\ncannot support the multiplexing it should indicate it using the flag and\nadd to the RAMS-R the transport address to be used (Note that it can be\nv4 or v6).\n\nSDP cannot be used since there is no SDP from RR to RS.\n"}, "context_segments": []}, {"current_segment": {"sid": 6001, "labels": "InformationProviding", "content": "\nRoni Even\n"}, "context_segments": []}, {"current_segment": {"sid": 6002, "labels": "InformationProviding", "content": "\nRoni-\n"}, "context_segments": []}, {"current_segment": {"sid": 6003, "labels": "InformationProviding,ProposeAction", "content": "\nYes, the document needs updating in this respect. We have two broad\noptions which need to be described in detail.\n"}, "context_segments": []}, {"current_segment": {"sid": 6004, "labels": "InformationProviding", "content": "\nThe method that I have been assuming does use muxing. The RS sends the\nunicast burst back to the UDP port number on the RR that sent the\nRAMS-R. This allows transparent operation through NAT. There is a single\nUDP port, and the transaction is initiated by the \"client\", so it is NAT\nfriendly.\n"}, "context_segments": []}, {"current_segment": {"sid": 6005, "labels": "ClarificationElicitation,ProposeAction,InformationSeeking,InformationProviding", "content": "\nThere are quite a few ways we could handle the case in which muxing is\nnot used. We could add a parameter to the RAMS-R, use another RTCP\npacket in the same compound packet, define the port numbers as a\nrelationship to the opened port (not attractive), or define something in\nthe SDP (also not attractive). I personally like the \"RAMS-R optional\nfield\" approach, but I think this should be a topic that we consider in\ndetail once we have a WG item.\n"}, "context_segments": []}, {"current_segment": {"sid": 6006, "labels": "InformationProviding", "content": "\nbvs\n"}, "context_segments": []}, {"current_segment": {"sid": 6007, "labels": "InformationProviding,ProposeAction", "content": "\nHi,\n\nI think that the current draft does not give a description of a system\nthat works since there is no text explaining how the RS knows the\nunicast transport address on the RR to where to send the stream.\n\nIf you mandate the use of RTP/RTCP mux it should say so otherwise the\nRAMS-R should have an optional parameter that supplies this information\nand a flag for using RTP/RTCP mux.\n\nThanks\n\nRoni Even\n"}, "context_segments": []}, {"current_segment": {"sid": 6008, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nm=video 41000 RTP/AVPF 98\ni=Primary Multicast Stream #2\nc=IN IP4 224.1.1.2/255\na=source-filter: incl IN IP4 224.1.1.2 192.0.2.2"}, "context_segments": []}, {"current_segment": {"sid": 6009, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nSource (192.0.2.2) sends the rtp packets to the multicast group (224.1.1.2) with a dest port 41000."}, "context_segments": []}, {"current_segment": {"sid": 6010, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\na=rtpmap:98 MP2T/90000\na=rtcp:41001 IN IP4 192.0.2.1"}, "context_segments": []}, {"current_segment": {"sid": 6011, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nThe feedback target (RS) address for this SSM session is 192.0.2.1 and its port is 41001. This is the address/port where RR sends the RAMS-R, or receiver reports for the SSM session."}, "context_segments": []}, {"current_segment": {"sid": 6012, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\na=rtcp-fb:98 nack\na=rtcp-fb:98 nack ssli\na=ssrc:123321 cname:iptv-ch32@rams.example.com\na=mid:3\nm=video 41002 RTP/AVPF 99"}, "context_segments": []}, {"current_segment": {"sid": 6013, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nThe retransmission packets go to port 41002. This is the port RRs listen to for retransmission and RAMS."}, "context_segments": []}, {"current_segment": {"sid": 6014, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\ni=Unicast Retransmission Stream #2 (Ret. and Rapid Acq. Support)\nc=IN IP4 192.0.2.1"}, "context_segments": []}, {"current_segment": {"sid": 6015, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nThis is where the retransmission packets come from, same as the feedback target (in this example)."}, "context_segments": []}, {"current_segment": {"sid": 6016, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\na=rtpmap:99 rtx/90000\na=rtcp:41003"}, "context_segments": []}, {"current_segment": {"sid": 6017, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nThis is where the RTCP packets for the retransmission session go. For example, RAMS-I goes to this port on RRs. RAMS-T goes to this port on RS."}, "context_segments": []}, {"current_segment": {"sid": 6018, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\na=fmtp:99 apt=98; rtx-time=5000\na=mid:4"}, "context_segments": []}, {"current_segment": {"sid": 6019, "labels": "InformationProviding", "content": "\n-acbegen"}, "context_segments": []}, {"current_segment": {"sid": 6020, "labels": "ExtensionOfPrevious,ContextSetting,ClarificationElicitation,InformationSeeking,InformationProviding", "content": "\nAs for the c-line in the unicast stream the whole section you quoted"}, "context_segments": []}, {"current_segment": {"sid": 6021, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n\" If the session is multicast, the connection address will be an IP\nmulticast group address.  If the session is not multicast, then\nthe connection address contains the unicast IP address of the\nexpected data source or data relay or data sink as determined by\nadditional attribute fields.  It is not expected that unicast\naddresses will be given in a session description that is\ncommunicated by a multicast announcement, though this is not\nprohibited.\""}, "context_segments": []}, {"current_segment": {"sid": 6022, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nm=video 41000 RTP/AVPF 98\ni=Primary Multicast Stream #2\nc=IN IP4 224.1.1.2/255\na=source-filter: incl IN IP4 224.1.1.2 192.0.2.2\na=rtpmap:98 MP2T/90000\na=rtcp:41001 IN IP4 192.0.2.1\na=rtcp-fb:98 nack\na=rtcp-fb:98 nack ssli\na=ssrc:123321 cname:iptv-ch32@rams.example.com\na=mid:3\nm=video 41002 RTP/AVPF 99\ni=Unicast Retransmission Stream #2 (Ret. and Rapid Acq. Support)\nc=IN IP4 192.0.2.1\na=recvonly\na=rtpmap:99 rtx/90000\na=rtcp:41003\na=fmtp:99 apt=98; rtx-time=5000\na=mid:4"}, "context_segments": []}, {"current_segment": {"sid": 6023, "labels": "InformationProviding", "content": "16>         c=IN IP4 192.0.2.1\n17>         a=recvonly\n18>         a=rtpmap:99 rtx/90000\n19>         a=rtcp:41003\n20>         a=fmtp:99 apt=98; rtx-time=5000\n21>         a=mid:4"}, "context_segments": [{"sid": 6022, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nm=video 41000 RTP/AVPF 98\ni=Primary Multicast Stream #2\nc=IN IP4 224.1.1.2/255\na=source-filter: incl IN IP4 224.1.1.2 192.0.2.2\na=rtpmap:98 MP2T/90000\na=rtcp:41001 IN IP4 192.0.2.1\na=rtcp-fb:98 nack\na=rtcp-fb:98 nack ssli\na=ssrc:123321 cname:iptv-ch32@rams.example.com\na=mid:3\nm=video 41002 RTP/AVPF 99\ni=Unicast Retransmission Stream #2 (Ret. and Rapid Acq. Support)\nc=IN IP4 192.0.2.1\na=recvonly\na=rtpmap:99 rtx/90000\na=rtcp:41003\na=fmtp:99 apt=98; rtx-time=5000\na=mid:4"}]}, {"current_segment": {"sid": 6024, "labels": "InformationProviding", "content": "\nPanasonic R&D Center Germany GmbH\n63225 Langen, Hessen, Germany\nReg: AG Offenbach (Hessen) HRB 33974\nManaging Director: Thomas Micke"}, "context_segments": [{"sid": 6022, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nm=video 41000 RTP/AVPF 98\ni=Primary Multicast Stream #2\nc=IN IP4 224.1.1.2/255\na=source-filter: incl IN IP4 224.1.1.2 192.0.2.2\na=rtpmap:98 MP2T/90000\na=rtcp:41001 IN IP4 192.0.2.1\na=rtcp-fb:98 nack\na=rtcp-fb:98 nack ssli\na=ssrc:123321 cname:iptv-ch32@rams.example.com\na=mid:3\nm=video 41002 RTP/AVPF 99\ni=Unicast Retransmission Stream #2 (Ret. and Rapid Acq. Support)\nc=IN IP4 192.0.2.1\na=recvonly\na=rtpmap:99 rtx/90000\na=rtcp:41003\na=fmtp:99 apt=98; rtx-time=5000\na=mid:4"}]}, {"current_segment": {"sid": 6025, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nIn this case, the burst will go to port 41002 on the RR. The RAMS-I message(s), which is an RTCP feedback message, will go to port 41003."}, "context_segments": []}, {"current_segment": {"sid": 6026, "labels": "InformationProviding", "content": "\nHTH,\n-acbegen"}, "context_segments": []}, {"current_segment": {"sid": 6027, "labels": "InformationProviding,Answer,Agreement,InformationProviding,Agreement", "content": "\nIndeed, RAMS-R goes to the FT of the new primary session that RR is interested in acquiring rapidly. Then the unicast session becomes alive and RS sends RAMS-I message(s) to RR on the RTCP port for the unicast session. After some time, RR sends the RAMS-T message to the RTCP port for the unicast session since it is supposed to end the unicast session."}, "context_segments": []}, {"current_segment": {"sid": 6028, "labels": "InformationProviding", "content": "\n-acbegen"}, "context_segments": []}, {"current_segment": {"sid": 6029, "labels": "InformationProviding", "content": "Roni,\n"}, "context_segments": []}, {"current_segment": {"sid": 6030, "labels": "InformationProviding", "content": "Sessions (RAMS)\" available"}, "context_segments": []}, {"current_segment": {"sid": 7109, "labels": "Social,InformationProviding,Social", "content": "Hi,\n(as author, not as AD)"}, "context_segments": []}, {"current_segment": {"sid": 7110, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction", "content": "\nThis document currently under WG last call in MMUSIC WG contains\nregistration requests for 3 URIs (See section 22.14). Can you please\nprovide a review by the end of the WG last call on the 19th of October."}, "context_segments": []}, {"current_segment": {"sid": 7111, "labels": "Thanking,Thanking,Social", "content": "\nThanks"}, "context_segments": []}, {"current_segment": {"sid": 7161, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nNONE"}, "context_segments": []}, {"current_segment": {"sid": 7162, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n3.3.2 Returning Items"}, "context_segments": []}, {"current_segment": {"sid": 7163, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nNONE"}, "context_segments": []}, {"current_segment": {"sid": 7164, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n3.4 IRTF and Independent Submission Stream Documents\n3.4.1 New Items"}, "context_segments": []}, {"current_segment": {"sid": 7165, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "\nNONE"}, "context_segments": []}, {"current_segment": {"sid": 7166, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n3.4.2 Returning Items"}, "context_segments": []}, {"current_segment": {"sid": 7167, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no conflict-review-gieben-auth-denial-of-existence-dns-00\nIETF conflict review for draft-gieben-auth-denial-of-existence-dns\ndraft-gieben-auth-denial-of-existence-dns-05\nAuthenticated Denial of Existence in the DNS (ISE: Informational)\nToken: Ted Lemon"}, "context_segments": []}, {"current_segment": {"sid": 7168, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n3.4.3 For Action"}, "context_segments": []}, {"current_segment": {"sid": 7169, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no conflict-review-wkumari-dnsop-defense-collision-mitigate-00\nIETF conflict review for\ndraft-wkumari-dnsop-defense-collision-mitigate\ndraft-wkumari-dnsop-defense-collision-mitigate-03\nA method for mitigating namespace collisions (ISE: Informational)\nToken: Jari Arkko"}, "context_segments": []}, {"current_segment": {"sid": 7170, "labels": "ContextSetting,InformationProviding", "content": "\n4. Working Group Actions\n4.1 WG Creation\n4.1.1 Proposed for IETF Review"}, "context_segments": []}, {"current_segment": {"sid": 7171, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nNONE"}, "context_segments": []}, {"current_segment": {"sid": 7172, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n4.1.2 Proposed for Approval"}, "context_segments": []}, {"current_segment": {"sid": 7173, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no Extensible Provisioning Protocol Extensions (eppext)"}, "context_segments": []}, {"current_segment": {"sid": 7174, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no Using TLS in Applications (uta)"}, "context_segments": []}, {"current_segment": {"sid": 7175, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n4.2 WG Rechartering\n4.2.1 Under Evaluation for IETF Review"}, "context_segments": []}, {"current_segment": {"sid": 7176, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no Multiple Interfaces (mif)"}, "context_segments": []}, {"current_segment": {"sid": 7177, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n4.2.2 Proposed for Approval"}, "context_segments": []}, {"current_segment": {"sid": 7178, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no Emergency Context Resolution with Internet Technologies (ecrit)"}, "context_segments": []}, {"current_segment": {"sid": 7179, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no Content Delivery Networks Interconnection (cdni)"}, "context_segments": []}, {"current_segment": {"sid": 7180, "labels": "ContextSetting,InformationProviding", "content": "\n5. IAB News We Can Use"}, "context_segments": []}, {"current_segment": {"sid": 7181, "labels": "ContextSetting,InformationProviding", "content": "\n6. Management Issues"}, "context_segments": []}, {"current_segment": {"sid": 7182, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\n6.1 New Addition to the IPFIX Experts (Benoit Claise)"}, "context_segments": []}, {"current_segment": {"sid": 7183, "labels": "ContextSetting,InformationProviding", "content": "\n7. Working Group News"}, "context_segments": []}, {"current_segment": {"sid": 7184, "labels": "InformationProviding,InformationProviding", "content": "INTERNET ENGINEERING STEERING GROUP (IESG)\nSummarized Agenda for the 2013-12-05 IESG Teleconference"}, "context_segments": []}, {"current_segment": {"sid": 7185, "labels": "InformationProviding,InformationProviding", "content": "\nThis agenda was generated at 2013-11-28 14:18:53 PST\nUp-to-date web version of this agenda can be found at:\nhttp://datatracker.ietf.org/iesg/agenda/"}, "context_segments": []}, {"current_segment": {"sid": 7186, "labels": "ContextSetting,InformationProviding", "content": "\n1. Administrivia"}, "context_segments": []}, {"current_segment": {"sid": 7187, "labels": "InformationProviding,InformationProviding", "content": "\n1.1 Roll Call\n1.2 Bash the Agenda\n1.3 Approval of the Minutes of Past Telechats\n1.4 List of Remaining Action Items from Last Telechat"}, "context_segments": []}, {"current_segment": {"sid": 7188, "labels": "ContextSetting,InformationProviding,ContextSetting", "content": "\nOUTSTANDING TASKS"}, "context_segments": []}, {"current_segment": {"sid": 7189, "labels": "InformationProviding,InformationProviding", "content": "\nLast updated: November 22, 2013"}, "context_segments": []}, {"current_segment": {"sid": 7190, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no Jari Arkko to draft a call for nominations for the IESG appointment\nto the IAOC for 2014."}, "context_segments": []}, {"current_segment": {"sid": 7191, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no Ted Lemon to write a note to ICANN indicating that the IESG is\nconsidering allocating Special-use Top-Level Domain Names for Peer-\nto-Peer Applications and requesting feedback."}, "context_segments": []}, {"current_segment": {"sid": 7192, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no Ted Lemon to write up a document describing how the IESG should\nfigure out whether to do early allocations for special-use TLDs, and\npresent it to the IESG for discussion."}, "context_segments": []}, {"current_segment": {"sid": 7193, "labels": "ContextSetting,InformationProviding", "content": "\n2. Protocol Actions\n2.1 WG Submissions\n2.1.1 New Items"}, "context_segments": []}, {"current_segment": {"sid": 7194, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-soc-load-control-event-package-11  - IETF stream\nA Session Initiation Protocol (SIP) Load Control Event Package\n(Proposed Standard)\nNote: Volker Hilt (volker.hilt@alcatel-lucent.com) is the document\nshepherd.\nToken: Richard Barnes\nIANA Review: IANA - Review Needed\nConsensus: Unknown"}, "context_segments": []}, {"current_segment": {"sid": 7195, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-forces-ceha-09  - IETF stream\nForCES Intra-NE High Availability (Proposed Standard)\nToken: Adrian Farrel\nIANA Review: IANA OK - Actions Needed\nConsensus: Yes"}, "context_segments": []}, {"current_segment": {"sid": 7196, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-ipfix-mediation-protocol-08  - IETF stream\nOperation of the IP Flow Information Export (IPFIX) Protocol on\nIPFIX Mediators (Proposed Standard)\nToken: Joel Jaeggli\nIANA Review: Version Changed - Review Needed\nConsensus: Yes"}, "context_segments": []}, {"current_segment": {"sid": 7197, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-json-rfc4627bis-07  - IETF stream\nThe JSON Data Interchange Format (Proposed Standard)\nToken: Pete Resnick\nIANA Review: IANA - Not OK\nConsensus: Yes"}, "context_segments": []}, {"current_segment": {"sid": 7198, "labels": "InformationProviding", "content": "\no draft-ietf-ospf-rfc6506bis-03  - IETF stream\nSupporting Authentication Trailer for OSPFv3 (Proposed Standard)\nToken: Stewart Bryant\nIANA Review: IANA OK - Actions Needed\nConsensus: Yes"}, "context_segments": []}, {"current_segment": {"sid": 7199, "labels": "ContextSetting,InformationProviding", "content": "\n2.1.2 Returning Items"}, "context_segments": []}, {"current_segment": {"sid": 7200, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-mmusic-rfc2326bis-38  - IETF stream\nReal Time Streaming Protocol 2.0 (RTSP) (Proposed Standard)\nNote: Document Shepherd: Flemming Andreasen (fandreas@cisco.com)\nToken: Gonzalo Camarillo\nIANA Review: IANA OK - Actions Needed\nConsensus: Yes\nWas deferred by Joel Jaeggli on 2013-11-20"}, "context_segments": []}, {"current_segment": {"sid": 7201, "labels": "ContextSetting,InformationProviding", "content": "\n2.2 Individual Submissions\n2.2.1 New Items"}, "context_segments": []}, {"current_segment": {"sid": 7202, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-leiba-smime-type-registry-02  - IETF stream\nCreation of a registry for smime-type parameter values (Proposed\nStandard)\nToken: Sean Turner\nIANA Review: IANA OK - Actions Needed\nConsensus: Unknown"}, "context_segments": []}, {"current_segment": {"sid": 7203, "labels": "ContextSetting,InformationProviding", "content": "\n2.2.2 Returning Items"}, "context_segments": []}, {"current_segment": {"sid": 7204, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nNONE"}, "context_segments": []}, {"current_segment": {"sid": 7205, "labels": "ContextSetting,InformationProviding", "content": "\n2.3 Status Changes\n2.3.1 New Items"}, "context_segments": []}, {"current_segment": {"sid": 7206, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nNONE"}, "context_segments": []}, {"current_segment": {"sid": 7207, "labels": "InformationProviding", "content": "\n2.3.2 Returning Items"}, "context_segments": []}, {"current_segment": {"sid": 7208, "labels": "InformationProviding", "content": "\nNONE"}, "context_segments": []}, {"current_segment": {"sid": 7209, "labels": "ContextSetting,InformationProviding", "content": "\n3. Document Actions\n3.1 WG Submissions\n3.1.1 New Items"}, "context_segments": []}, {"current_segment": {"sid": 7210, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-cdni-requirements-13  - IETF stream\nContent Distribution Network Interconnection (CDNI) Requirements\n(Informational)\nToken: Spencer Dawkins\nIANA Review: IANA OK - No Actions Needed\nConsensus: Unknown"}, "context_segments": []}, {"current_segment": {"sid": 7211, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-trill-oam-framework-03  - IETF stream\nTRILL OAM Framework (Informational)\nToken: Ted Lemon\nIANA Review: IANA OK - No Actions Needed\nConsensus: Unknown"}, "context_segments": []}, {"current_segment": {"sid": 7212, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-multimob-handover-optimization-06  - IETF stream\nPMIPv6 multicast handover optimization by the Subscription\nInformation Acquisition through the LMA (SIAL) (Experimental)\nToken: Brian Haberman\nIANA Review: IANA OK - Actions Needed\nConsensus: Yes"}, "context_segments": []}, {"current_segment": {"sid": 7213, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-l2vpn-etree-reqt-05  - IETF stream\nRequirements for Metro Ethernet Forum (MEF) Ethernet-Tree (E-Tree)\nSupport in L2VPN (Informational)\nToken: Stewart Bryant\nIANA Review: IANA OK - No Actions Needed\nConsensus: Yes"}, "context_segments": []}, {"current_segment": {"sid": 7214, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n3.1.2 Returning Items"}, "context_segments": []}, {"current_segment": {"sid": 7215, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\no draft-ietf-geopriv-res-gw-lis-discovery-07  - IETF stream\nLocation Information Server (LIS) Discovery using IP address and\nReverse DNS (Informational)\nNote: Alissa Cooper (acooper@cdt.org) is the document shepherd.\nToken: Richard Barnes\nIANA Review: IANA OK - No Actions Needed\nConsensus: Unknown"}, "context_segments": []}, {"current_segment": {"sid": 7216, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "\no draft-ietf-karp-ops-model-09  - IETF stream\nOperations Model for Router Keying (Informational)\nToken: Stewart Bryant\nIANA Review: IANA OK - No Actions Needed\nConsensus: Yes\nWas deferred by Benoit Claise on 2013-11-21"}, "context_segments": []}, {"current_segment": {"sid": 7217, "labels": "ContextSetting,InformationProviding", "content": "\n3.2 Individual Submissions Via AD\n3.2.1 New Items"}, "context_segments": []}, {"current_segment": {"sid": 7218, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nNONE"}, "context_segments": []}, {"current_segment": {"sid": 7219, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n3.2.2 Returning Items"}, "context_segments": []}, {"current_segment": {"sid": 7220, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nNONE"}, "context_segments": []}, {"current_segment": {"sid": 7221, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\n3.3 Status Changes\n3.3.1 New Items"}, "context_segments": []}, {"current_segment": {"sid": 1953, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "\n1) Have TBNEGO specify something like \"Token Binding and 0-RTT MUST\nNOT both be negotiated on the same connection\" and let\ndraft-ietf-tokbind-tls13-0rtt update TBNEGO later.\n2) Specify in TBNEGO a max TLS version of 1.2, and have\ndraft-ietf-tokbind-tls13-0rtt or another draft specify the behavior of\nthe extension in TLS 1.3 and higher."}, "context_segments": []}, {"current_segment": {"sid": 1954, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding,ContextSetting", "content": "\nDoes this WG think this is something that needs to be addressed? Are\nthere other options to consider?"}, "context_segments": []}, {"current_segment": {"sid": 1955, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "Nick Harper  <SIGNATURES AND QUOTES>"}, "context_segments": []}, {"current_segment": {"sid": 1956, "labels": "InformationProviding,ContextSetting,InformationProviding,ContextSetting", "content": "\nThe IESG has received a request from the Transport Layer Security WG (tls) to\nconsider the following document: - 'The Transport Layer Security (TLS)\nProtocol Version 1.3'\n<draft-ietf-tls-tls13-24.txt> as Proposed Standard"}, "context_segments": []}, {"current_segment": {"sid": 1957, "labels": "InformationProviding,ProposeAction,InformationSeeking,InformationProviding,ExtensionOfPrevious,ProposeAction,Social", "content": "\nThe IESG plans to make a decision in the next few weeks, and solicits final\ncomments on this action. Please send substantive comments to the\nietf@ietf.org mailing lists by 2018-03-01. Exceptionally, comments may be\nsent to iesg@ietf.org instead. In either case, please retain the beginning of\nthe Subject line to allow automated sorting."}, "context_segments": []}, {"current_segment": {"sid": 1958, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nAbstract"}, "context_segments": []}, {"current_segment": {"sid": 1959, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThis document specifies version 1.3 of the Transport Layer Security\n(TLS) protocol.  TLS allows client/server applications to communicate\nover the Internet in a way that is designed to prevent eavesdropping,\ntampering, and message forgery."}, "context_segments": []}, {"current_segment": {"sid": 1960, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThe file can be obtained via\nhttps://datatracker.ietf.org/doc/draft-ietf-tls-tls13/"}, "context_segments": []}, {"current_segment": {"sid": 1961, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nIESG discussion can be tracked via\nhttps://datatracker.ietf.org/doc/draft-ietf-tls-tls13/ballot/"}, "context_segments": []}, {"current_segment": {"sid": 1962, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ContextSetting", "content": "\nThe following IPR Declarations may be related to this I-D:"}, "context_segments": []}, {"current_segment": {"sid": 1963, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nhttps://datatracker.ietf.org/ipr/2900/"}, "context_segments": []}, {"current_segment": {"sid": 1964, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThe document contains these normative downward references.\nSee RFC 3967 for additional information:\nrfc8017: PKCS #1: RSA Cryptography Specifications Version 2.2 (Informational - IETF stream)"}, "context_segments": []}, {"current_segment": {"sid": 1965, "labels": "Social,Social", "content": "Hi,"}, "context_segments": []}, {"current_segment": {"sid": 6101, "labels": "InformationProviding,ContextSetting,InformationProviding,ContextSetting", "content": "When I read the grammar for the absolute time format in RTSP both in RFC\n2326 and in draft-ietf-mmusic-rfc2326bis-05.txt I stumbled across a\nrecursive definition. In both documents you can find this text:"}, "context_segments": [{"sid": 1965, "labels": "Social,Social", "content": "Hi,"}]}, {"current_segment": {"sid": 1966, "labels": "InformationSeeking,ContextSetting,ProposeAction,InformationProviding,ContextSetting,ProposeAction", "content": "\nOne or more media streams within a BUNDLE group can use\nthe Datagram Transport Layer Security (DTLS) protocol [RFC6347]\nin order to encrypt the data, or to negotiate encryption keys\nif another encryption mechanism is used to encrypt media."}, "context_segments": []}, {"current_segment": {"sid": 6102, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nutc-time = utc-date \"T\" utc-time \"Z\"\nutc-date = 8DIGIT ; < YYYYMMDD >\nutc-time = 6DIGIT [ \".\" fraction ] ; < HHMMSS.fraction >"}, "context_segments": [{"sid": 1966, "labels": "InformationSeeking,ContextSetting,ProposeAction,InformationProviding,ContextSetting,ProposeAction", "content": "\nOne or more media streams within a BUNDLE group can use\nthe Datagram Transport Layer Security (DTLS) protocol [RFC6347]\nin order to encrypt the data, or to negotiate encryption keys\nif another encryption mechanism is used to encrypt media."}]}, {"current_segment": {"sid": 1967, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nWhen DTLS is used for more than one media stream within a BUNDLE\ngroup, the following rules apply:"}, "context_segments": []}, {"current_segment": {"sid": 6103, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "\nWhich gives two definitions for utc-time of which the first happens to\nbe recursive. Fixing this only involves changing the name of one of the\ndefinitions, but have two definitions for utc-time can lead to some\nconfusion."}, "context_segments": [{"sid": 1967, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nWhen DTLS is used for more than one media stream within a BUNDLE\ngroup, the following rules apply:"}]}, {"current_segment": {"sid": 1968, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\no  A single DTLS association [RFC6347] MUST be used for all media\nusing DTLS; and"}, "context_segments": []}, {"current_segment": {"sid": 1969, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\no  Each media protocol using DTLS MUST use the same mechanism for\ndetermining which endpoint (the offerer or answerer) becomes DTLS client and DTLS server."}, "context_segments": []}, {"current_segment": {"sid": 1970, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "Christer Holmberg  <SIGNATURES AND QUOTES>"}, "context_segments": []}, {"current_segment": {"sid": 2043, "labels": "InformationProviding,ProposeAction,InformationProviding,ProposeAction", "content": "IPv4 address exhaustion is a reality, and the truth is that IPv6 will not be deployed fast enough to be a complete solution. I have an idea where QUIC could be used to solve the IPv4 address exhaustion problem by using multiplexing middleboxes, with minimal modifications to QUIC."}, "context_segments": []}, {"current_segment": {"sid": 2044, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456#issuecomment-398745630"}, "context_segments": []}, {"current_segment": {"sid": 2045, "labels": "InformationProviding,InformationProviding,NeutralResponse", "content": "Closed #1456."}, "context_segments": []}, {"current_segment": {"sid": 2046, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456#event-1691862761"}, "context_segments": []}, {"current_segment": {"sid": 2047, "labels": "InformationProviding,ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\nThe idea is that the client is forced to provide a server name indication (SNI) if the user provided the client with a DNS name instead of a raw IP address. A NAT middlebox then shares one IPv4 address for multiple servers. The middlebox makes a decision based on the SNI which internal private IPv4 address will be used. The connection will always, reliably, be forwarded to the correct internal private IPv4 address, because the client would be required to always supply an SNI. Nested middleboxes may be supported by configuring SNI matches with wildcards (e.g. server1.department1.company.com will match *.department1.company.com at the company's middlebox and server1.department.company.com at the department's middlebox)."}, "context_segments": []}, {"current_segment": {"sid": 2048, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nThe most common application of QUIC, web browsing, typically uses DNS names and not IP addresses."}, "context_segments": []}, {"current_segment": {"sid": 2049, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nThe most important of the eventual applications of QUIC will probably be:\n* E-mail: SMTP over QUIC\n* Remote access: SSH over QUIC, VNC over QUIC, etc."}, "context_segments": []}, {"current_segment": {"sid": 2050, "labels": "InformationProviding,InformationProviding", "content": "\nFor SMTP, the MX records already use DNS names instead of IP addresses. SSH and VNC are also typically executed with DNS names."}, "context_segments": []}, {"current_segment": {"sid": 2051, "labels": "InformationProviding,ProposeAction,InformationProviding,ContextSetting", "content": "\nThe only change to QUIC would be to add the following to draft-ietf-quic-tls-12 somewhere:"}, "context_segments": []}, {"current_segment": {"sid": 2052, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n<blockquote>\nA client MUST provide a server name indication, as defined in RFC6066, if the user of the client specified the connection destination as a DNS name instead of an IP address.\n</blockquote>"}, "context_segments": []}, {"current_segment": {"sid": 2053, "labels": "InformationProviding,InformationProviding", "content": "\nI don't see any mention of SNI in QUIC specifications now, so I assume the proposed requirement is not a requirement now."}, "context_segments": []}, {"current_segment": {"sid": 2054, "labels": "InformationProviding,ProposeAction,InformationProviding,ContextSetting,ProposeAction", "content": "\nTLS 1.3 apparently allows servers to require a client to use SNI (https://tools.ietf.org/html/draft-ietf-tls-tls13-28), but I believe the same should be explicitly specified in the QUIC specifications as well. According to TLS 1.3 draft:"}, "context_segments": []}, {"current_segment": {"sid": 2055, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n<blockquote>\nAdditionally, all implementations MUST support use of the\n\"server_name\" extension with applications capable of using it.\nServers MAY require clients to send a valid \"server_name\" extension.\nServers requiring this extension SHOULD respond to a ClientHello\nlacking a \"server_name\" extension by terminating the connection with\na \"missing_extension\" alert.\n</blockquote>"}, "context_segments": []}, {"current_segment": {"sid": 2056, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nI hope the same will be true with QUIC's use of TLS. Otherwise QUIC will be a step backwards from TLS+TCP that allows a transparent proxy to operate as a NAT multiplexing device offering access to multiple servers."}, "context_segments": []}, {"current_segment": {"sid": 2057, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nIf QUIC makes SNI necessary, then QUIC will be much better than TCP+TLS because you don't need a full transparent proxy to do said multiplexing (as the first packet already contains the SNI)."}, "context_segments": []}, {"current_segment": {"sid": 2058, "labels": "InformationProviding,ProposeAction,InformationProviding", "content": "\nI hope this is the correct venue for this modification proposal (this is my first QUIC related issue). I'm not part of any QUIC mailing list, but if a mailing list is a more appropriate venue for discussing this modification, I could join."}, "context_segments": []}, {"current_segment": {"sid": 2059, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456"}, "context_segments": []}, {"current_segment": {"sid": 2060, "labels": "InformationProviding,Disagreement,ProposeAction,InformationProviding,NeutralResponse", "content": "This probably should be discussed on the mailing list rather than as an issue."}, "context_segments": []}, {"current_segment": {"sid": 2061, "labels": "Question,ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious,Question,InformationSeeking", "content": "\nAren't there privacy concerns here? One could imagine a DNS like mapping from SNI to connection ID similar to a stateless retry, but where a SNI drives the retry. This could be a sort-of separate service external to QUIC."}, "context_segments": []}, {"current_segment": {"sid": 2062, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456#issuecomment-398029983"}, "context_segments": []}, {"current_segment": {"sid": 2063, "labels": "Question,Question,InformationProviding,NeutralResponse,InformationSeeking", "content": "Would a forward proxy approach help alleviate your concerns?"}, "context_segments": []}, {"current_segment": {"sid": 2064, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n@bemasc and I are putting together some ideas on how a User Agent could explicitly opt-in to passing non-TCP traffic via a proxy, in a similar way to how HTTP proxies work now. This takes place after secure session establishment."}, "context_segments": []}, {"current_segment": {"sid": 2065, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456#issuecomment-398041749"}, "context_segments": []}, {"current_segment": {"sid": 2066, "labels": "InformationProviding,Disagreement,InformationProviding,Disagreement,NeutralResponse", "content": "A forward proxy is useful but it cannot safely operate at the cloud provider level load balancer because privacy is compromised."}, "context_segments": []}, {"current_segment": {"sid": 2067, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456#issuecomment-398045612"}, "context_segments": []}, {"current_segment": {"sid": 2068, "labels": "InformationProviding,InformationProviding,NeutralResponse", "content": "I guess it depends where the exhaustion concerns are."}, "context_segments": []}, {"current_segment": {"sid": 2069, "labels": "InformationProviding,NeutralResponse,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nA reverse proxy for the cloud case, i.e. a request router, is something I'm familiar with. Some have scalability concerns with these."}, "context_segments": []}, {"current_segment": {"sid": 2070, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456#issuecomment-398053344"}, "context_segments": []}, {"current_segment": {"sid": 2071, "labels": "InformationProviding,InformationProviding,NeutralResponse", "content": "FWIW, the QUIC-HTTP draft mandates the use of SNI. Quoting from [section 2.3](https://quicwg.org/base-drafts/draft-ietf-quic-http.html#rfc.section.2.3), \"The Server Name Indication (SNI) extension [RFC6066] MUST be included in the TLS handshake.\""}, "context_segments": []}, {"current_segment": {"sid": 2072, "labels": "InformationProviding,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\nThough I wonder if we might want to relax the wording in possibility of having SNI encryption, to something like what we see in [RFC 7540 section 9.2](https://tools.ietf.org/html/rfc7540#section-9.2)."}, "context_segments": []}, {"current_segment": {"sid": 2073, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456#issuecomment-398059647"}, "context_segments": []}, {"current_segment": {"sid": 2074, "labels": "InformationProviding,InformationProviding,NeutralResponse", "content": "As observed, we mandate use of SNI already (though we might want to soften this to allow encrypted SNI as @kazuho points out).  TLS doesn't mandate use of SNI, which is entirely appropriate for QUIC-the-transport."}, "context_segments": []}, {"current_segment": {"sid": 2075, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456#issuecomment-398279115"}, "context_segments": []}, {"current_segment": {"sid": 2076, "labels": "InformationProviding,ProposeAction,InformationProviding,NeutralResponse", "content": "As noted already, QUIC inherits TLS's requirements of SNI (the SNI field is still part of TLS), and QUIC-HTTP inherits HTTP/2's requirements of SNI. @jmtilli : If you're concerned about encrypted SNI, that conversation ought to apply to HTTP over TCP as well, so I would take that to the httpbis working group.\u00a0If you are concerned about other applications using QUIC without SNI, that'll probably be relevant when considering other applications mapped on QUIC, which we haven't done yet as a wg."}, "context_segments": []}, {"current_segment": {"sid": 2077, "labels": "InformationProviding,InformationProviding", "content": "\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/quicwg/base-drafts/issues/1456#issuecomment-398504617"}, "context_segments": []}, {"current_segment": {"sid": 2078, "labels": "InformationProviding,ProposeAction,InformationProviding,Agreement,ProposeAction", "content": "Ok, perhaps this issue can be closed then, if QUIC inherits the requirement of TLS. I was fearing that QUIC might not adopt all of TLS, as QUIC is very different from TCP and not all of TLS might necessarily apply."}, "context_segments": []}, {"current_segment": {"sid": 2079, "labels": "InformationProviding,ContextSetting,InformationProviding,ContextSetting", "content": "\nA New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Transport Layer Security of the IETF."}, "context_segments": []}, {"current_segment": {"sid": 6107, "labels": "Social,Social", "content": "Hi:"}, "context_segments": [{"sid": 2079, "labels": "InformationProviding,ContextSetting,InformationProviding,ContextSetting", "content": "\nA New Internet-Draft is available from the on-line Internet-Drafts directories.\nThis draft is a work item of the Transport Layer Security of the IETF."}]}, {"current_segment": {"sid": 2080, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nTitle           : The Transport Layer Security (TLS) Protocol Version 1.3\nAuthor          : Eric Rescorla\nFilename        : draft-ietf-tls-tls13-16.txt\nPages           : 117\nDate            : 2016-09-22"}, "context_segments": []}, {"current_segment": {"sid": 6108, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nDuring the Jan 22, 2003 RTSP telecon, we discussed Range header in PLAY\nreponses in the context of option tag play.basic.\nIn current draft (draft-ietf-mmusic-rfc2326bis-02.txt), PLAY Range response\nis required for on demand media (see section 10.5).\nIt was decided to make this an requirement for live streaming as well."}, "context_segments": [{"sid": 2080, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding", "content": "\nTitle           : The Transport Layer Security (TLS) Protocol Version 1.3\nAuthor          : Eric Rescorla\nFilename        : draft-ietf-tls-tls13-16.txt\nPages           : 117\nDate            : 2016-09-22"}]}, {"current_segment": {"sid": 2081, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nAbstract:\nThis document specifies version 1.3 of the Transport Layer Security\n(TLS) protocol.  TLS allows client/server applications to communicate\nover the Internet in a way that is designed to prevent eavesdropping,\ntampering, and message forgery."}, "context_segments": []}, {"current_segment": {"sid": 6109, "labels": "InformationProviding,StateDecision,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nHere is the proposed changes to section 10.5 and section 14 (examples) in\ndraft-ietf-mmusic-rfc2326bis-02.txt. Each change is separated by \"-----\"'s,\nand instructions on how to make the changes are put in square brackets."}, "context_segments": [{"sid": 2081, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nAbstract:\nThis document specifies version 1.3 of the Transport Layer Security\n(TLS) protocol.  TLS allows client/server applications to communicate\nover the Internet in a way that is designed to prevent eavesdropping,\ntampering, and message forgery."}]}, {"current_segment": {"sid": 2082, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThe IETF datatracker status page for this draft is:\nhttps://datatracker.ietf.org/doc/draft-ietf-tls-tls13/"}, "context_segments": []}, {"current_segment": {"sid": 6110, "labels": "InformationProviding,InformationSeeking,ExtensionOfPrevious,ProposeAction,Social", "content": "\nYour comments are always welcome."}, "context_segments": [{"sid": 2082, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThe IETF datatracker status page for this draft is:\nhttps://datatracker.ietf.org/doc/draft-ietf-tls-tls13/"}]}, {"current_segment": {"sid": 2083, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThere's also a htmlized version available at:\nhttps://tools.ietf.org/html/draft-ietf-tls-tls13-16"}, "context_segments": []}, {"current_segment": {"sid": 6111, "labels": "Thanking,Thanking,Social", "content": "\nThanks"}, "context_segments": [{"sid": 2083, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThere's also a htmlized version available at:\nhttps://tools.ietf.org/html/draft-ietf-tls-tls13-16"}]}, {"current_segment": {"sid": 2084, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nA diff from the previous version is available at:\nhttps://www.ietf.org/rfcdiff?url2=draft-ietf-tls-tls13-16"}, "context_segments": []}, {"current_segment": {"sid": 2085, "labels": "InformationProviding,ExtensionOfPrevious,Social,InformationProviding,ProposeAction,ExtensionOfPrevious", "content": "\nPlease note that it may take a couple of minutes from the time of submission\nuntil the htmlized version and diff are available at tools.ietf.org."}, "context_segments": []}, {"current_segment": {"sid": 2086, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nInternet-Drafts are also available by anonymous FTP at:\nftp://ftp.ietf.org/internet-drafts/"}, "context_segments": []}, {"current_segment": {"sid": 1628, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nFor one thing, the music collaboration use case, I believe, calls for\nthis architecture."}, "context_segments": []}, {"current_segment": {"sid": 2150, "labels": "Social", "content": "Hey All,"}, "context_segments": [{"sid": 1628, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nFor one thing, the music collaboration use case, I believe, calls for\nthis architecture."}]}, {"current_segment": {"sid": 6155, "labels": "Social", "content": "Hi all,"}, "context_segments": [{"sid": 1628, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nFor one thing, the music collaboration use case, I believe, calls for\nthis architecture."}, {"sid": 2150, "labels": "Social", "content": "Hey All,"}]}, {"current_segment": {"sid": 1629, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPerhaps one thing to watch for in the use case write-ups is separation\nbetween a use case and architecture. These are two different things\nbecause one architecture can fit many (and maybe all) use cases."}, "context_segments": []}, {"current_segment": {"sid": 2151, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nFrom implementation point of view AFAWK, [1], [2] does not explicitly\nmention the  * cipher suites * to be used in NTS. [1] mentions the\nfollowing:"}, "context_segments": [{"sid": 1629, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPerhaps one thing to watch for in the use case write-ups is separation\nbetween a use case and architecture. These are two different things\nbecause one architecture can fit many (and maybe all) use cases."}]}, {"current_segment": {"sid": 6156, "labels": "Answer,InformationProviding,Answer", "content": "SDP was originally devised for multicast sessions, and this wording\nreflects the original use.  If a session was recvonly, the multicast\nparticipants who received the SDP description must not transmit data.\nObviously someone else will transmit data or the session will be\nrather quiet.\n\nIn a unicast world, recvonly would typically indicate that the\nrecipient of the SDP description should not send data. Thus it would\napply to the RTSP client, as the SDP is sent from the server to the\nclient.\n\n- Mark\n"}, "context_segments": [{"sid": 1629, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPerhaps one thing to watch for in the use case write-ups is separation\nbetween a use case and architecture. These are two different things\nbecause one architecture can fit many (and maybe all) use cases."}, {"sid": 2151, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nFrom implementation point of view AFAWK, [1], [2] does not explicitly\nmention the  * cipher suites * to be used in NTS. [1] mentions the\nfollowing:"}]}, {"current_segment": {"sid": 1630, "labels": "NeutralResponse,InformationProviding", "content": "\nAs mentioned by Igor, I'm also looking for the architecture document\nwhich provide the insight into RTCWeb deployment possibilities.\n\ndraft-rosenberg-rtcweb-framework-00 is one of the RTCWeb document which\nis in the similar line.  I'm interested in hearing others opinion on\nthis.\n\nThanks\nPartha\n"}, "context_segments": [{"sid": 1629, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPerhaps one thing to watch for in the use case write-ups is separation\nbetween a use case and architecture. These are two different things\nbecause one architecture can fit many (and maybe all) use cases."}, {"sid": 2151, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nFrom implementation point of view AFAWK, [1], [2] does not explicitly\nmention the  * cipher suites * to be used in NTS. [1] mentions the\nfollowing:"}, {"sid": 6156, "labels": "Answer,InformationProviding,Answer", "content": "SDP was originally devised for multicast sessions, and this wording\nreflects the original use.  If a session was recvonly, the multicast\nparticipants who received the SDP description must not transmit data.\nObviously someone else will transmit data or the session will be\nrather quiet.\n\nIn a unicast world, recvonly would typically indicate that the\nrecipient of the SDP description should not send data. Thus it would\napply to the RTSP client, as the SDP is sent from the server to the\nclient.\n\n- Mark\n"}]}, {"current_segment": {"sid": 6157, "labels": "Agreement,InformationProviding,Agreement,ProposeAction", "content": "\nI also agree.\nTo conclude it depends on using offer/answer which kind of semantics is\nused for recvonly and sendonly.\nTherefore, for clarifying I would appreciate this being explicitly\nstated in some draft/rfc.\n"}, "context_segments": [{"sid": 1629, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nPerhaps one thing to watch for in the use case write-ups is separation\nbetween a use case and architecture. These are two different things\nbecause one architecture can fit many (and maybe all) use cases."}, {"sid": 2151, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "\nFrom implementation point of view AFAWK, [1], [2] does not explicitly\nmention the  * cipher suites * to be used in NTS. [1] mentions the\nfollowing:"}, {"sid": 6156, "labels": "Answer,InformationProviding,Answer", "content": "SDP was originally devised for multicast sessions, and this wording\nreflects the original use.  If a session was recvonly, the multicast\nparticipants who received the SDP description must not transmit data.\nObviously someone else will transmit data or the session will be\nrather quiet.\n\nIn a unicast world, recvonly would typically indicate that the\nrecipient of the SDP description should not send data. Thus it would\napply to the RTSP client, as the SDP is sent from the server to the\nclient.\n\n- Mark\n"}, {"sid": 1630, "labels": "NeutralResponse,InformationProviding", "content": "\nAs mentioned by Igor, I'm also looking for the architecture document\nwhich provide the insight into RTCWeb deployment possibilities.\n\ndraft-rosenberg-rtcweb-framework-00 is one of the RTCWeb document which\nis in the similar line.  I'm interested in hearing others opinion on\nthis.\n\nThanks\nPartha\n"}]}, {"current_segment": {"sid": 1631, "labels": "InformationProviding", "content": "\nas proposed in the July 26th meeting I'd like to put forward a new use\ncase: assume a client is involved in a large multiparty session but is\nunable (or unwilling) to upload his signals to all participants."}, "context_segments": []}, {"current_segment": {"sid": 2152, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n** *The server MUST NOT include HMAC with a SHA-1 or weaker algorithms*\n** *The server MUST include HMAC with SHA-256 or stronger algorithms *"}, "context_segments": [{"sid": 1631, "labels": "InformationProviding", "content": "\nas proposed in the July 26th meeting I'd like to put forward a new use\ncase: assume a client is involved in a large multiparty session but is\nunable (or unwilling) to upload his signals to all participants."}]}, {"current_segment": {"sid": 6158, "labels": "Answer,InformationProviding,Answer,Agreement,ContextSetting", "content": "Yes, offer/answer inverted the original meaning of this.  According to RFC 3264:\n\nIf the offerer wishes to only send media on a stream to its peer, it\nMUST mark the stream as sendonly with the \"a=sendonly\" attribute.  We\nrefer to a stream as being marked with a certain direction if a\ndirection attribute was present as either a media stream attribute or\na session attribute.  If the offerer wishes to only receive media\nfrom its peer, it MUST mark the stream as recvonly.\n\nSo it's pretty clear if offer/answer is used, what the sense of\nrecvonly and sendonly are.\n\nBut I didn't think RTSP used offer/answer.  Or if it does now, I\nmissed it somewhere (I haven't been watching RTSP for a long time).\n\n- Mark\n"}, "context_segments": [{"sid": 1631, "labels": "InformationProviding", "content": "\nas proposed in the July 26th meeting I'd like to put forward a new use\ncase: assume a client is involved in a large multiparty session but is\nunable (or unwilling) to upload his signals to all participants."}, {"sid": 2152, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n** *The server MUST NOT include HMAC with a SHA-1 or weaker algorithms*\n** *The server MUST include HMAC with SHA-256 or stronger algorithms *"}]}, {"current_segment": {"sid": 6159, "labels": "NeutralResponse,InformationProviding,ContextSetting", "content": "\nI think offer/answer were being discussed to\nsetup the RTSP streams/session some while ago when\nRTSP and SIP combination was being discussed on this\nlist.\n"}, "context_segments": [{"sid": 1631, "labels": "InformationProviding", "content": "\nas proposed in the July 26th meeting I'd like to put forward a new use\ncase: assume a client is involved in a large multiparty session but is\nunable (or unwilling) to upload his signals to all participants."}, {"sid": 2152, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n** *The server MUST NOT include HMAC with a SHA-1 or weaker algorithms*\n** *The server MUST include HMAC with SHA-256 or stronger algorithms *"}, {"sid": 6158, "labels": "Answer,InformationProviding,Answer,Agreement,ContextSetting", "content": "Yes, offer/answer inverted the original meaning of this.  According to RFC 3264:\n\nIf the offerer wishes to only send media on a stream to its peer, it\nMUST mark the stream as sendonly with the \"a=sendonly\" attribute.  We\nrefer to a stream as being marked with a certain direction if a\ndirection attribute was present as either a media stream attribute or\na session attribute.  If the offerer wishes to only receive media\nfrom its peer, it MUST mark the stream as recvonly.\n\nSo it's pretty clear if offer/answer is used, what the sense of\nrecvonly and sendonly are.\n\nBut I didn't think RTSP used offer/answer.  Or if it does now, I\nmissed it somewhere (I haven't been watching RTSP for a long time).\n\n- Mark\n"}]}, {"current_segment": {"sid": 6160, "labels": "Agreement,InformationProviding,Agreement,ContextSetting", "content": "\nYes, in the context of doing media setup for RTSP controlled session\nusing SIP one does end up using offer/answer (in the SIP part). However\nI don't think anyone has seriously argued for using offer/answer within\nRTSP.\n"}, "context_segments": [{"sid": 1631, "labels": "InformationProviding", "content": "\nas proposed in the July 26th meeting I'd like to put forward a new use\ncase: assume a client is involved in a large multiparty session but is\nunable (or unwilling) to upload his signals to all participants."}, {"sid": 2152, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\n** *The server MUST NOT include HMAC with a SHA-1 or weaker algorithms*\n** *The server MUST include HMAC with SHA-256 or stronger algorithms *"}, {"sid": 6158, "labels": "Answer,InformationProviding,Answer,Agreement,ContextSetting", "content": "Yes, offer/answer inverted the original meaning of this.  According to RFC 3264:\n\nIf the offerer wishes to only send media on a stream to its peer, it\nMUST mark the stream as sendonly with the \"a=sendonly\" attribute.  We\nrefer to a stream as being marked with a certain direction if a\ndirection attribute was present as either a media stream attribute or\na session attribute.  If the offerer wishes to only receive media\nfrom its peer, it MUST mark the stream as recvonly.\n\nSo it's pretty clear if offer/answer is used, what the sense of\nrecvonly and sendonly are.\n\nBut I didn't think RTSP used offer/answer.  Or if it does now, I\nmissed it somewhere (I haven't been watching RTSP for a long time).\n\n- Mark\n"}, {"sid": 6159, "labels": "NeutralResponse,InformationProviding,ContextSetting", "content": "\nI think offer/answer were being discussed to\nsetup the RTSP streams/session some while ago when\nRTSP and SIP combination was being discussed on this\nlist.\n"}]}, {"current_segment": {"sid": 1632, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThis suggests forwarding support from the network is required, e.g.\nsome relay server, multicast, or the future IETF peer-to-peer streaming\nprotocol (PPSP)."}, "context_segments": []}, {"current_segment": {"sid": 2153, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nWe believe that the NTS draft should be more specific/explicit about the\ncipher suites that should be used. Both for authenticating timing requests\nand for the KE.   This is a standard practice: TLS and DNSSEC both specify\ntheir cipher suites in their drafts.  (For example,\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\netc)"}, "context_segments": [{"sid": 1632, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThis suggests forwarding support from the network is required, e.g.\nsome relay server, multicast, or the future IETF peer-to-peer streaming\nprotocol (PPSP)."}]}, {"current_segment": {"sid": 1633, "labels": "NeutralResponse,InformationProviding", "content": "\nSo the use case is:\n\nUser is part of a multiparty (3 or greater) session, but for one of\nseveral reasons (such as\navailable upstream bandwidth)  cannot send media to all other\nparticipants (\"mesh\" conferencing).\nThis requires that another node, either a central network node (such as\na conferencing server)\nor another member in the session, relay or mix the user's media to\ndistribute to the rest of the\nmembers of the session.\n"}, "context_segments": [{"sid": 1632, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThis suggests forwarding support from the network is required, e.g.\nsome relay server, multicast, or the future IETF peer-to-peer streaming\nprotocol (PPSP)."}, {"sid": 2153, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nWe believe that the NTS draft should be more specific/explicit about the\ncipher suites that should be used. Both for authenticating timing requests\nand for the KE.   This is a standard practice: TLS and DNSSEC both specify\ntheir cipher suites in their drafts.  (For example,\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\netc)"}, {"sid": 6158, "labels": "Answer,InformationProviding,Answer,Agreement,ContextSetting", "content": "Yes, offer/answer inverted the original meaning of this.  According to RFC 3264:\n\nIf the offerer wishes to only send media on a stream to its peer, it\nMUST mark the stream as sendonly with the \"a=sendonly\" attribute.  We\nrefer to a stream as being marked with a certain direction if a\ndirection attribute was present as either a media stream attribute or\na session attribute.  If the offerer wishes to only receive media\nfrom its peer, it MUST mark the stream as recvonly.\n\nSo it's pretty clear if offer/answer is used, what the sense of\nrecvonly and sendonly are.\n\nBut I didn't think RTSP used offer/answer.  Or if it does now, I\nmissed it somewhere (I haven't been watching RTSP for a long time).\n\n- Mark\n"}]}, {"current_segment": {"sid": 6161, "labels": "Agreement,InformationProviding,Agreement,ProposeAction", "content": "\nYour correct, RTSP doesn't use offer/answer. There is no text in either\nRFC 2326 or draft-ietf-mmusic-rfc2326bis about the usage of recvonly. It\nis however included in some examples. To my reading of RFC 4566 is quite\napplicable in for a client receiving an a=recvonly line in the DESCRIBE\nresponse. However we probably should add a few line of text in regards\nto this.\n"}, "context_segments": [{"sid": 1632, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\nThis suggests forwarding support from the network is required, e.g.\nsome relay server, multicast, or the future IETF peer-to-peer streaming\nprotocol (PPSP)."}, {"sid": 2153, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nWe believe that the NTS draft should be more specific/explicit about the\ncipher suites that should be used. Both for authenticating timing requests\nand for the KE.   This is a standard practice: TLS and DNSSEC both specify\ntheir cipher suites in their drafts.  (For example,\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\netc)"}, {"sid": 6158, "labels": "Answer,InformationProviding,Answer,Agreement,ContextSetting", "content": "Yes, offer/answer inverted the original meaning of this.  According to RFC 3264:\n\nIf the offerer wishes to only send media on a stream to its peer, it\nMUST mark the stream as sendonly with the \"a=sendonly\" attribute.  We\nrefer to a stream as being marked with a certain direction if a\ndirection attribute was present as either a media stream attribute or\na session attribute.  If the offerer wishes to only receive media\nfrom its peer, it MUST mark the stream as recvonly.\n\nSo it's pretty clear if offer/answer is used, what the sense of\nrecvonly and sendonly are.\n\nBut I didn't think RTSP used offer/answer.  Or if it does now, I\nmissed it somewhere (I haven't been watching RTSP for a long time).\n\n- Mark\n"}, {"sid": 1633, "labels": "NeutralResponse,InformationProviding", "content": "\nSo the use case is:\n\nUser is part of a multiparty (3 or greater) session, but for one of\nseveral reasons (such as\navailable upstream bandwidth)  cannot send media to all other\nparticipants (\"mesh\" conferencing).\nThis requires that another node, either a central network node (such as\na conferencing server)\nor another member in the session, relay or mix the user's media to\ndistribute to the rest of the\nmembers of the session.\n"}]}, {"current_segment": {"sid": 1636, "labels": "NeutralResponse,InformationProviding", "content": "I strongly support the use case, but I was under the impression that\nthere has been a use case thar required a similar architecture: a\n\"central\" server (of course, it can be replicated) for accumulating\ninput and distributing output."}, "context_segments": []}, {"current_segment": {"sid": 2154, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nIt is not a good idea to leave this up to implementors, because it\nleads to interoperability issues (like those that have plagued IPsec [3])."}, "context_segments": [{"sid": 1636, "labels": "NeutralResponse,InformationProviding", "content": "I strongly support the use case, but I was under the impression that\nthere has been a use case thar required a similar architecture: a\n\"central\" server (of course, it can be replicated) for accumulating\ninput and distributing output."}]}, {"current_segment": {"sid": 6163, "labels": "Question,InformationProviding,InformationSeeking,Question,InformationProviding,ContextSetting", "content": "\nFor me it is not quite clear how to interpret the a=recvonly and\na=sendonly SDP items in an RTSP response to a DESCRIBE request. The SDP\nspecification says that \"this specifies that the tools should be started\nin\" the specified mode (recvonly or sendonly). However, in an asymmetric\nscenario, where one entity is only sending and the other entity is only\nreceiving, it is not quite clear, which entity is meant by \"the tools\".\nIn RTSP, is \"the tools\" actually the RTSP server or the client? Is there\na general answer for this question for other protocols like SIP as well?"}, "context_segments": [{"sid": 1636, "labels": "NeutralResponse,InformationProviding", "content": "I strongly support the use case, but I was under the impression that\nthere has been a use case thar required a similar architecture: a\n\"central\" server (of course, it can be replicated) for accumulating\ninput and distributing output."}, {"sid": 2154, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nIt is not a good idea to leave this up to implementors, because it\nleads to interoperability issues (like those that have plagued IPsec [3])."}]}, {"current_segment": {"sid": 2155, "labels": "ExtensionOfPrevious,Question,InformationProviding,ExtensionOfPrevious,InformationSeeking", "content": "\nFor instance the language above says \"SHA-256 OR stronger\".  What if one\nvendor decides to implement HMAC-SHA-256 and another HMAC-SHA3?  Both\nimplementations satisfy the spec but the implementations will not\ninteroperate."}, "context_segments": []}, {"current_segment": {"sid": 6164, "labels": "Question,Question,ExtensionOfPrevious,InformationSeeking,InformationProviding", "content": "\nIs there anything more concrete about this issue, or is this a gap in\nthe SDP specification?"}, "context_segments": [{"sid": 2155, "labels": "ExtensionOfPrevious,Question,InformationProviding,ExtensionOfPrevious,InformationSeeking", "content": "\nFor instance the language above says \"SHA-256 OR stronger\".  What if one\nvendor decides to implement HMAC-SHA-256 and another HMAC-SHA3?  Both\nimplementations satisfy the spec but the implementations will not\ninteroperate."}]}, {"current_segment": {"sid": 2156, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nSection 8.1 of the TLS1.3 draft gives a good example of how this could be\ndone [4].   All ciphersuites that MUST or SHOULD or MAY be used are\nspecified."}, "context_segments": []}, {"current_segment": {"sid": 6165, "labels": "Thanking,Thanking,Social", "content": "\nThank you in advance."}, "context_segments": [{"sid": 2156, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nSection 8.1 of the TLS1.3 draft gives a good example of how this could be\ndone [4].   All ciphersuites that MUST or SHOULD or MAY be used are\nspecified."}]}, {"current_segment": {"sid": 2157, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThis is also a security issue. Various attacks on older versions of\nprotocols like TLS [5] resulted from the inclusion of weak crypto\nprimitives.  This has lead the community to drop several cipher suites in\nTLS v 1.3 [6]."}, "context_segments": []}, {"current_segment": {"sid": 6166, "labels": "Question,NeutralResponse,Question,ClarificationElicitation,NeutralResponse,ContextSetting,InformationSeeking,InformationProviding", "content": "OK, but when having the Offerer/Answerer model in mind, I would expect\nthat the SDP describes the sending terminal's capabilities, right?"}, "context_segments": [{"sid": 2157, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nThis is also a security issue. Various attacks on older versions of\nprotocols like TLS [5] resulted from the inclusion of weak crypto\nprimitives.  This has lead the community to drop several cipher suites in\nTLS v 1.3 [6]."}]}, {"current_segment": {"sid": 2158, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nSince we are trying to build NTP security from scratch we should be wary\nabout what crypto we want to use!"}, "context_segments": []}, {"current_segment": {"sid": 6167, "labels": "Social", "content": "Hi,\n\nMark Handley schrieb:"}, "context_segments": [{"sid": 2158, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nSince we are trying to build NTP security from scratch we should be wary\nabout what crypto we want to use!"}]}, {"current_segment": {"sid": 2159, "labels": "Agreement,NeutralResponse,InformationProviding,Agreement,NeutralResponse,ProposeAction", "content": "\nWe have to be careful here. I agree that at least some  cipher suites\nshould be specified as a minimal subset in the draft but we also need\nflexibility as new ciphers come out and older ones are found to be\nvunerable. Otherwise we will need to create new RFC's to update the RFC\nfor either of these scenarios. I'm sure that there are other\nimplementations that have run into this problem and we should see how\nthey handle it.\n"}, "context_segments": [{"sid": 2158, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nSince we are trying to build NTP security from scratch we should be wary\nabout what crypto we want to use!"}, {"sid": 6167, "labels": "Social", "content": "Hi,\n\nMark Handley schrieb:"}]}, {"current_segment": {"sid": 2160, "labels": "Question,InformationProviding,NeutralResponse,Question,InformationProviding,NeutralResponse,ProposeAction,InformationSeeking", "content": "\nWe should pick a cipher suite. Absent a compelling reason for more,\nlet's just pick one (for now).\n\nAnd we do need to provide for algorithm agility. Unfortunately, that\nis much trickier than merely parameterizing ciphers - we also need to\nunderstand the negotiation of cipher suites and prevent downgrade\nattacks.  Here's some discussion on the topic:\nhttps://tools.ietf.org/html/rfc7696\n\nFor good or ill, other negotiations (e.g. NTS version number) may also\nprovide opportunities for downgrade. Which means we may be also to\naddress multiple vulnerabilities at once.\n\nOne step toward addressing all of this might be to extend the ntp\nclient config file to include a bit for \"this name server is expected\nto use NTS (version #blah)\".  Perhaps cipher suite info could be in\nthe same config file or in the server's certs?\n\nLastly, do not be afraid to roll a new RFC to introduce a new\nalgorithm. While it makes sense to have an IANA registry for cipher\nsuites, \"standards action\" might be a good choice of policy to add a\nnew entry into that registry.\n\n-- Sam\n\nntpwg mailing list\nntpwg@lists.ntp.org\nhttp://lists.ntp.org/listinfo/ntpwg"}, "context_segments": [{"sid": 2158, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nSince we are trying to build NTP security from scratch we should be wary\nabout what crypto we want to use!"}, {"sid": 6167, "labels": "Social", "content": "Hi,\n\nMark Handley schrieb:"}, {"sid": 2159, "labels": "Agreement,NeutralResponse,InformationProviding,Agreement,NeutralResponse,ProposeAction", "content": "\nWe have to be careful here. I agree that at least some  cipher suites\nshould be specified as a minimal subset in the draft but we also need\nflexibility as new ciphers come out and older ones are found to be\nvunerable. Otherwise we will need to create new RFC's to update the RFC\nfor either of these scenarios. I'm sure that there are other\nimplementations that have run into this problem and we should see how\nthey handle it.\n"}]}, {"current_segment": {"sid": 2161, "labels": "Agreement,NeutralResponse,InformationProviding,Agreement,NeutralResponse,ProposeAction", "content": "\nWe have to be careful here. I agree that at least some  cipher suites\nshould be specified as a minimal subset in the draft but we also need\nflexibility as new ciphers come out and older ones are found to be\nvunerable. Otherwise we will need to create new RFC's to update the RFC\nfor either of these scenarios. I'm sure that there are other\nimplementations that have run into this problem and we should see how\nthey handle it.\n"}, "context_segments": [{"sid": 2158, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious", "content": "\nSince we are trying to build NTP security from scratch we should be wary\nabout what crypto we want to use!"}]}, {"current_segment": {"sid": 2162, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "> 6.  Security Token Validation"}, "context_segments": []}, {"current_segment": {"sid": 6168, "labels": "InformationProviding,InformationProviding,ContextSetting", "content": "Reading further into the new draft I had some more feedback and questions\nwhich I feel should be addressed."}, "context_segments": [{"sid": 2162, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "> 6.  Security Token Validation"}]}, {"current_segment": {"sid": 2163, "labels": "ExtensionOfPrevious,InformationProviding", "content": "> 7.  IANA Considerations"}, "context_segments": []}, {"current_segment": {"sid": 6169, "labels": "Question,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\nI see that the re-transmission text has been moved elsewhere and that\nvarious nomenclature regarding 're-transmission' has been either removed or\nit's location and context has changed to totally oppose the previous\nconcepts put forth... It seems that re-transmission is now only acceptable\nunder UDP which the standard goes to remove support for?"}, "context_segments": [{"sid": 2163, "labels": "ExtensionOfPrevious,InformationProviding", "content": "> 7.  IANA Considerations"}]}, {"current_segment": {"sid": 6170, "labels": "Agreement,Answer,Agreement,InformationProviding", "content": "\nYes, that is a fair summary. And this is well motivated.\n"}, "context_segments": [{"sid": 2163, "labels": "ExtensionOfPrevious,InformationProviding", "content": "> 7.  IANA Considerations"}, {"sid": 6169, "labels": "Question,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\nI see that the re-transmission text has been moved elsewhere and that\nvarious nomenclature regarding 're-transmission' has been either removed or\nit's location and context has changed to totally oppose the previous\nconcepts put forth... It seems that re-transmission is now only acceptable\nunder UDP which the standard goes to remove support for?"}]}, {"current_segment": {"sid": 2164, "labels": "ContextSetting,InformationProviding", "content": "review comments on -tokbind-protocol-05 aka TBPROTO:\n"}, "context_segments": []}, {"current_segment": {"sid": 6171, "labels": "Question,Question,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\nWhat about TCP? How should a RTSP 2 system deal with legacy RTSP 1\nconnection with that regard? I think there are several other places this\nmistake was made also."}, "context_segments": [{"sid": 2164, "labels": "ContextSetting,InformationProviding", "content": "review comments on -tokbind-protocol-05 aka TBPROTO:\n"}]}, {"current_segment": {"sid": 6172, "labels": "Answer,Disagreement,InformationProviding,Answer,ProposeAction", "content": "\nThis was not a mistake. The reason is that in RTSP 2.0 the RTSP client\nis not to retransmit any RTSP requests. It relies on TCP for the\nrequests to be delivered to the next hop RTSP agent. TCP will perform\nany necessary retransmission. This way the receiving agent will not be\nforced to deal with multiple duplicated of requests.\n\nThis is of course not possible if one would use UDP. However, due to\nlack of interest in UDP transport of RTSP messages this has not be\nspecified for RTSP 2.0.\n\nWhen it comes to a RTSP 2.0 agents handling of RTSP 1.0 messages, that\nhave to be implemented as best can according to RFC 2326. This will mean\nduplication handling.\n\nThe main point is that the messages are clearly indicating RTSP version,\nand thus an RTSP 2.0 message and its protocol interactions can be held\nto the tighter and more well defined behaviour of the new specification.\nIt is difficult to define how to correctly handle something that is\nunderspecified.\n"}, "context_segments": [{"sid": 2164, "labels": "ContextSetting,InformationProviding", "content": "review comments on -tokbind-protocol-05 aka TBPROTO:\n"}, {"sid": 6171, "labels": "Question,Question,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\nWhat about TCP? How should a RTSP 2 system deal with legacy RTSP 1\nconnection with that regard? I think there are several other places this\nmistake was made also."}]}, {"current_segment": {"sid": 2165, "labels": "InformationProviding,ProposeAction,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nSubstantive comments:\n\nS1. need to migrate the referred_token_binding type and its IANA\nregistration over to -tokbind-https aka HTTPSTB. see..\n\nRe: [Unbearable] -tokbind-protocol-04: verifying signature(s)\nin TokenBindingMessage.TokenBinding?\n<https://www.ietf.org/mail-archive/web/unbearable/current/msg00470.html>\n\nAs part of this, we may want to explicitly state that defining the\nsemantics of TokenBindingMessages containing more than one provided\nTokenBinding, as well as allocating new TokenBindingType value(s), is left\nto applications.\n"}, "context_segments": []}, {"current_segment": {"sid": 6173, "labels": "NeutralResponse,InformationProviding,NeutralResponse,ContextSetting,ProposeAction", "content": "\nLooking at the below comments, I think you misinterpreted the reason for\nAppendix G. It is not to provide anything that one can implement a\nworking and interoperable solution from this section. It is intended as\na starting point for someone that needs to write a specification for\nunreliable transport of RTSP messages.\n\nOne thing I do need to remark on. The registration of the RTSPU URI\nscheme. This does not fully belong here, however it is included to clean\nup the paper-trail for the RTSP URIs. Better to have a proper\nregistration, if only to make it clear that it is only defined in RFC 2326.\n"}, "context_segments": [{"sid": 2165, "labels": "InformationProviding,ProposeAction,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nSubstantive comments:\n\nS1. need to migrate the referred_token_binding type and its IANA\nregistration over to -tokbind-https aka HTTPSTB. see..\n\nRe: [Unbearable] -tokbind-protocol-04: verifying signature(s)\nin TokenBindingMessage.TokenBinding?\n<https://www.ietf.org/mail-archive/web/unbearable/current/msg00470.html>\n\nAs part of this, we may want to explicitly state that defining the\nsemantics of TokenBindingMessages containing more than one provided\nTokenBinding, as well as allocating new TokenBindingType value(s), is left\nto applications.\n"}, {"sid": 6171, "labels": "Question,Question,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\nWhat about TCP? How should a RTSP 2 system deal with legacy RTSP 1\nconnection with that regard? I think there are several other places this\nmistake was made also."}]}, {"current_segment": {"sid": 2166, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nS2. TBPROTO focuses on the server side binding TBIDs to \"security tokens\".\nHowever, there are occasions in some protocols/apps where the client side\nis obliged to bind objects to the TLS layer. See for example\n<http://w3c.github.io/webauthn/#sec-client-data>. TBPROTO should more\nclearly explain that either the client or server side may bind TBIDs into\nobjects (tokens, messages, whatever) and either side may be obliged to\nvalidate such objects, depending on application use case(s).\n"}, "context_segments": []}, {"current_segment": {"sid": 6174, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nAppendix G <http://tools.ietf.org/html/draft-ietf-mmusic-rfc2326bis-40#appendix-G>.\nRequirements for Unreliable Transport of RTSP"}, "context_segments": [{"sid": 2166, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nS2. TBPROTO focuses on the server side binding TBIDs to \"security tokens\".\nHowever, there are occasions in some protocols/apps where the client side\nis obliged to bind objects to the TLS layer. See for example\n<http://w3c.github.io/webauthn/#sec-client-data>. TBPROTO should more\nclearly explain that either the client or server side may bind TBIDs into\nobjects (tokens, messages, whatever) and either side may be obliged to\nvalidate such objects, depending on application use case(s).\n"}]}, {"current_segment": {"sid": 2167, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nS3. It seems that TBPROTO intends to be a general purpose app-layer means\nfor generating and agreeing on TBIDs, i.e., it is not just for HTTP; it\nseems to serve the purpose of mitigating the need for different app-layers\nto re-invent such a mechanism on their own. In doing so, it arguably is\nacting as general-purpose packaging of the TLS keying material exporter,\nand insulating other app-layer designers from the vagaries described in\nthe last parag of the sec cons in RFC5705..\n\nDesigning a secure mechanism that uses exporters is not necessarily\nstraightforward. This document only provides the exporter mechanism,\nbut the problem of agreeing on the surrounding context and the\nmeaning of the information passed to and from the exporter remains.\nAny new uses of the exporter mechanism should be subject to careful\nreview.\n\nIf so, this should be stated more explicitly in TBPROTO.\n"}, "context_segments": []}, {"current_segment": {"sid": 6175, "labels": "InformationProviding,ExtensionOfPrevious,ExtensionOfPrevious,ContextSetting", "content": "\nThis appendix provides guidance for those who want to implement RTSP\nmessages over unreliable transports as has been defined in RTSP 1.0\n[RFC2326 <http://tools.ietf.org/html/rfc2326>].  RFC 2326\n<http://tools.ietf.org/html/rfc2326> defined the \"rtspu\" URI scheme\nand provided some\nbasic information for the transport of RTSP messages over UDP.  The\ninformation is being provided here as there has been at at least one\ncommercial implementation and compatibility with that should be\nmaintained."}, "context_segments": [{"sid": 2167, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nS3. It seems that TBPROTO intends to be a general purpose app-layer means\nfor generating and agreeing on TBIDs, i.e., it is not just for HTTP; it\nseems to serve the purpose of mitigating the need for different app-layers\nto re-invent such a mechanism on their own. In doing so, it arguably is\nacting as general-purpose packaging of the TLS keying material exporter,\nand insulating other app-layer designers from the vagaries described in\nthe last parag of the sec cons in RFC5705..\n\nDesigning a secure mechanism that uses exporters is not necessarily\nstraightforward. This document only provides the exporter mechanism,\nbut the problem of agreeing on the surrounding context and the\nmeaning of the information passed to and from the exporter remains.\nAny new uses of the exporter mechanism should be subject to careful\nreview.\n\nIf so, this should be stated more explicitly in TBPROTO.\n"}]}, {"current_segment": {"sid": 2168, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,ExtensionOfPrevious,InformationSeeking,InformationProviding", "content": "\nS5. Should TBPROTO have a \"Required Application Programming Interfaces\"\nsection similar to that in RFC5929 [1] ?\n"}, "context_segments": []}, {"current_segment": {"sid": 6176, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nThe following points should be considered for an interoperable\nimplementation:"}, "context_segments": [{"sid": 2168, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,ExtensionOfPrevious,InformationSeeking,InformationProviding", "content": "\nS5. Should TBPROTO have a \"Required Application Programming Interfaces\"\nsection similar to that in RFC5929 [1] ?\n"}]}, {"current_segment": {"sid": 2169, "labels": "Question,InformationProviding,ExtensionOfPrevious,InformationSeeking,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nS6a. How TBIDs are \"reset\" is not described. Presumably, this is\naccomplished by the client allocating a new key pair for a server,\nresigning EKM, and including the new values in the \"next\"\nTokenBindingMessage sent to the server, and servers need to be vigilant\nabout noticing new TBIDs and re-binding application security\ntokens/messages as appropriate, yes?\n\nS6b. Our Security AD verbally expressed to some of us (at IETF-94?) that\nsimply saying \"TBIDs can be reset by the user at any time\" is insufficient\nguidance to app-layer designers regarding a privacy-preserving utilization\nof TBPROTO. What else might be added? Perhaps suggestion(s) that the\napp-layer periodically auto-reset TBIDs?\n"}, "context_segments": []}, {"current_segment": {"sid": 6177, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\no  Requests shall be acknowledged by the receiver.  If there is no\nacknowledgement, the sender may resend the same message after a\ntimeout of one round-trip time (RTT).  Any retransmissions due to\nlack of acknowledgement must carry the same sequence number as the\noriginal request."}, "context_segments": [{"sid": 2169, "labels": "Question,InformationProviding,ExtensionOfPrevious,InformationSeeking,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nS6a. How TBIDs are \"reset\" is not described. Presumably, this is\naccomplished by the client allocating a new key pair for a server,\nresigning EKM, and including the new values in the \"next\"\nTokenBindingMessage sent to the server, and servers need to be vigilant\nabout noticing new TBIDs and re-binding application security\ntokens/messages as appropriate, yes?\n\nS6b. Our Security AD verbally expressed to some of us (at IETF-94?) that\nsimply saying \"TBIDs can be reset by the user at any time\" is insufficient\nguidance to app-layer designers regarding a privacy-preserving utilization\nof TBPROTO. What else might be added? Perhaps suggestion(s) that the\napp-layer periodically auto-reset TBIDs?\n"}]}, {"current_segment": {"sid": 2170, "labels": "Question,ExtensionOfPrevious,Question,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\nS7. Section 6 Security Token Validation specifies conditions (eg incorrect\nTBID) upon which the server \"MUST discard the token\". Are there not a\nrange of application behaviors that might occur, e.g., terminating the\napplication session? Or, is this particular behavior defined in order to\naccommodate resetting of TBIDs by the client-side whereupon there may be a\nrace condition before all the server-issued bound app sec tokens contain\nthe updated TBID? Is this behavior appropriate for all apps in all cases?\nwhat if an incorrect bound TBID is being caused by a MITM?\n"}, "context_segments": []}, {"current_segment": {"sid": 6178, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\no  The round-trip time can be estimated as in TCP (RFC 6298\n<http://tools.ietf.org/html/rfc6298>)\n[RFC6298 <http://tools.ietf.org/html/rfc6298>], with an initial\nround-trip value of 500 ms.  An\nimplementation may cache the last RTT measurement as the initial\nvalue for future connections."}, "context_segments": [{"sid": 2170, "labels": "Question,ExtensionOfPrevious,Question,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\nS7. Section 6 Security Token Validation specifies conditions (eg incorrect\nTBID) upon which the server \"MUST discard the token\". Are there not a\nrange of application behaviors that might occur, e.g., terminating the\napplication session? Or, is this particular behavior defined in order to\naccommodate resetting of TBIDs by the client-side whereupon there may be a\nrace condition before all the server-issued bound app sec tokens contain\nthe updated TBID? Is this behavior appropriate for all apps in all cases?\nwhat if an incorrect bound TBID is being caused by a MITM?\n"}]}, {"current_segment": {"sid": 2171, "labels": "Question,ExtensionOfPrevious,ProposeAction,InformationSeeking,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nS8. Section 8.2 Security Token Replay is fairly light on details regarding\nhow an application layer can utilize TBPROTO to detect MITM attacks,\nperhaps appropriately generalizing and including the 2nd parag from [2]\nwould help readers better understand how this would work?\n"}, "context_segments": []}, {"current_segment": {"sid": 6179, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\no  The Timestamp header (Section 18.53\n<http://tools.ietf.org/html/draft-ietf-mmusic-rfc2326bis-40#section-18.53>)\nis used to avoid the\nretransmission ambiguity problem [Stevens98\n<http://tools.ietf.org/html/draft-ietf-mmusic-rfc2326bis-40#ref-Stevens98>]."}, "context_segments": [{"sid": 2171, "labels": "Question,ExtensionOfPrevious,ProposeAction,InformationSeeking,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nS8. Section 8.2 Security Token Replay is fairly light on details regarding\nhow an application layer can utilize TBPROTO to detect MITM attacks,\nperhaps appropriately generalizing and including the 2nd parag from [2]\nwould help readers better understand how this would work?\n"}]}, {"current_segment": {"sid": 2172, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,Disagreement,ExtensionOfPrevious,ProposeAction", "content": "\nS9. I would not say \"TLS Token Binding IDs are never transmitted in clear\ntext..\" -- this could easily occur in an HTTP-based web app that\ninadvertently leaks cookies, e.g. by retrieving some image over plain\nhttp. addressing this implies adding sec cons wrt such risks, eg \"apps\nneed to take precautions to ensure bound sec tokens/messages are not\n'leaked' over insecure connections such as can occur due to non-https\nlink(s) lurking in a web app, e.g., an image load. HTTP-based applications\nshould employ techniques such as HSTS and HPKP in order to guard against\nsuch situations.\"\n"}, "context_segments": []}, {"current_segment": {"sid": 6180, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\no  The registered default port for RTSP over UDP for the server is\n554."}, "context_segments": [{"sid": 2172, "labels": "InformationProviding,ExtensionOfPrevious,InformationProviding,Disagreement,ExtensionOfPrevious,ProposeAction", "content": "\nS9. I would not say \"TLS Token Binding IDs are never transmitted in clear\ntext..\" -- this could easily occur in an HTTP-based web app that\ninadvertently leaks cookies, e.g. by retrieving some image over plain\nhttp. addressing this implies adding sec cons wrt such risks, eg \"apps\nneed to take precautions to ensure bound sec tokens/messages are not\n'leaked' over insecure connections such as can occur due to non-https\nlink(s) lurking in a web app, e.g., an image load. HTTP-based applications\nshould employ techniques such as HSTS and HPKP in order to guard against\nsuch situations.\"\n"}]}, {"current_segment": {"sid": 2173, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nS10. I would remove the triple-handshake admonition in section 4, and\nperhaps the one in sec cons, but in any case add to sec cons that there\nare important sec cons regarding the underlying TLS connection in\n[I-D.ietf-tokbind-negotiation] that could mitigate the app-layer's\nTB-based security benefits if they are not heeded.\n"}, "context_segments": []}, {"current_segment": {"sid": 6181, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\no  RTSP messages can be carried over any lower-layer transport\nprotocol that is 8-bit clean."}, "context_segments": [{"sid": 2173, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\nS10. I would remove the triple-handshake admonition in section 4, and\nperhaps the one in sec cons, but in any case add to sec cons that there\nare important sec cons regarding the underlying TLS connection in\n[I-D.ietf-tokbind-negotiation] that could mitigate the app-layer's\nTB-based security benefits if they are not heeded.\n"}]}, {"current_segment": {"sid": 2174, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\nS11. Regarding the design decision: TokenBindingType is not within\nTokenBindingID -- it is within the enclosing TokenBinding because\nTokenBindingIDs (TBIDs) may be conveyed in TBMSG as either provided_ or\nsome other app-layer-defined TBType. If the app-layer has defined\nadditional TBType(s), the server-side would want to remember each TBID's\ntype, yes?\n"}, "context_segments": []}, {"current_segment": {"sid": 6182, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\no  RTSP messages are vulnerable to bit errors and should not be\nsubjected to them."}, "context_segments": [{"sid": 2174, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,InformationProviding,ExtensionOfPrevious,ContextSetting,InformationSeeking", "content": "\nS11. Regarding the design decision: TokenBindingType is not within\nTokenBindingID -- it is within the enclosing TokenBinding because\nTokenBindingIDs (TBIDs) may be conveyed in TBMSG as either provided_ or\nsome other app-layer-defined TBType. If the app-layer has defined\nadditional TBType(s), the server-side would want to remember each TBID's\ntype, yes?\n"}]}, {"current_segment": {"sid": 2175, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,ExtensionOfPrevious,ContextSetting,ProposeAction,InformationSeeking,InformationProviding", "content": "\nS12. Perhaps spec should stipulate \"server must ignore TBTypes it does not\nunderstand\" -- or not?\n"}, "context_segments": []}, {"current_segment": {"sid": 6183, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "\no  Source authentication, or at least validation that RTSP messages\ncomes from the same entity becomes extremely important, as session\nhijacking may be substantially easier for RTSP message transport\nusing an unreliable protocol like UDP than for TCP."}, "context_segments": [{"sid": 2175, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,ExtensionOfPrevious,ContextSetting,ProposeAction,InformationSeeking,InformationProviding", "content": "\nS12. Perhaps spec should stipulate \"server must ignore TBTypes it does not\nunderstand\" -- or not?\n"}]}, {"current_segment": {"sid": 2176, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\n[1] https://tools.ietf.org/html/rfc5929#section-7\n\n[2] <https://tools.ietf.org/html/draft-ietf-tokbind-https-02#section-4.4>\n"}, "context_segments": []}, {"current_segment": {"sid": 6184, "labels": "Question,Question,ExtensionOfPrevious,ContextSetting,InformationSeeking,InformationProviding", "content": "\nBullet 5 - *TCP is too, what does this statement add?*"}, "context_segments": [{"sid": 2176, "labels": "ExtensionOfPrevious,InformationProviding", "content": "\n[1] https://tools.ietf.org/html/rfc5929#section-7\n\n[2] <https://tools.ietf.org/html/draft-ietf-tokbind-https-02#section-4.4>\n"}]}, {"current_segment": {"sid": 2177, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,ExtensionOfPrevious,ContextSetting,ProposeAction,InformationSeeking", "content": "\nOverall editorial issues/comments (in no particular order):\n\nE1. the mechanics of verifying the signature(s) in a TokenBindingMessage\nare not spec'd in detail -- experienced crypto folk may know what to do,\nbut others may not.\n\nE2. ought to clearly delineate \"server processing model\" and \"client\nprocessing model\". (e.g. see https://tools.ietf.org/html/rfc6797)\n\nE3. section \"1. Introduction\" and section \"2. token binding protocol\noverview\" are quite similar -- perhaps they could be combined?\n\nE4. If section 3 and 4 are massaged per E2, section 5 becomes superfluous\n(it seemed to in my experimenting).\n\nE4. the security considerations section contains RFC2119 requirements\nlanguage -- some downstream reviews may frown on this.\n\nE5. TBPROTO in and of itself does not \"prevent\" export and replay of app\nsecurity tokens -- rather it facilitates detection of such occurances.\n\nE6. Terminology is fairly loose, e.g. terms such as \"token\", \"security\ntoken\", \"bound token\", \"bound security token\" are not used as consistently\nas they could be.\n\nE7. Various spec portions could benefit from further wordsmithing --\nsuggestions are inline below...\n"}, "context_segments": []}, {"current_segment": {"sid": 6185, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\n*This information in the header seems to contradict what information\nis given later on in Appendix I.*"}, "context_segments": [{"sid": 2177, "labels": "Question,InformationProviding,ExtensionOfPrevious,Question,ExtensionOfPrevious,ContextSetting,ProposeAction,InformationSeeking", "content": "\nOverall editorial issues/comments (in no particular order):\n\nE1. the mechanics of verifying the signature(s) in a TokenBindingMessage\nare not spec'd in detail -- experienced crypto folk may know what to do,\nbut others may not.\n\nE2. ought to clearly delineate \"server processing model\" and \"client\nprocessing model\". (e.g. see https://tools.ietf.org/html/rfc6797)\n\nE3. section \"1. Introduction\" and section \"2. token binding protocol\noverview\" are quite similar -- perhaps they could be combined?\n\nE4. If section 3 and 4 are massaged per E2, section 5 becomes superfluous\n(it seemed to in my experimenting).\n\nE4. the security considerations section contains RFC2119 requirements\nlanguage -- some downstream reviews may frown on this.\n\nE5. TBPROTO in and of itself does not \"prevent\" export and replay of app\nsecurity tokens -- rather it facilitates detection of such occurances.\n\nE6. Terminology is fairly loose, e.g. terms such as \"token\", \"security\ntoken\", \"bound token\", \"bound security token\" are not used as consistently\nas they could be.\n\nE7. Various spec portions could benefit from further wordsmithing --\nsuggestions are inline below...\n"}]}, {"current_segment": {"sid": 2178, "labels": "ContextSetting,InformationProviding", "content": ">                  The Token Binding Protocol Version 1.0\n>                      draft-ietf-tokbind-protocol-05"}, "context_segments": []}, {"current_segment": {"sid": 6186, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\n*Additionally the information related to re-transmission and Timestamp\nis still ambiguous IMHO as the Timestamp header plays no role TCP\nre-transmissions, furthermore since it's syntax [The Timestamp header]\nonly has meaning to a Client the Server has no way of measuring or\ncomparing the previous Timestamp unless they attempt parsing of\nvarious ways of conveying the information. *"}, "context_segments": [{"sid": 2178, "labels": "ContextSetting,InformationProviding", "content": ">                  The Token Binding Protocol Version 1.0\n>                      draft-ietf-tokbind-protocol-05"}]}, {"current_segment": {"sid": 2179, "labels": "InformationProviding,ContextSetting", "content": "> 1.  Introduction\n>    Servers generate various security tokens (e.g.  HTTP cookies, OAuth\n>    tokens) for applications to access protected resources.  Any party in\n>    possession of such token gains access to the protected resource.\n>    Attackers export bearer tokens from the user's machine, present them\n>    to the servers, and impersonate authenticated users.  The idea of\n>    Token Binding is to prevent such attacks by cryptographically binding\n>    security tokens to the TLS layer.\n>    A TLS Token Binding is established by the user agent generating a"}, "context_segments": []}, {"current_segment": {"sid": 6187, "labels": "ProposeAction,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n*There needs to be more definite syntax related to Timestamp and it\nneeds to further be indicated that TCP re-transmissions can cause\npartial data to appear to a receiver and that when using TCP and how\nto handle this as I previously indicated. *"}, "context_segments": [{"sid": 2179, "labels": "InformationProviding,ContextSetting", "content": "> 1.  Introduction\n>    Servers generate various security tokens (e.g.  HTTP cookies, OAuth\n>    tokens) for applications to access protected resources.  Any party in\n>    possession of such token gains access to the protected resource.\n>    Attackers export bearer tokens from the user's machine, present them\n>    to the servers, and impersonate authenticated users.  The idea of\n>    Token Binding is to prevent such attacks by cryptographically binding\n>    security tokens to the TLS layer.\n>    A TLS Token Binding is established by the user agent generating a"}]}, {"current_segment": {"sid": 2180, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\ns/the user agent/a client-side application (e.g., a user agent)/\n"}, "context_segments": []}, {"current_segment": {"sid": 6188, "labels": "ProposeAction,ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\n*Some text about minimum packet size with respect to Blocksize\nutilized would also be beneficial so there is no reason for clients to\nattempt to verify data which cannot be verified by a packet with no\nTimestamp header (Rtsp or Rtp or otherwise e.g. a Rtcp packet)*"}, "context_segments": [{"sid": 2180, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\ns/the user agent/a client-side application (e.g., a user agent)/\n"}]}, {"current_segment": {"sid": 2181, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": ">    private-public key pair (possibly within a secure hardware module,\n>    such as TPM) per target server, and proving possession of the private\n>    key on every TLS connection to the target server.  The proof of\n>    possession involves signing the exported keying material [RFC5705]\n>    for the TLS connection with the private key.  The corresponding\n>    public key is included in the TLS Token Binding identifier structure\n>    (described in the \"TLS Token Binding ID Format\" section of this\n>    document).  TLS Token Bindings are long-lived, i.e. they encompass\n>    multiple TLS connections and TLS sessions between a given client and\n>    server.  To protect privacy, TLS Token Binding IDs are never\n>    transmitted in clear text and can be reset by the user at any time,\n>    e.g. when clearing browser cookies.\n>    When issuing a security token to a client that supports TLS Token\n>    Binding, a server includes the client's TLS Token Binding ID in the\n>    token.  Later on, when a client presents a security token containing\n>    a TLS Token Binding ID, the server makes sure the ID in the token\n>    matches the ID of the TLS Token Binding established with the client.\n>    In the case of a mismatch, the server discards the token.\n>    In order to successfully export and replay a bound security token,\n>    the attacker needs to also be able to export the client's private\n>    key, which is hard to do in the case of the key generated in a secure\n>    hardware module.\n> 1.1.  Requirements Language\n>    The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n>    \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n>    document are to be interpreted as described in [RFC2119].\n> 2.  Token Binding Protocol Overview"}, "context_segments": []}, {"current_segment": {"sid": 6189, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\n*The contradicting text from Appendix I is listed below.*"}, "context_segments": [{"sid": 2181, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": ">    private-public key pair (possibly within a secure hardware module,\n>    such as TPM) per target server, and proving possession of the private\n>    key on every TLS connection to the target server.  The proof of\n>    possession involves signing the exported keying material [RFC5705]\n>    for the TLS connection with the private key.  The corresponding\n>    public key is included in the TLS Token Binding identifier structure\n>    (described in the \"TLS Token Binding ID Format\" section of this\n>    document).  TLS Token Bindings are long-lived, i.e. they encompass\n>    multiple TLS connections and TLS sessions between a given client and\n>    server.  To protect privacy, TLS Token Binding IDs are never\n>    transmitted in clear text and can be reset by the user at any time,\n>    e.g. when clearing browser cookies.\n>    When issuing a security token to a client that supports TLS Token\n>    Binding, a server includes the client's TLS Token Binding ID in the\n>    token.  Later on, when a client presents a security token containing\n>    a TLS Token Binding ID, the server makes sure the ID in the token\n>    matches the ID of the TLS Token Binding established with the client.\n>    In the case of a mismatch, the server discards the token.\n>    In order to successfully export and replay a bound security token,\n>    the attacker needs to also be able to export the client's private\n>    key, which is hard to do in the case of the key generated in a secure\n>    hardware module.\n> 1.1.  Requirements Language\n>    The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n>    \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n>    document are to be interpreted as described in [RFC2119].\n> 2.  Token Binding Protocol Overview"}]}, {"current_segment": {"sid": 2182, "labels": "ExtensionOfPrevious,Question,Question,InformationProviding,ProposeAction,InformationSeeking", "content": "\nthis section largely duplicates the Introduction -- could the intro be\ntrimmed way down and then this section effectively provides the underlying\ndetails that are summarized in the Intro?\n"}, "context_segments": []}, {"current_segment": {"sid": 6190, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\n*  The description on how rtspu works is not part of the core\nspecification and will require external description.  Only that"}, "context_segments": [{"sid": 2182, "labels": "ExtensionOfPrevious,Question,Question,InformationProviding,ProposeAction,InformationSeeking", "content": "\nthis section largely duplicates the Introduction -- could the intro be\ntrimmed way down and then this section effectively provides the underlying\ndetails that are summarized in the Intro?\n"}]}, {"current_segment": {"sid": 2183, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": ">    The client and server use the Token Binding Negotiation TLS Extension\n>    [I-D.ietf-tokbind-negotiation] to negotiate the Token Binding\n>    protocol version and the parameters (signature algorithm, length) of\n>    the Token Binding key.  This negotiation does not require additional\n>    round-trips."}, "context_segments": []}, {"current_segment": {"sid": 6191, "labels": "ExtensionOfPrevious,ExtensionOfPrevious,ContextSetting,InformationProviding", "content": "\nit exists is defined here and some requirements for the\ntransport is provided."}, "context_segments": [{"sid": 2183, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": ">    The client and server use the Token Binding Negotiation TLS Extension\n>    [I-D.ietf-tokbind-negotiation] to negotiate the Token Binding\n>    protocol version and the parameters (signature algorithm, length) of\n>    the Token Binding key.  This negotiation does not require additional\n>    round-trips."}]}, {"current_segment": {"sid": 2184, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,InformationSeeking,InformationProviding", "content": "\nwrt \"the parameters (signature algorithm, length)\" -- this is now\neffectively referred to as \"key parameters\" yes?\n"}, "context_segments": []}, {"current_segment": {"sid": 6192, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\n*Additionally this section seems to further contradict the above paragraphs.*"}, "context_segments": [{"sid": 2184, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,InformationSeeking,InformationProviding", "content": "\nwrt \"the parameters (signature algorithm, length)\" -- this is now\neffectively referred to as \"key parameters\" yes?\n"}]}, {"current_segment": {"sid": 2185, "labels": "ClarificationElicitation,ExtensionOfPrevious,ContextSetting,InformationSeeking,InformationProviding", "content": ">    The Token Binding protocol consists of one message sent by the client\n>    to the server, proving possession of one or more client-generated\n>    asymmetric keys.  This message is only sent if the client and server\n>    agree on the use of the Token Binding protocol and the key\n>    parameters.  The Token Binding message is sent with the application\n>    protocol data in TLS application_data records."}, "context_segments": []}, {"current_segment": {"sid": 6193, "labels": "InformationProviding,InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\n4.2 <http://tools.ietf.org/html/draft-ietf-mmusic-rfc2326bis-40#section-4.2>.\nRTSP IRI and URI"}, "context_segments": [{"sid": 2185, "labels": "ClarificationElicitation,ExtensionOfPrevious,ContextSetting,InformationSeeking,InformationProviding", "content": ">    The Token Binding protocol consists of one message sent by the client\n>    to the server, proving possession of one or more client-generated\n>    asymmetric keys.  This message is only sent if the client and server\n>    agree on the use of the Token Binding protocol and the key\n>    parameters.  The Token Binding message is sent with the application\n>    protocol data in TLS application_data records."}]}, {"current_segment": {"sid": 2186, "labels": "Question,InformationProviding,ExtensionOfPrevious,ClarificationElicitation,InformationProviding,ContextSetting,ProposeAction,InformationSeeking", "content": "\nwrt... \"The Token Binding message is sent with the application\nprotocol data in TLS application_data records\"\n\n...in other words, after Token Binding negotiation during TLS handshake\n[I-D.ietf-tokbind-negotiation], the Token Binding msg is created by the\nclient and conveyed to the server in the app layer protocol which is\nrunning over TLS within whose context the token binding ID was\nestablished. Yes?\n\nperhaps re-state.\n"}, "context_segments": []}, {"current_segment": {"sid": 6194, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": "\nRTSP 2.0 defines and registers or updates three URI schemes \"rtsp\",\n\"rtsps\" and \"rtspu\".  The usage of the last, \"rtspu\", is unspecified\nin RTSP 2.0, and is defined here to register the URI scheme that was\ndefined in RTSP 1.0.  The \"rtspu\" scheme indicates unspecified\ntransport of the RTSP messages over unreliable transport (UDP in RTSP\n1.0).  An RTSP server MUST respond with an error code indicating the\n\"rtspu\" scheme is not implemented (501) to a request that carries a\n\"rtspu\" URI scheme."}, "context_segments": [{"sid": 2186, "labels": "Question,InformationProviding,ExtensionOfPrevious,ClarificationElicitation,InformationProviding,ContextSetting,ProposeAction,InformationSeeking", "content": "\nwrt... \"The Token Binding message is sent with the application\nprotocol data in TLS application_data records\"\n\n...in other words, after Token Binding negotiation during TLS handshake\n[I-D.ietf-tokbind-negotiation], the Token Binding msg is created by the\nclient and conveyed to the server in the app layer protocol which is\nrunning over TLS within whose context the token binding ID was\nestablished. Yes?\n\nperhaps re-state.\n"}]}, {"current_segment": {"sid": 2187, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": ">    A server receiving the Token Binding message verifies that the key\n>    parameters in the message match the Token Binding parameters\n>    negotiated via [I-D.ietf-tokbind-negotiation], and then validates the\n>    signatures contained in the Token Binding message.  If either of\n>    these checks fails, the server terminates the connection, otherwise\n>    the TLS Token Binding is successfully established with the ID\n>    contained in the Token Binding message.\n>    When a server supporting the Token Binding protocol receives a bound\n>    token, the server compares the TLS Token Binding ID in the security\n>    token with the TLS Token Binding ID established with the client.  If\n>    the bound token came from a TLS connection without a Token Binding,\n>    or if the IDs don't match, the token is discarded.\n>    This document defines the format of the Token Binding protocol\n>    message, the process of establishing a TLS Token Binding, the format\n>    of the Token Binding ID, and the process of validating a security\n>    token."}, "context_segments": []}, {"current_segment": {"sid": 6195, "labels": "Question,Question,ExtensionOfPrevious,ProposeAction,InformationSeeking,InformationProviding", "content": "\nLastly wouldn't that also mean that a client can still use UDP but their\nrequests simply can't have a 'rtspu' scheme? I am not sure if that wan\nintended or not but it seems silly to indicate that the scheme of the\nlocation means anything when in fact the protocol of the connection is what\nreally matters. Why would anyone care if a client used a different scheme\nin their request?"}, "context_segments": [{"sid": 2187, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": ">    A server receiving the Token Binding message verifies that the key\n>    parameters in the message match the Token Binding parameters\n>    negotiated via [I-D.ietf-tokbind-negotiation], and then validates the\n>    signatures contained in the Token Binding message.  If either of\n>    these checks fails, the server terminates the connection, otherwise\n>    the TLS Token Binding is successfully established with the ID\n>    contained in the Token Binding message.\n>    When a server supporting the Token Binding protocol receives a bound\n>    token, the server compares the TLS Token Binding ID in the security\n>    token with the TLS Token Binding ID established with the client.  If\n>    the bound token came from a TLS connection without a Token Binding,\n>    or if the IDs don't match, the token is discarded.\n>    This document defines the format of the Token Binding protocol\n>    message, the process of establishing a TLS Token Binding, the format\n>    of the Token Binding ID, and the process of validating a security\n>    token."}]}, {"current_segment": {"sid": 2188, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\ns/security token/bound security token/\n"}, "context_segments": []}, {"current_segment": {"sid": 6196, "labels": "NeutralResponse,InformationSeeking,InformationProviding,ContextSetting,ProposeAction,StateDecision,Social", "content": "Hi Julius,\n\nDropping AVTCORE WG as they are not the relevant WG for this.\n\nI am just back from a quite long parental leave. I have not yet anywhere\nnear to catch up on my email. Thus, I have not read more than some few\nof your emails.\n\nFirst of all, I see just from the volume that you appreciate how broken\nthe specification text of RFC 2326 is. That is why we started back in\n2003 to produce an updated version. That work has finally in principal\nconcluded by the approval for publication of\ndraft-ietf-mmusic-rfc2326bis. The only thing preventing this document\nfrom being published as an RFC is a missing normative reference.\n\nThus, we are currently in a state where it is difficult to make any\nsignificant changes to the text. Wording corrections would still be\npossible to fix. Also if you find anything that is so significant that\nit must be corrected then we\n\nFiling Errata on RFC 2326 is also not particular useful.\n\nHaving said that I will attempt to answer your issue below.\n"}, "context_segments": [{"sid": 2188, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\ns/security token/bound security token/\n"}]}, {"current_segment": {"sid": 2189, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": ">            Token Binding Negotiation TLS Extension\n>    [I-D.ietf-tokbind-negotiation] describes the negotiation of the Token\n>    Binding protocol and key parameters.  Token Binding over HTTP\n>    [I-D.ietf-tokbind-https] explains how the Token Binding message is\n>    encapsulated within HTTP/1.1 [RFC7230] or HTTP/2 [RFC7540] messages.\n>    [I-D.ietf-tokbind-https] also describes Token Binding between\n>    multiple communicating parties: User Agent, Identity Provider and\n>    Relying Party.\n> 3.  Token Binding Protocol Message\n>    The Token Binding message is sent by the client and proves possession\n>    of one or more private keys held by the client.  This message MUST be\n>    sent if the client and server successfully negotiated the use of the\n>    Token Binding protocol via [I-D.ietf-tokbind-negotiation], and MUST\n>    NOT be sent otherwise.  This message MUST be sent in the client's\n>    first application protocol message.  This message MAY also be sent in\n>    subsequent application protocol messages, proving possession of other\n>    keys by the same client, to facilitate token binding between more\n>    than two communicating parties."}, "context_segments": []}, {"current_segment": {"sid": 2190, "labels": "ExtensionOfPrevious,ProposeAction,ProposeAction,InformationProviding", "content": "\nsuggest beginning new parag here..\n"}, "context_segments": []}, {"current_segment": {"sid": 2191, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": ">                                       Token Binding over HTTP\n>    [I-D.ietf-tokbind-https] specifies the encapsulation of the Token\n>    Binding message in the application protocol messages, and the\n>    scenarios involving more than two communicating parties.  The Token\n>    Binding message format is defined using TLS specification language:\n> enum {\n>     rsa2048_pkcs1.5(0), rsa2048_pss(1), ecdsap256(2), (255)\n> } TokenBindingKeyParameters;"}, "context_segments": []}, {"current_segment": {"sid": 2192, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "\nadd comment on above:\n\n/* imported from [I-D.ietf-tokbind-negotiation] */\n"}, "context_segments": []}, {"current_segment": {"sid": 2193, "labels": "InformationProviding,ContextSetting", "content": "> struct {\n>     opaque modulus<1..2^16-1>;\n>     opaque publicexponent<1..2^8-1>;\n> } RSAPublicKey;\n> struct {\n>     opaque point <1..2^8-1>;\n> } ECPoint;\n> enum {\n>     provided_token_binding(0), referred_token_binding(1), (255)\n> } TokenBindingType;\n> struct {\n>     TokenBindingKeyParameters key_parameters;\n>     select (key_parameters) {\n>         case rsa2048_pkcs1.5:\n>         case rsa2048_pss:\n>             RSAPublicKey rsapubkey;\n>         case ecdsap256:\n>             ECPoint point;"}, "context_segments": []}, {"current_segment": {"sid": 2194, "labels": "ExtensionOfPrevious,ProposeAction,ProposeAction,InformationProviding", "content": "\nmissing a semi-colon, should be:\n"}, "context_segments": []}, {"current_segment": {"sid": 2195, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": "> } TokenBindingID;\n> enum {\n>     (255)                       // No initial ExtensionType registrations\n> } ExtensionType;"}, "context_segments": []}, {"current_segment": {"sid": 2196, "labels": "InformationProviding,InformationProviding,ProposeAction", "content": "\ncomments in TLS presentation language are: /* . . . */\nsee https://tools.ietf.org/html/draft-ietf-tls-tls13#section-4.2\n"}, "context_segments": []}, {"current_segment": {"sid": 2197, "labels": "InformationProviding,ContextSetting", "content": "> struct {\n>     ExtensionType extension_type;\n>     opaque extension_data<0..2^16-1>;\n> } Extension;\n> struct {\n>     TokenBindingType tokenbinding_type;\n>     TokenBindingID tokenbindingid;\n>     opaque signature<0..2^16-1>;// Signature over the exported keying\n>material value\n>     Extension extensions<0..2^16-1>;\n> } TokenBinding;\n> struct {\n>     TokenBinding tokenbindings<0..2^16-1>;\n> } TokenBindingMessage;"}, "context_segments": []}, {"current_segment": {"sid": 2198, "labels": "Question,ClarificationElicitation,InformationProviding,ProposeAction,InformationSeeking", "content": "\nis it legit for a TokenBindingMessage to be an empty sequence as implied\nby the \"tokenbindings<0..2^16-1>\" declaration? no, it is not, see last\nparagraph below in this section.\n\n[this sort of inconsistency seems to also exist in RFC5246 so I am\ndoubting it is something to worry about.]\n"}, "context_segments": []}, {"current_segment": {"sid": 2199, "labels": "Question,ClarificationElicitation,ContextSetting,ProposeAction,InformationSeeking,InformationProviding", "content": "\nThe below paragraphs appear to be client-side processing rules, yes? I\nsuggest identifying them as such.\n"}, "context_segments": []}, {"current_segment": {"sid": 2200, "labels": "InformationProviding,ExtensionOfPrevious", "content": ">    The Token Binding message consists of a series of TokenBinding\n>    structures containing the type of the token binding, the\n>    TokenBindingID, a signature over the exported keying material (EKM)\n>    value, optionally followed by Extension structures.\n>    This document defines two token binding types: provided_token_binding\n>    used to establish a Token Binding when connecting to a server, and\n>    referred_token_binding used when requesting tokens to be presented to\n>    a different server.  Token Binding over HTTP [I-D.ietf-tokbind-https]\n>    describes Token Binding between multiple communicating parties: User\n>    Agent, Identity Provider and Relying Party.  See also Section 7.1\n>    When an rsa2048_pkcs1.5 or rsa2048_pss key is used,\n>    TokenBinding.signature contains the signature generated using,\n>    respectively, the RSASSA-PKCS1-v1_5 or RSASSA-PSS signature scheme\n>    defined in [RFC3447].  RSAPublicKey.modulus and\n>    RSAPublicKey.publicexponent contain the length-prefixed modulus and\n>    exponent of the RSA public key represented in big-endian format.\n>    When an ecdsap256 key is used, TokenBinding.signature contains a pair\n>    of integers, R followed by S, as defined in [ANSI.X9-62.2005].  R and\n>    S are encoded in big-endian format.  ECPoint.point contains the X\n>    coordinate followed by the Y coordinate.  The X and Y coordinates are\n>    unsigned integers encoded in big-endian format.  Future\n>    specifications may define Token Binding keys using other elliptic\n>    curves with their corresponding signature and point formats.\n>    The EKM is obtained using the Keying Material Exporters for TLS\n>    defined in [RFC5705], by supplying the following input values:\n>    o  Label: The ASCII string \"EXPORTER-Token-Binding\" with no\n>       terminating NUL.\n>    o  Context value: NULL (no application context supplied).\n>    o  Length: 32 bytes."}, "context_segments": []}, {"current_segment": {"sid": 2201, "labels": "Question,Question,ContextSetting,ProposeAction,InformationSeeking,InformationProviding", "content": "\nthe below 2 parags are essentially server-side processing rules -- fold\nthem into the next section and rename it \"server processing model\"?\n"}, "context_segments": []}, {"current_segment": {"sid": 2202, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ExtensionOfPrevious", "content": ">    An implementation MUST ignore any unknown extensions.  Initially, no\n>    extension types are defined (see Section 7.2).  One of the possible\n>    uses of extensions envisioned at the time of this writing is\n>    attestation: cryptographic proof that allows the server to verify\n>    that the Token Binding key is hardware-bound.  The definitions of\n>    such Token Binding protocol extensions are outside the scope of this\n>    specification.\n>    At least one TokenBinding MUST be included in the Token Binding\n>    message.  The signature algorithm and key length used in the\n>    TokenBinding MUST match the parameters negotiated via\n>    [I-D.ietf-tokbind-negotiation].  The client SHOULD generate and store\n>    Token Binding keys in a secure manner that prevents key export.  In\n>    order to prevent cooperating servers from linking user identities,\n>    different keys SHOULD be used by the client for connections to\n>    different servers,"}, "context_segments": []}, {"current_segment": {"sid": 2203, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\ns/cooperating servers/colluding servers/\n"}, "context_segments": []}, {"current_segment": {"sid": 2204, "labels": "ExtensionOfPrevious,ProposeAction,ContextSetting,InformationProviding", "content": "\naccording to the token scoping rules of the"}, "context_segments": []}, {"current_segment": {"sid": 2205, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": ">    application protocol.\n> 4.  Establishing a TLS Token Binding"}, "context_segments": []}, {"current_segment": {"sid": 2206, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\ns/Token Binding/Token Binding ID/\n"}, "context_segments": []}, {"current_segment": {"sid": 2207, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ProposeAction", "content": "\nthis section is written from the perspective of the server side upon\nreceipt of an app layer msg containing a TokenBindingMessage, perhaps be\nmore explicit and have an intro sentence like..\n\nUpon receipt by the server of a client's TokenBindingMessage via the\napplication layer protocol, the server performs these checks:\n"}, "context_segments": []}, {"current_segment": {"sid": 2208, "labels": "InformationProviding,ContextSetting", "content": ">    The triple handshake vulnerability in TLS 1.2 and older TLS versions\n>    affects the security of the Token Binding protocol, as described in\n>    the \"Security Considerations\" section below.  Therefore, the server\n>    MUST NOT negotiate the use of the Token Binding protocol with these\n>    TLS versions, unless the server also negotiates Extended Master\n>    Secret [RFC7627] and Renegotiation Indication [RFC5746] TLS\n>    extensions."}, "context_segments": []}, {"current_segment": {"sid": 2209, "labels": "Question,Question,InformationProviding,ExtensionOfPrevious,ProposeAction,InformationSeeking", "content": "\nthe above admonition is TLS-specific and is already addressed in\n[I-D.ietf-tokbind-negotiation] so remove it?\n"}, "context_segments": []}, {"current_segment": {"sid": 2210, "labels": "InformationProviding,ContextSetting", "content": ">    The server MUST terminate the connection if the use of the Token\n>    Binding protocol was not negotiated, but the client sends the Token\n>    Binding message."}, "context_segments": []}, {"current_segment": {"sid": 2211, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\ns/not negotiated/not negotiated at the TLS layer/\n"}, "context_segments": []}, {"current_segment": {"sid": 2212, "labels": "InformationProviding,ContextSetting", "content": ">                       If the Token Binding type is\n>    \"provided_token_binding\", the server MUST verify that the signature\n>    algorithm (including elliptic curve in the case of ECDSA) and key\n>    length in the Token Binding message match those negotiated via\n>    [I-D.ietf-tokbind-negotiation].  In the case of a mismatch, the\n>    server MUST terminate the connection."}, "context_segments": []}, {"current_segment": {"sid": 2213, "labels": "ProposeAction,InformationProviding,ProposeAction", "content": "\nsuggest..\n\nOLD:\nthe signature algorithm (including elliptic curve in the case of ECDSA)\nand key length in the Token Binding message match those\n\nNEW:\nthe key parameters value in the Token Binding object match that\n"}, "context_segments": []}, {"current_segment": {"sid": 2214, "labels": "InformationProviding,ContextSetting", "content": ">                                              As described in\n>    [I-D.ietf-tokbind-https], Token Bindings of type\n>    \"referred_token_binding\" may have different key parameters than those\n>    negotiated via [I-D.ietf-tokbind-negotiation]."}, "context_segments": []}, {"current_segment": {"sid": 2215, "labels": "Question,ClarificationElicitation,InformationProviding,ProposeAction,InformationSeeking", "content": "\nrather than \"negotiated via [I-D.ietf-tokbind-negotiation]\", you mean\n\"negotiated with this server.\" -- yes ?\n\nsuggest:\n\nToken Bindings of types other than \"provided_token_binding\" may have\ndifferent key parameters than those negotiated for the current provided\nTLS Token Binding ID.\n"}, "context_segments": []}, {"current_segment": {"sid": 2216, "labels": "InformationProviding,ContextSetting", "content": ">    If the Token Binding message does not contain at least one\n>    TokenBinding structure, or the signature contained in a TokenBinding\n>    structure is invalid, the server MUST terminate the connection."}, "context_segments": []}, {"current_segment": {"sid": 2217, "labels": "ProposeAction,ProposeAction,InformationProviding", "content": "\nmake the next sentence a new parag:\n"}, "context_segments": []}, {"current_segment": {"sid": 2218, "labels": "ExtensionOfPrevious,ContextSetting,InformationProviding", "content": ">    Otherwise, the TLS Token Binding is successfully established and its\n>    ID can be provided to the application for security token validation."}, "context_segments": []}, {"current_segment": {"sid": 2219, "labels": "InformationProviding,InformationProviding,ProposeAction", "content": "\nsuggested enhancement:\n\nOtherwise, the Token Binding IDs for the token binding\ncontext between this client and server are successfully\nestablished. The TokenBindingID structure(s) are noted by\nthe client application, and they are extracted from the\nTokenBindingMessage and noted by the server side\napplication. The application may then use the Token Binding\nIDs for bound security token creation and validation (e.g., as in\n[I-D.ietf-tokbind-https]), or other application uses as appropriate.\n"}, "context_segments": []}, {"current_segment": {"sid": 2220, "labels": "ExtensionOfPrevious,InformationProviding,ExtensionOfPrevious,ContextSetting,ProposeAction", "content": "\ngiven the above, it seems section 5 below seems superfluous to me:\n"}, "context_segments": []}, {"current_segment": {"sid": 2221, "labels": "InformationProviding", "content": "> 5.  TLS Token Binding ID Format\n>    The ID of the TLS Token Binding established as a result of Token\n>    Binding message processing is a binary representation of the\n>    following structure:\n>    struct {\n>        TokenBindingKeyParameters key_parameters;\n>        select (key_parameters) {\n>            case rsa2048_pkcs1.5:\n>            case rsa2048_pss:\n>                RSAPublicKey rsapubkey;\n>            case ecdsap256:\n>                ECPoint point;\n>    } TokenBindingID;\n>    TokenBindingID contains the key parameters negotiated via\n>    [I-D.ietf-tokbind-negotiation].  TLS Token Binding ID can be obtained\n>    from the TokenBinding structure described in the \"Token Binding\n>    Protocol Message\" section of this document by discarding the token\n>    binding type, signature and extensions.  TLS Token Binding ID will be\n>    available at the application layer and used by the server to generate\n>    and verify bound tokens."}, "context_segments": []}, {"current_segment": {"sid": 2222, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\nSecurity Token Binding and Validation\n"}, "context_segments": []}, {"current_segment": {"sid": 2223, "labels": "InformationProviding,ExtensionOfPrevious,ContextSetting", "content": ">    Security tokens can be bound to the TLS layer either by embedding the\n>    Token Binding ID in the token, or by maintaining a database mapping\n>    tokens to Token Binding IDs.  The specific method of generating bound\n>    security tokens is application-defined and beyond the scope of this\n>    document."}, "context_segments": []}, {"current_segment": {"sid": 2224, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding,ProposeAction", "content": "\nsuggested rewrite:\n\nIn general, application layer security tokens are bound to the\nunderlying TLS connection by either embedding the connection's\nTokenBindingID within the security token, or by the application\nmaintaining a mapping of security tokens to TokenBindingIDs. The\nspecific method of binding application security tokens to underlying\nTLS connection(s) is application-defined and beyond the scope of this\nspecification.\n"}, "context_segments": []}, {"current_segment": {"sid": 2225, "labels": "InformationProviding,ContextSetting", "content": ">    Upon receipt of a security token, the server attempts to retrieve TLS\n>    Token Binding ID information from the token and from the TLS\n>    connection with the client.  Application-provided policy determines\n>    whether to honor non-bound (bearer) tokens.  If the token is bound\n>    and a TLS Token Binding has not been established for the client\n>    connection, the server MUST discard the token.  If the TLS Token\n>    Binding ID for the token does not match the TLS Token Binding ID\n>    established for the client connection, the server MUST discard the\n>    token."}, "context_segments": []}, {"current_segment": {"sid": 2226, "labels": "ExtensionOfPrevious,ProposeAction,InformationProviding", "content": "\nUpon receipt of a bound security token, the server-side application\nextracts the TokenBindingID(s) from the bound security token and from\nthe TLS connection with the client. Application-specific policy\ndetermines whether to honor unbound (i.e., bearer) security tokens.\nIf the security token is bound and a Token Binding has not been\nestablished for the client connection, the server MUST discard the\nsecurity token. If the TokenBindingID within the token does not match\nthe TokenBindingID established for the client connection, the server\nMUST discard the token.\n"}, "context_segments": []}, {"current_segment": {"sid": 2227, "labels": "Question,ExtensionOfPrevious,ClarificationElicitation,ExtensionOfPrevious,ProposeAction,InformationSeeking,InformationProviding", "content": "\nthough: what's the rationale for only discarding tokens and not doing\nanything further? see S7 above.\n"}, "context_segments": []}, {"current_segment": {"sid": 2228, "labels": "ExtensionOfPrevious,InformationProviding,ContextSetting", "content": "> 8.  Security Considerations\n> 8.1.  Security Token Replay\n>    The goal of the Token Binding protocol is to prevent attackers from\n>    exporting and replaying security tokens, thereby impersonating\n>    legitimate users and gaining access to protected resources.  Bound\n>    tokens can still be replayed by the malware present in the User\n>    Agent.  In order to export the token to another machine and\n>    successfully replay it, the attacker also needs to export the\n>    corresponding private key.  Token Binding private keys are therefore\n>    high-value assets and SHOULD be strongly protected, ideally by\n>    generating them in a hardware security module that prevents key\n>    export.\n>    The manner in which a token is bound to the TLS layer is application-\n>    defined and beyond the scope of this document.  However, the\n>    resulting bound token needs to be integrity-protected, so that an\n>    attacker cannot remove the binding or substitute a Token Binding ID\n>    of their choice without detection.\n> 8.2.  Downgrade Attacks\n>    The Token Binding protocol is only used when negotiated via\n>    [I-D.ietf-tokbind-negotiation] within the TLS handshake.  TLS\n>    prevents active attackers from modifying the messages of the TLS\n>    handshake, therefore it is not possible for the attacker to remove or\n>    modify the Token Binding Negotiation TLS Extension used to negotiate\n>    the Token Binding protocol and key parameters.  The signature\n>    algorithm and key length used in the TokenBinding of type\n>    \"provided_token_binding\" MUST match the parameters negotiated via\n>    [I-D.ietf-tokbind-negotiation]."}, "context_segments": []}, {"current_segment": {"sid": 2229, "labels": "ProposeAction,InformationProviding,ProposeAction", "content": "\nsuggest:\n\nTLS prevents active attackers from modifying the messages of the TLS\nhandshake, therefore it is not possible for the attacker to remove or\nmodify the Token Binding Negotiation TLS Extension used to negotiate\nthe Token Binding protocol version and key parameters. The key\nparameters used in TokenBindingMessage.TokenBinding structures of type\n\"provided_token_binding\" MUST match the key parameters negotiated via\n[I-D.ietf-tokbind-negotiation].\n"}, "context_segments": []}, {"current_segment": {"sid": 2230, "labels": "InformationProviding,ProposeAction,ContextSetting", "content": "> 8.3.  Privacy Considerations\n>    The Token Binding protocol uses persistent, long-lived TLS Token\n>    Binding IDs.  To protect privacy, TLS Token Binding IDs are never\n>    transmitted in clear text and can be reset by the user at any time,\n>    e.g. when clearing browser cookies.  Some applications offer a\n>    special privacy mode where they don't store or use tokens supplied by\n>    the server, e.g.  \"in private\" browsing.  When operating in this\n>    special privacy mode, applications SHOULD use newly generated Token\n>    Binding keys and delete them when exiting this mode, or else SHOULD\n>    NOT negotiate Token Binding at all.\n>    In order to prevent cooperating servers from linking user identities,\n>    different keys SHOULD be used by the client for connections to\n>    different servers, according to the token scoping rules of the\n>    application protocol."}, "context_segments": []}, {"current_segment": {"sid": 2231, "labels": "ExtensionOfPrevious,InformationProviding,ProposeAction", "content": "\nthe above admonition (paragraph) should be up above where generation of\nthe token binding key pair is stipulated.\n"}, "context_segments": []}, {"current_segment": {"sid": 2232, "labels": "InformationProviding", "content": ">    A server can use tokens and Token Binding IDs to track clients.\n>    Client applications that automatically limit the lifetime of tokens\n>    to maintain user privacy SHOULD apply the same validity time limits\n>    to Token Binding keys."}, "context_segments": []}, {"current_segment": {"sid": 2233, "labels": "Social", "content": "Hi Jeff,"}, "context_segments": []}, {"current_segment": {"sid": 2234, "labels": "Thanking,Thanking,Social", "content": "\nThanks for the review."}, "context_segments": []}, {"current_segment": {"sid": 2235, "labels": "NeutralResponse,NeutralResponse,StateDecision,InformationProviding", "content": "\nS1. If Dirk is OK with adding referred_token_binding type and its IANA registration to HTTPSTB, then when it's done, I will remove from TBPROTO. Although the need for referred_token_binding is general enough that I would be fine keeping it in TBPROTO."}, "context_segments": []}, {"current_segment": {"sid": 2236, "labels": "ClarificationElicitation,Question,ClarificationElicitation,InformationSeeking", "content": "\nS2. What is the use case? A client generating its own token and binding it to the client's TB key?"}, "context_segments": []}, {"current_segment": {"sid": 2237, "labels": "NeutralResponse,InformationProviding,NeutralResponse,ProposeAction", "content": "\nS3. TBPROTO already describes the specific parameters of the TLS exporter, including the context, per RFC5705, see TBPROTO section 3."}, "context_segments": []}, {"current_segment": {"sid": 2238, "labels": "NeutralResponse,Answer,Disagreement,InformationProviding", "content": "\nS5. Token Binding is a protocol; I don't see a need to describe APIs."}, "context_segments": []}, {"current_segment": {"sid": 2239, "labels": "Answer,InformationProviding,Answer,StateDecision", "content": "\nS6a. \"Reset\" means \"deleted\" in this case, perhaps it will be more clear if I use the latter term. Servers simply need to validate the binding: either the token is acceptable, or not. If not, client auth is re-done and a new bound token is generated. This is a flow that today's Web apps support."}, "context_segments": []}, {"current_segment": {"sid": 2240, "labels": "NeutralResponse,InformationProviding,Answer", "content": "\nS6b. TBPROTO has a new privacy consideration for this:\n\" A server can use tokens and Token Binding IDs to track clients.\nClient applications that automatically limit the lifetime of tokens\nto maintain user privacy SHOULD apply the same validity time limits\nto Token Binding keys.\""}, "context_segments": []}, {"current_segment": {"sid": 2241, "labels": "NeutralResponse,InformationProviding,Answer", "content": "\nS7. Servers handle invalid tokens today; TBPROTO describes new cases where a bound token must be considered invalid. At least in our deployment experience so far, TB validation failures are auto-handled by the existing application logic with no change."}, "context_segments": []}, {"current_segment": {"sid": 2242, "labels": "NeutralResponse,InformationSeeking,Answer,ProposeAction,InformationProviding", "content": "\nS8. Pull request will be appreciated:)."}, "context_segments": []}, {"current_segment": {"sid": 2243, "labels": "Question,Question,NeutralResponse,ProposeAction,InformationSeeking,InformationProviding", "content": "\nS9. How about \"Token Binding IDs MUST never be transmitted in clear text\"?"}, "context_segments": []}, {"current_segment": {"sid": 2244, "labels": "NeutralResponse,Disagreement,ContextSetting,StateDecision,InformationProviding", "content": "\nS10. We've discussed this before and I would prefer to keep the EMS mantra:). If more folks push for this, I'll make the change."}, "context_segments": []}, {"current_segment": {"sid": 2245, "labels": "NeutralResponse,InformationProviding,Answer", "content": "\nS11. TB type was removed from TB ID because it's contextual: the same TB is \"provided\" to the RP and \"referred\" to the IDP. Now if the IDP includes this \"referred\" TB ID in the token, the RP will see that the first byte does not match. At least in our implementation, this change reduces the number of SW components that need to understand the structure of TB IDs."}, "context_segments": []}, {"current_segment": {"sid": 2246, "labels": "Answer,NeutralResponse,InformationSeeking,Answer,Agreement,ContextSetting,ProposeAction,StateDecision,InformationProviding", "content": "\nS12. I think so, at least I don't see a reason why we would not do this. I did not make this change in -05, because I'd like to give folks time to think about this and speak up if they see a problem."}, "context_segments": []}, {"current_segment": {"sid": 2247, "labels": "InformationProviding,InformationSeeking,ContextSetting,ProposeAction", "content": "\nRegarding the editorial comments, but I'd appreciate pull requests:)."}, "context_segments": []}, {"current_segment": {"sid": 2772, "labels": "InformationProviding,ContextSetting,InformationProviding", "content": "\nThe document, along with other ballot positions, can be found here:\nhttps://datatracker.ietf.org/doc/draft-ietf-tls-tls13/"}, "context_segments": []}, {"current_segment": {"sid": 2773, "labels": "ContextSetting,ContextSetting,InformationProviding", "content": "\nCOMMENT:"}, "context_segments": []}, {"current_segment": {"sid": 2774, "labels": "InformationProviding,ContextSetting,ProposeAction", "content": "\nI found this document to be clear despite its length and complexity. The\nGen-ART reviewer wrote a lengthy review that I encourage the author/WG to look\nat. Many of his comments relate to stylistic preferences in the text and some\nof them might have been more actionable earlier in the process (e.g., the\nsuggestion for a minor error code, which I like but wouldn't hold this up\nover), but they are worth reviewing. For example, I was also confused about the\nuse of \"fatal alert\" versus \"error alert,\" and I also found the invocation of\nthe SNI check in 4.6.1 to be introduced abruptly."}, "context_segments": []}, {"current_segment": {"sid": 2775, "labels": "ContextSetting,InformationProviding,ContextSetting", "content": "Alissa Cooper has entered the following ballot position for\ndraft-ietf-tls-tls13-26: Yes"}, "context_segments": []}, {"current_segment": {"sid": 2776, "labels": "ProposeAction,ExtensionOfPrevious,InformationProviding", "content": "\nWhen responding, please keep the subject line intact and reply to all\nemail addresses included in the To and CC lines. (Feel free to cut this\nintroductory paragraph, however.)"}, "context_segments": []}, {"current_segment": {"sid": 2777, "labels": "InformationProviding,InformationProviding", "content": "\nPlease refer to https://www.ietf.org/iesg/statement/discuss-criteria.html\nfor more information about IESG DISCUSS and COMMENT positions."}, "context_segments": []}]